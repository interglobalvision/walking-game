//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/infinitedg:gsap/vendor/Draggable.js                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*!                                                                                                                    // 1
 * VERSION: 0.12.0                                                                                                     // 2
 * DATE: 2015-03-01                                                                                                    // 3
 * UPDATES AND DOCS AT: http://greensock.com                                                                           // 4
 *                                                                                                                     // 5
 * Requires TweenLite and CSSPlugin version 1.11.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://www.greensock.com/club/).
 *                                                                                                                     // 7
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.                                                   // 8
 * This work is subject to the terms at http://greensock.com/standard-license or for                                   // 9
 * Club GreenSock members, the software agreement that was issued with your membership.                                // 10
 *                                                                                                                     // 11
 * @author: Jack Doyle, jack@greensock.com                                                                             // 12
 */                                                                                                                    // 13
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {                                                     // 15
                                                                                                                       // 16
	"use strict";                                                                                                         // 17
                                                                                                                       // 18
	_gsScope._gsDefine("utils.Draggable", ["events.EventDispatcher","TweenLite"], function(EventDispatcher, TweenLite) {  // 19
                                                                                                                       // 20
		var _tempVarsXY = {css:{}}, //speed optimization - we reuse the same vars object for x/y TweenLite.set() calls to minimize garbage collection tasks and improve performance.
			_tempVarsX = {css:{}},                                                                                              // 22
			_tempVarsY = {css:{}},                                                                                              // 23
			_tempVarsRotation = {css:{}},                                                                                       // 24
			_globals = _gsScope._gsDefine.globals,                                                                              // 25
			_tempEvent = {}, //for populating with pageX/pageY in old versions of IE                                            // 26
			_doc = document,                                                                                                    // 27
			_docElement = _doc.documentElement || {},                                                                           // 28
			_emptyArray = [],                                                                                                   // 29
			_emptyFunc = function() { return false; },                                                                          // 30
			_RAD2DEG = 180 / Math.PI,                                                                                           // 31
			_max = 999999999999999,                                                                                             // 32
			_getTime = Date.now || function() {return new Date().getTime();},                                                   // 33
			_isOldIE = !!(!_doc.addEventListener && _doc.all),                                                                  // 34
			_placeholderDiv = _doc.createElement("div"),                                                                        // 35
			_renderQueue = [],                                                                                                  // 36
			_lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
			_lookupCount = 0,                                                                                                   // 38
			_clickableTagExp = /^(?:a|input|textarea|button|select)$/i,                                                         // 39
			_dragCount = 0, //total number of elements currently being dragged                                                  // 40
			_prefix,                                                                                                            // 41
			_isMultiTouching,                                                                                                   // 42
			_lastDragTime = 0,                                                                                                  // 43
			_windowProxy = {}, //memory/performance optimizatin - we reuse this object during autoScroll to store window-related bounds/offsets.
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				if (typeof(a) === "string") {                                                                                      // 46
					a = TweenLite.selector(a);                                                                                        // 47
				}                                                                                                                  // 48
				if (!a || a.nodeType) { //if it's not an array, wrap it in one.                                                    // 49
					return [a];                                                                                                       // 50
				}                                                                                                                  // 51
				var b = [],                                                                                                        // 52
					l = a.length,                                                                                                     // 53
					i;                                                                                                                // 54
				for (i = 0; i !== l; b.push(a[i++]));                                                                              // 55
				return b;                                                                                                          // 56
			},                                                                                                                  // 57
			ThrowPropsPlugin,                                                                                                   // 58
                                                                                                                       // 59
			_renderQueueTick = function() {                                                                                     // 60
				var i = _renderQueue.length;                                                                                       // 61
				while (--i > -1) {                                                                                                 // 62
					_renderQueue[i]();                                                                                                // 63
				}                                                                                                                  // 64
			},                                                                                                                  // 65
			_addToRenderQueue = function(func) {                                                                                // 66
				_renderQueue.push(func);                                                                                           // 67
				if (_renderQueue.length === 1) {                                                                                   // 68
					TweenLite.ticker.addEventListener("tick", _renderQueueTick, this, false, 1);                                      // 69
				}                                                                                                                  // 70
			},                                                                                                                  // 71
			_removeFromRenderQueue = function(func) {                                                                           // 72
				var i = _renderQueue.length;                                                                                       // 73
				while (--i > -1) {                                                                                                 // 74
					if (_renderQueue[i] === func) {                                                                                   // 75
						_renderQueue.splice(i, 1);                                                                                       // 76
					}                                                                                                                 // 77
				}                                                                                                                  // 78
				TweenLite.to(_renderQueueTimeout, 0, {overwrite:"all", delay:15, onComplete:_renderQueueTimeout}); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
			},                                                                                                                  // 80
			_renderQueueTimeout = function() {                                                                                  // 81
				if (!_renderQueue.length) {                                                                                        // 82
					TweenLite.ticker.removeEventListener("tick", _renderQueueTick);                                                   // 83
				}                                                                                                                  // 84
			},                                                                                                                  // 85
                                                                                                                       // 86
			_extend = function(obj, defaults) {                                                                                 // 87
				var p;                                                                                                             // 88
				for (p in defaults) {                                                                                              // 89
					if (obj[p] === undefined) {                                                                                       // 90
						obj[p] = defaults[p];                                                                                            // 91
					}                                                                                                                 // 92
				}                                                                                                                  // 93
				return obj;                                                                                                        // 94
			},                                                                                                                  // 95
			_getDocScrollTop = function() {                                                                                     // 96
				return (window.pageYOffset != null) ? window.pageYOffset : (_doc.scrollTop != null) ? _doc.scrollTop : _docElement.scrollTop || _doc.body.scrollTop || 0;
			},                                                                                                                  // 98
			_getDocScrollLeft = function() {                                                                                    // 99
				return (window.pageXOffset != null) ? window.pageXOffset : (_doc.scrollLeft != null) ? _doc.scrollLeft : _docElement.scrollLeft || _doc.body.scrollLeft || 0;
			},                                                                                                                  // 101
			_addScrollListener = function(e, callback) {                                                                        // 102
				_addListener(e, "scroll", callback);                                                                               // 103
				if (!_isRoot(e.parentNode)) {                                                                                      // 104
					_addScrollListener(e.parentNode, callback);                                                                       // 105
				}                                                                                                                  // 106
			},                                                                                                                  // 107
			_removeScrollListener = function(e, callback) {                                                                     // 108
				_removeListener(e, "scroll", callback);                                                                            // 109
				if (!_isRoot(e.parentNode)) {                                                                                      // 110
					_removeScrollListener(e.parentNode, callback);                                                                    // 111
				}                                                                                                                  // 112
			},                                                                                                                  // 113
			_isRoot = function (e) {                                                                                            // 114
				return !!(!e || e === _docElement || e === _doc || e === _doc.body || e === window || !e.nodeType || !e.parentNode);
			},                                                                                                                  // 116
			_getMaxScroll = function(element, axis) {                                                                           // 117
				var dim = (axis === "x") ? "Width" : "Height",                                                                     // 118
					scroll = "scroll" + dim,                                                                                          // 119
					client = "client" + dim,                                                                                          // 120
					body = _doc.body;                                                                                                 // 121
				return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], body[scroll]) - (window["inner" + dim] || _docElement[client] || body[client]) : element[scroll] - element[client]);
			},                                                                                                                  // 123
			_recordMaxScrolls = function(e) { //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
				var isRoot = _isRoot(e),                                                                                           // 125
					x = _getMaxScroll(e, "x"),                                                                                        // 126
					y = _getMaxScroll(e, "y");                                                                                        // 127
				if (isRoot) {                                                                                                      // 128
					e = _windowProxy;                                                                                                 // 129
				} else {                                                                                                           // 130
					_recordMaxScrolls(e.parentNode);                                                                                  // 131
				}                                                                                                                  // 132
				e._gsMaxScrollX = x;                                                                                               // 133
				e._gsMaxScrollY = y;                                                                                               // 134
				e._gsScrollX = e.scrollLeft || 0;                                                                                  // 135
				e._gsScrollY = e.scrollTop || 0;                                                                                   // 136
			},                                                                                                                  // 137
                                                                                                                       // 138
			//just used for IE8 and earlier to normalize events and populate pageX/pageY                                        // 139
			_populateIEEvent = function(e, preventDefault) {                                                                    // 140
				e = e || window.event;                                                                                             // 141
				_tempEvent.pageX = e.clientX + _doc.body.scrollLeft + _docElement.scrollLeft;                                      // 142
				_tempEvent.pageY = e.clientY + _doc.body.scrollTop + _docElement.scrollTop;                                        // 143
				if (preventDefault) {                                                                                              // 144
					e.returnValue = false;                                                                                            // 145
				}                                                                                                                  // 146
				return _tempEvent;                                                                                                 // 147
			},                                                                                                                  // 148
                                                                                                                       // 149
			//grabs the first element it finds (and we include the window as an element), so if it's selector text, it'll feed that value to TweenLite.selector, if it's a jQuery object or some other selector engine's result, it'll grab the first one, and same for an array. If the value doesn't contain a DOM element, it'll just return null.
			_unwrapElement = function(value) {                                                                                  // 151
				if (!value) {                                                                                                      // 152
					return value;                                                                                                     // 153
				}                                                                                                                  // 154
				if (typeof(value) === "string") {                                                                                  // 155
					value = TweenLite.selector(value);                                                                                // 156
				}                                                                                                                  // 157
				if (value.length && value !== window && value[0] && value[0].style && !value.nodeType) {                           // 158
					value = value[0];                                                                                                 // 159
				}                                                                                                                  // 160
				return (value === window || (value.nodeType && value.style)) ? value : null;                                       // 161
			},                                                                                                                  // 162
                                                                                                                       // 163
			_checkPrefix = function(e, p) {                                                                                     // 164
				var s = e.style,                                                                                                   // 165
					capped, i, a;                                                                                                     // 166
				if (s[p] === undefined) {                                                                                          // 167
					a = ["O","Moz","ms","Ms","Webkit"];                                                                               // 168
					i = 5;                                                                                                            // 169
					capped = p.charAt(0).toUpperCase() + p.substr(1);                                                                 // 170
					while (--i > -1 && s[a[i]+capped] === undefined) { }                                                              // 171
					if (i < 0) {                                                                                                      // 172
						return "";                                                                                                       // 173
					}                                                                                                                 // 174
					_prefix = (i === 3) ? "ms" : a[i];                                                                                // 175
					p = _prefix + capped;                                                                                             // 176
				}                                                                                                                  // 177
				return p;                                                                                                          // 178
			},                                                                                                                  // 179
                                                                                                                       // 180
			_setStyle = function(e, p, value) {                                                                                 // 181
				var s = e.style;                                                                                                   // 182
				if (!s) {                                                                                                          // 183
					return;                                                                                                           // 184
				}                                                                                                                  // 185
				if (s[p] === undefined) {                                                                                          // 186
					p = _checkPrefix(e, p);                                                                                           // 187
				}                                                                                                                  // 188
				if (value == null) {                                                                                               // 189
					if (s.removeProperty) {                                                                                           // 190
						s.removeProperty(p.replace(/([A-Z])/g, "-$1").toLowerCase());                                                    // 191
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"                         // 192
						s.removeAttribute(p);                                                                                            // 193
					}                                                                                                                 // 194
				} else if (s[p] !== undefined) {                                                                                   // 195
					s[p] = value;                                                                                                     // 196
				}                                                                                                                  // 197
			},                                                                                                                  // 198
                                                                                                                       // 199
			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : _emptyFunc,                              // 200
			_horizExp = /(?:Left|Right|Width)/i,                                                                                // 201
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,                                                                               // 202
			_convertToPixels = function(t, p, v, sfx, recurse) {                                                                // 203
				if (sfx === "px" || !sfx) { return v; }                                                                            // 204
				if (sfx === "auto" || !v) { return 0; }                                                                            // 205
				var horiz = _horizExp.test(p),                                                                                     // 206
					node = t,                                                                                                         // 207
					style = _tempDiv.style,                                                                                           // 208
					neg = (v < 0),                                                                                                    // 209
					pix;                                                                                                              // 210
				if (neg) {                                                                                                         // 211
					v = -v;                                                                                                           // 212
				}                                                                                                                  // 213
				if (sfx === "%" && p.indexOf("border") !== -1) {                                                                   // 214
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);                                                       // 215
				} else {                                                                                                           // 216
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position", true) + ";line-height:0;";              // 217
					if (sfx === "%" || !node.appendChild) {                                                                           // 218
						node = t.parentNode || _doc.body;                                                                                // 219
						style[(horiz ? "width" : "height")] = v + sfx;                                                                   // 220
					} else {                                                                                                          // 221
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;                                                 // 222
					}                                                                                                                 // 223
					node.appendChild(_tempDiv);                                                                                       // 224
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);                                             // 225
					node.removeChild(_tempDiv);                                                                                       // 226
					if (pix === 0 && !recurse) {                                                                                      // 227
						pix = _convertToPixels(t, p, v, sfx, true);                                                                      // 228
					}                                                                                                                 // 229
				}                                                                                                                  // 230
				return neg ? -pix : pix;                                                                                           // 231
			},                                                                                                                  // 232
			_calculateOffset = function(t, p) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", true) !== "absolute") { return 0; }                                                   // 234
				var dim = ((p === "left") ? "Left" : "Top"),                                                                       // 235
					v = _getStyle(t, "margin" + dim, true);                                                                           // 236
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), (v + "").replace(_suffixExp, "")) || 0);         // 237
			},                                                                                                                  // 238
                                                                                                                       // 239
			_getStyle = function(element, prop, keepUnits) {                                                                    // 240
				var rv = (element._gsTransform || {})[prop],                                                                       // 241
					cs;                                                                                                               // 242
				if (rv || rv === 0) {                                                                                              // 243
					return rv;                                                                                                        // 244
				} else if (element.style[prop]) {                                                                                  // 245
					rv = element.style[prop];                                                                                         // 246
				} else if ((cs = _getComputedStyle(element))) {                                                                    // 247
					rv = cs.getPropertyValue(prop.replace(/([A-Z])/g, "-$1").toLowerCase());                                          // 248
					rv = (rv || cs.length) ? rv : cs[prop]; //Opera behaves VERY strangely - length is usually 0 and cs[prop] is the only way to get accurate results EXCEPT when checking for -o-transform which only works with cs.getPropertyValue()!
				} else if (element.currentStyle) {                                                                                 // 250
					rv = element.currentStyle[prop];                                                                                  // 251
				}                                                                                                                  // 252
				if (rv === "auto" && (prop === "top" || prop === "left")) {                                                        // 253
					rv = _calculateOffset(element, prop);                                                                             // 254
				}                                                                                                                  // 255
				return keepUnits ? rv : parseFloat(rv) || 0;                                                                       // 256
			},                                                                                                                  // 257
                                                                                                                       // 258
			_dispatchEvent = function(instance, type, callbackName) {                                                           // 259
				var vars = instance.vars,                                                                                          // 260
					callback = vars[callbackName],                                                                                    // 261
					listeners = instance._listeners[type];                                                                            // 262
				if (typeof(callback) === "function") {                                                                             // 263
					callback.apply(vars[callbackName + "Scope"] || instance, vars[callbackName + "Params"] || [instance.pointerEvent]);
				}                                                                                                                  // 265
				if (listeners) {                                                                                                   // 266
					instance.dispatchEvent(type);                                                                                     // 267
				}                                                                                                                  // 268
			},                                                                                                                  // 269
			_getBounds = function(obj, context) { //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
				var e = _unwrapElement(obj),                                                                                       // 271
					top, left, offset;                                                                                                // 272
				if (!e) {                                                                                                          // 273
					if (obj.left !== undefined) {                                                                                     // 274
						offset = _getOffsetTransformOrigin(context); //the bounds should be relative to the origin                       // 275
						return {left: obj.left - offset.x, top: obj.top - offset.y, width: obj.width, height: obj.height};               // 276
					}                                                                                                                 // 277
					left = obj.min || obj.minX || obj.minRotation || 0;                                                               // 278
					top = obj.min || obj.minY || 0;                                                                                   // 279
					return {left:left, top:top, width:(obj.max || obj.maxX || obj.maxRotation || 0) - left, height:(obj.max || obj.maxY || 0) - top};
				}                                                                                                                  // 281
				return _getElementBounds(e, context);                                                                              // 282
			},                                                                                                                  // 283
                                                                                                                       // 284
			_tempDiv = _doc.createElement("div"),                                                                               // 285
			_supports3D = (_checkPrefix(_tempDiv, "perspective") !== ""),                                                       // 286
                                                                                                                       // 287
                                                                                                                       // 288
			// start matrix and point conversion methods...                                                                     // 289
			_originProp = _checkPrefix(_tempDiv, "transformOrigin").replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
			_transformProp = _checkPrefix(_tempDiv, "transform"),                                                               // 291
			_transformCSSProp = _transformProp.replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),                  // 292
			_point1 = {}, //we reuse _point1 and _point2 objects inside matrix and point conversion methods to conserve memory and minimize garbage collection tasks.
			_point2 = {},                                                                                                       // 294
			_hasReparentBug, //we'll set this inside the _getOffset2DMatrix() method after the body has loaded.                 // 295
			_dummySVGRect = (function() {                                                                                       // 296
				if (_isOldIE) {                                                                                                    // 297
					return;                                                                                                           // 298
				}                                                                                                                  // 299
				var url = "http://www.w3.org/2000/svg",                                                                            // 300
					svg = _doc.createElementNS(url, "svg"),                                                                           // 301
					e = _doc.createElementNS(url, "rect");                                                                            // 302
				e.setAttributeNS(null, "width", "10");                                                                             // 303
				e.setAttributeNS(null, "height", "10");                                                                            // 304
				svg.appendChild(e);                                                                                                // 305
				return svg;                                                                                                        // 306
			}()),                                                                                                               // 307
			_SVGElement = window.SVGElement,                                                                                    // 308
			_isSVG = function(e) {                                                                                              // 309
				return !!(_SVGElement && typeof(e.getBBox) === "function" && e.getCTM && (!e.parentNode || (e.parentNode.getBBox && e.parentNode.getCTM)));
			},                                                                                                                  // 311
			_svgAttributes = ["class","viewBox","width","height","xml:space"],                                                  // 312
			_getSVGOffsets = function(e) { //SVG elements don't always report offsetTop/offsetLeft/offsetParent at all (I'm looking at you, Firefox 29), so we have to do some work to manufacture those values. You can pass any SVG element and it'll spit back an object with offsetTop, offsetLeft, offsetParent, scaleX, and scaleY properties. We need the scaleX and scaleY to handle the way SVG can resize itself based on the container.
				if (!e.getBoundingClientRect || !e.parentNode) {                                                                   // 314
					return {offsetTop:0, offsetLeft:0, scaleX:1, scaleY:1, offsetParent:_docElement};                                 // 315
				}                                                                                                                  // 316
				if (e._gsSVGData && e._gsSVGData.lastUpdate === TweenLite.ticker.frame) {                                          // 317
					return e._gsSVGData;                                                                                              // 318
				}                                                                                                                  // 319
				var curElement = e,                                                                                                // 320
					prevCSS = e.style.cssText,                                                                                        // 321
					data = e._gsSVGData = e._gsSVGData || {},                                                                         // 322
					eRect, parentRect, offsetParent, rRect, i, a;                                                                     // 323
				if ((e.nodeName + "").toLowerCase() !== "svg" && e.getBBox) { //if it's a nested/child SVG element, we must find the parent SVG canvas and measure the offset from there.
					curElement = e.parentNode;                                                                                        // 325
					eRect = e.getBBox();                                                                                              // 326
					while (curElement && (curElement.nodeName + "").toLowerCase() !== "svg") {                                        // 327
						curElement = curElement.parentNode;                                                                              // 328
					}                                                                                                                 // 329
					data = _getSVGOffsets(curElement);                                                                                // 330
					return {offsetTop:eRect.y * data.scaleY, offsetLeft:eRect.x * data.scaleX, scaleX:data.scaleX, scaleY:data.scaleY, offsetParent:curElement || _docElement};
				}                                                                                                                  // 332
				while (!curElement.offsetParent && curElement.parentNode) {                                                        // 333
					curElement = curElement.parentNode;                                                                               // 334
				}                                                                                                                  // 335
				e.parentNode.insertBefore(_dummySVGRect, e); //Firefox measures things based NOT on the <svg> itself, but on the bounds of the child elements, so we add a dummy SVG object temporarily in the original one's spot which has a 10x10 <rect> in the upper left corner to make sure we're getting accurate results.
				e.parentNode.removeChild(e);                                                                                       // 337
				_dummySVGRect.style.cssText = prevCSS;                                                                             // 338
				_dummySVGRect.style[_transformProp] = "none";                                                                      // 339
				i = _svgAttributes.length;                                                                                         // 340
				while (--i > -1) {                                                                                                 // 341
					a = e.getAttribute(_svgAttributes[i]);                                                                            // 342
					if (a) {                                                                                                          // 343
						_dummySVGRect.setAttribute(_svgAttributes[i], a);                                                                // 344
					} else {                                                                                                          // 345
						_dummySVGRect.removeAttribute(_svgAttributes[i]);                                                                // 346
					}                                                                                                                 // 347
				}                                                                                                                  // 348
				eRect = _dummySVGRect.getBoundingClientRect();                                                                     // 349
				rRect = _dummySVGRect.firstChild.getBoundingClientRect();                                                          // 350
				offsetParent = curElement.offsetParent;                                                                            // 351
				if (offsetParent) {                                                                                                // 352
					if (offsetParent === _doc.body && _docElement) {                                                                  // 353
						offsetParent = _docElement; //to avoid problems with margins/padding on the <body>                               // 354
					}                                                                                                                 // 355
					parentRect = offsetParent.getBoundingClientRect();                                                                // 356
				} else {                                                                                                           // 357
					parentRect = {top:-_getDocScrollTop(), left:-_getDocScrollLeft()};                                                // 358
				}                                                                                                                  // 359
				_dummySVGRect.parentNode.insertBefore(e, _dummySVGRect);                                                           // 360
				e.parentNode.removeChild(_dummySVGRect);                                                                           // 361
				data.scaleX = rRect.width / 10;                                                                                    // 362
				data.scaleY = rRect.height / 10;                                                                                   // 363
				data.offsetLeft = eRect.left - parentRect.left;                                                                    // 364
				data.offsetTop = eRect.top - parentRect.top;                                                                       // 365
				data.offsetParent = curElement.offsetParent || _docElement;                                                        // 366
				data.lastUpdate = TweenLite.ticker.frame;                                                                          // 367
				return data;                                                                                                       // 368
			},                                                                                                                  // 369
			_getOffsetTransformOrigin = function(e, decoratee) {                                                                // 370
				decoratee = decoratee || {};                                                                                       // 371
				if (!e || e === _docElement || !e.parentNode) {                                                                    // 372
					return {x:0, y:0};                                                                                                // 373
				}                                                                                                                  // 374
				var cs = _getComputedStyle(e),                                                                                     // 375
					v = (_originProp && cs) ? cs.getPropertyValue(_originProp) : "50% 50%",                                           // 376
					a = v.split(" "),                                                                                                 // 377
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],                              // 378
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];                              // 379
				if (y === "center" || y == null) {                                                                                 // 380
					y = "50%";                                                                                                        // 381
				}                                                                                                                  // 382
				if (x === "center" || isNaN(parseFloat(x))) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";                                                                                                        // 384
				}                                                                                                                  // 385
				if (e.getBBox && _isSVG(e)) { //SVG elements must be handled in a special way because their origins are calculated from the parent SVG canvas origin
					if (!e._gsTransform) {                                                                                            // 387
						TweenLite.set(e, {x:"+=0"}); //forces creation of the _gsTransform where we store all the transform components including xOrigin and yOrigin for SVG elements, as of GSAP 1.15.0 which also takes care of calculating the origin from the upper left corner of the SVG canvas.
						if (e._gsTransform.xOrigin === undefined) {                                                                      // 389
							console.log("Draggable requires at least GSAP 1.16.0");                                                         // 390
						}                                                                                                                // 391
					}                                                                                                                 // 392
					v = e.getBBox();                                                                                                  // 393
					a = _getSVGOffsets(e);                                                                                            // 394
					decoratee.x = (e._gsTransform.xOrigin - v.x) * a.scaleX;                                                          // 395
					decoratee.y = (e._gsTransform.yOrigin - v.y) * a.scaleY;                                                          // 396
				} else {                                                                                                           // 397
					decoratee.x = ((x.indexOf("%") !== -1) ? e.offsetWidth * parseFloat(x) / 100 : parseFloat(x));                    // 398
					decoratee.y = ((y.indexOf("%") !== -1) ? e.offsetHeight * parseFloat(y) / 100 : parseFloat(y));                   // 399
				}                                                                                                                  // 400
				return decoratee;                                                                                                  // 401
			},                                                                                                                  // 402
			_getOffset2DMatrix = function(e, offsetOrigin, parentOffsetOrigin) {                                                // 403
				var cs, m, parent, offsetParent, isRoot, offsets;                                                                  // 404
				if (e === window || !e || !e.parentNode) {                                                                         // 405
					return [1,0,0,1,0,0];                                                                                             // 406
				}                                                                                                                  // 407
				cs = _getComputedStyle(e);                                                                                         // 408
				m = cs ? cs.getPropertyValue(_transformCSSProp) : e.currentStyle ? e.currentStyle[_transformProp] : "1,0,0,1,0,0"; // 409
				m = (m + "").match(/(?:\-|\b)[\d\-\.e]+\b/g) || [1,0,0,1,0,0];                                                     // 410
				if (m.length > 6) {                                                                                                // 411
					m = [m[0], m[1], m[4], m[5], m[12], m[13]];                                                                       // 412
				}                                                                                                                  // 413
				if (offsetOrigin) {                                                                                                // 414
					parent = e.parentNode;                                                                                            // 415
					offsets = ((e.getBBox && _isSVG(e)) || (e.offsetLeft === undefined && (e.nodeName + "").toLowerCase() === "svg")) ? _getSVGOffsets(e) : e;
					offsetParent = offsets.offsetParent;                                                                              // 417
					isRoot = (parent === _docElement || parent === _doc.body);                                                        // 418
                                                                                                                       // 419
					//some browsers (like Chrome 31) have a bug that causes the offsetParent not to report correctly when a transform is applied to an element's parent, so the offsetTop and offsetLeft are measured from the parent instead of whatever the offsetParent reports as. For example, put an absolutely-positioned child div inside a position:static parent, then check the child's offsetTop before and after you apply a transform, like rotate(1deg). You'll see that it changes, but the offsetParent doesn't. So we must sense this condition here (and we can only do it after the body has loaded, as browsers don't accurately report offsets otherwise) and set a variable that we can easily reference later.
					if (_hasReparentBug === undefined && _doc.body && _transformProp) {                                               // 421
						_hasReparentBug = (function() {                                                                                  // 422
							var parent = _doc.createElement("div"),                                                                         // 423
								child = _doc.createElement("div"),                                                                             // 424
								oldOffsetParent, value;                                                                                        // 425
							child.style.position = "absolute";                                                                              // 426
							_doc.body.appendChild(parent);                                                                                  // 427
							parent.appendChild(child);                                                                                      // 428
							oldOffsetParent = child.offsetParent;                                                                           // 429
							parent.style[_transformProp] = "rotate(1deg)";                                                                  // 430
							value = (child.offsetParent === oldOffsetParent);                                                               // 431
							_doc.body.removeChild(parent);                                                                                  // 432
							return value;                                                                                                   // 433
						}());                                                                                                            // 434
					}                                                                                                                 // 435
					m[4] = Number(m[4]) + offsetOrigin.x + (offsets.offsetLeft || 0) - parentOffsetOrigin.x - (isRoot ? 0 : parent.scrollLeft) + (offsetParent ? parseInt(_getStyle(offsetParent, "borderLeftWidth"), 10) || 0 : 0);
					m[5] = Number(m[5]) + offsetOrigin.y + (offsets.offsetTop || 0) - parentOffsetOrigin.y - (isRoot ? 0 : parent.scrollTop) + (offsetParent ? parseInt(_getStyle(offsetParent, "borderTopWidth"), 10) || 0 : 0);
					if (parent && parent.offsetParent === offsetParent && (!_hasReparentBug || _getOffset2DMatrix(parent).join("") === "100100")) {
						m[4] -= parent.offsetLeft || 0;                                                                                  // 439
						m[5] -= parent.offsetTop || 0;                                                                                   // 440
					}                                                                                                                 // 441
					if (parent && _getStyle(e, "position", true) === "fixed") { //fixed position elements should factor in the scroll position of the document.
						m[4] += _getDocScrollLeft();                                                                                     // 443
						m[5] += _getDocScrollTop();                                                                                      // 444
					}                                                                                                                 // 445
				}                                                                                                                  // 446
				return m;                                                                                                          // 447
			},                                                                                                                  // 448
			_getConcatenatedMatrix = function(e, invert) {                                                                      // 449
				if (!e || e === window || !e.parentNode) {                                                                         // 450
					return [1,0,0,1,0,0];                                                                                             // 451
				}                                                                                                                  // 452
				//note: we keep reusing _point1 and _point2 in order to minimize memory usage and garbage collection chores.       // 453
				var originOffset = _getOffsetTransformOrigin(e, _point1),                                                          // 454
					parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, _point2),                                            // 455
					m = _getOffset2DMatrix(e, originOffset, parentOriginOffset),                                                      // 456
					a, b, c, d, tx, ty, m2, determinant;                                                                              // 457
				while ((e = e.parentNode) && e.parentNode && e !== _docElement) {                                                  // 458
					originOffset = parentOriginOffset;                                                                                // 459
					parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, (originOffset === _point1) ? _point2 : _point1);     // 460
					m2 = _getOffset2DMatrix(e, originOffset, parentOriginOffset);                                                     // 461
					a = m[0];                                                                                                         // 462
					b = m[1];                                                                                                         // 463
					c = m[2];                                                                                                         // 464
					d = m[3];                                                                                                         // 465
					tx = m[4];                                                                                                        // 466
					ty = m[5];                                                                                                        // 467
					m[0] = a * m2[0] + b * m2[2];                                                                                     // 468
					m[1] = a * m2[1] + b * m2[3];                                                                                     // 469
					m[2] = c * m2[0] + d * m2[2];                                                                                     // 470
					m[3] = c * m2[1] + d * m2[3];                                                                                     // 471
					m[4] = tx * m2[0] + ty * m2[2] + m2[4];                                                                           // 472
					m[5] = tx * m2[1] + ty * m2[3] + m2[5];                                                                           // 473
				}                                                                                                                  // 474
				if (invert) {                                                                                                      // 475
					a = m[0];                                                                                                         // 476
					b = m[1];                                                                                                         // 477
					c = m[2];                                                                                                         // 478
					d = m[3];                                                                                                         // 479
					tx = m[4];                                                                                                        // 480
					ty = m[5];                                                                                                        // 481
					determinant = (a * d - b * c);                                                                                    // 482
					m[0] = d / determinant;                                                                                           // 483
					m[1] = -b / determinant;                                                                                          // 484
					m[2] = -c / determinant;                                                                                          // 485
					m[3] = a / determinant;                                                                                           // 486
					m[4] = (c * ty - d * tx) / determinant;                                                                           // 487
					m[5] = -(a * ty - b * tx) / determinant;                                                                          // 488
				}                                                                                                                  // 489
				return m;                                                                                                          // 490
			},                                                                                                                  // 491
			_localToGlobal = function(e, p, decoratee) {                                                                        // 492
				var m = _getConcatenatedMatrix(e),                                                                                 // 493
					x = p.x,                                                                                                          // 494
					y = p.y;                                                                                                          // 495
				decoratee = (decoratee === true) ? p : decoratee || {};                                                            // 496
				decoratee.x = x * m[0] + y * m[2] + m[4];                                                                          // 497
				decoratee.y = x * m[1] + y * m[3] + m[5];                                                                          // 498
				return decoratee;                                                                                                  // 499
			},                                                                                                                  // 500
			_localizePoint = function(p, localToGlobal, globalToLocal) {                                                        // 501
				var x = p.x * localToGlobal[0] + p.y * localToGlobal[2] + localToGlobal[4],                                        // 502
					y = p.x * localToGlobal[1] + p.y * localToGlobal[3] + localToGlobal[5];                                           // 503
				p.x = x * globalToLocal[0] + y * globalToLocal[2] + globalToLocal[4];                                              // 504
				p.y = x * globalToLocal[1] + y * globalToLocal[3] + globalToLocal[5];                                              // 505
				return p;                                                                                                          // 506
			},                                                                                                                  // 507
			_getElementBounds = function(e, context) {                                                                          // 508
				var origin, left, right, top, bottom, mLocalToGlobal, mGlobalToLocal, p1, p2, p3, p4;                              // 509
				if (e === window) {                                                                                                // 510
					top = _getDocScrollTop();                                                                                         // 511
					left = _getDocScrollLeft();                                                                                       // 512
					right = left + (_docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0);                           // 513
                                                                                                                       // 514
					bottom = top + (((e.innerHeight || 0) - 20 < _docElement.clientHeight) ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this. Also note that IE8 doesn't support window.innerHeight.
				} else {                                                                                                           // 516
					origin = _getOffsetTransformOrigin(e);                                                                            // 517
					left = -origin.x;                                                                                                 // 518
					right = left + e.offsetWidth;                                                                                     // 519
					top = -origin.y;                                                                                                  // 520
					bottom = top + e.offsetHeight;                                                                                    // 521
				}                                                                                                                  // 522
				if (e === context) {                                                                                               // 523
					return {left:left, top:top, width: right - left, height: bottom - top};                                           // 524
				}                                                                                                                  // 525
				mLocalToGlobal = _getConcatenatedMatrix(e);                                                                        // 526
				mGlobalToLocal = _getConcatenatedMatrix(context, true);                                                            // 527
				p1 = _localizePoint({x:left, y:top}, mLocalToGlobal, mGlobalToLocal);                                              // 528
				p2 = _localizePoint({x:right, y:top}, mLocalToGlobal, mGlobalToLocal);                                             // 529
				p3 = _localizePoint({x:right, y:bottom}, mLocalToGlobal, mGlobalToLocal);                                          // 530
				p4 = _localizePoint({x:left, y:bottom}, mLocalToGlobal, mGlobalToLocal);                                           // 531
				left = Math.min(p1.x, p2.x, p3.x, p4.x);                                                                           // 532
				top = Math.min(p1.y, p2.y, p3.y, p4.y);                                                                            // 533
				return {left:left, top:top, width:Math.max(p1.x, p2.x, p3.x, p4.x) - left, height:Math.max(p1.y, p2.y, p3.y, p4.y) - top};
			},                                                                                                                  // 535
			// end matrix and point conversion methods                                                                          // 536
                                                                                                                       // 537
                                                                                                                       // 538
                                                                                                                       // 539
			_isArrayLike = function(e) {                                                                                        // 540
				return (e.length && e[0] && ((e[0].nodeType && e[0].style && !e.nodeType) || (e[0].length && e[0][0]))) ? true : false; //could be an array of jQuery objects too, so accommodate that.
			},                                                                                                                  // 542
                                                                                                                       // 543
			_flattenArray = function(a) {                                                                                       // 544
				var result = [],                                                                                                   // 545
					l = a.length,                                                                                                     // 546
					i, e, j;                                                                                                          // 547
				for (i = 0; i < l; i++) {                                                                                          // 548
					e = a[i];                                                                                                         // 549
					if (_isArrayLike(e)) {                                                                                            // 550
						j = e.length;                                                                                                    // 551
						for (j = 0; j < e.length; j++) {                                                                                 // 552
							result.push(e[j]);                                                                                              // 553
						}                                                                                                                // 554
					} else {                                                                                                          // 555
						result.push(e);                                                                                                  // 556
					}                                                                                                                 // 557
				}                                                                                                                  // 558
				return result;                                                                                                     // 559
			},                                                                                                                  // 560
                                                                                                                       // 561
			_isTouchDevice = (("ontouchstart" in _docElement) && ("orientation" in window)),                                    // 562
			_touchEventLookup = (function(types) { //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
				var standard = types.split(","),                                                                                   // 564
					converted = ((_tempDiv.onpointerdown !== undefined) ? "pointerdown,pointermove,pointerup,pointercancel" : (_tempDiv.onmspointerdown !== undefined) ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
					obj = {},                                                                                                         // 566
					i = 8;                                                                                                            // 567
				while (--i > -1) {                                                                                                 // 568
					obj[standard[i]] = converted[i];                                                                                  // 569
					obj[converted[i]] = standard[i];                                                                                  // 570
				}                                                                                                                  // 571
				return obj;                                                                                                        // 572
			}("touchstart,touchmove,touchend,touchcancel")),                                                                    // 573
                                                                                                                       // 574
			_addListener = function(element, type, func) {                                                                      // 575
				if (element.addEventListener) {                                                                                    // 576
					element.addEventListener(_touchEventLookup[type] || type, func, false);                                           // 577
				} else if (element.attachEvent) {                                                                                  // 578
					element.attachEvent("on" + type, func);                                                                           // 579
				}                                                                                                                  // 580
			},                                                                                                                  // 581
                                                                                                                       // 582
			_removeListener = function(element, type, func) {                                                                   // 583
				if (element.removeEventListener) {                                                                                 // 584
					element.removeEventListener(_touchEventLookup[type] || type, func);                                               // 585
				} else if (element.detachEvent) {                                                                                  // 586
					element.detachEvent("on" + type, func);                                                                           // 587
				}                                                                                                                  // 588
			},                                                                                                                  // 589
                                                                                                                       // 590
			_onMultiTouchDocumentEnd = function(e) {                                                                            // 591
				_isMultiTouching = (e.touches && _dragCount < e.touches.length);                                                   // 592
				_removeListener(e.target, "touchend", _onMultiTouchDocumentEnd);                                                   // 593
			},                                                                                                                  // 594
                                                                                                                       // 595
			_onMultiTouchDocument = function(e) {                                                                               // 596
				_isMultiTouching = (e.touches && _dragCount < e.touches.length);                                                   // 597
				_addListener(e.target, "touchend", _onMultiTouchDocumentEnd);                                                      // 598
			},                                                                                                                  // 599
                                                                                                                       // 600
			_parseThrowProps = function(draggable, snap, max, min, factor, forceZeroVelocity) {                                 // 601
				var vars = {},                                                                                                     // 602
					a, i, l;                                                                                                          // 603
				if (snap) {                                                                                                        // 604
					if (factor !== 1 && snap instanceof Array) { //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
						vars.end = a = [];                                                                                               // 606
						l = snap.length;                                                                                                 // 607
						for (i = 0; i < l; i++) {                                                                                        // 608
							a[i] = snap[i] * factor;                                                                                        // 609
						}                                                                                                                // 610
						max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.
						min -= 1.1;                                                                                                      // 612
					} else if (typeof(snap) === "function") {                                                                         // 613
						vars.end = function(value) {                                                                                     // 614
							return snap.call(draggable, value) * factor; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
						};                                                                                                               // 616
					} else {                                                                                                          // 617
						vars.end = snap;                                                                                                 // 618
					}                                                                                                                 // 619
				}                                                                                                                  // 620
				if (max || max === 0) {                                                                                            // 621
					vars.max = max;                                                                                                   // 622
				}                                                                                                                  // 623
				if (min || min === 0) {                                                                                            // 624
					vars.min = min;                                                                                                   // 625
				}                                                                                                                  // 626
				if (forceZeroVelocity) {                                                                                           // 627
					vars.velocity = 0;                                                                                                // 628
				}                                                                                                                  // 629
				return vars;                                                                                                       // 630
			},                                                                                                                  // 631
                                                                                                                       // 632
			_isClickable = function(e) { //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
				var data;                                                                                                          // 634
				return (!e || !e.getAttribute || e.nodeName === "BODY") ? false : ((data = e.getAttribute("data-clickable")) === "true" || (data !== "false" && (e.onclick || _clickableTagExp.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true"))) ? true : _isClickable(e.parentNode);
			},                                                                                                                  // 636
                                                                                                                       // 637
			_setSelectable = function(elements, selectable) {                                                                   // 638
				var i = elements.length,                                                                                           // 639
					e;                                                                                                                // 640
				while (--i > -1) {                                                                                                 // 641
					e = elements[i];                                                                                                  // 642
					e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;                                                 // 643
					_setStyle(e, "userSelect", (selectable ? "text" : "none"));                                                       // 644
				}                                                                                                                  // 645
			},                                                                                                                  // 646
                                                                                                                       // 647
			_addPaddingBR,                                                                                                      // 648
			_addPaddingLeft = (function() { //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
				var div = _doc.createElement("div"),                                                                               // 650
					child = _doc.createElement("div"),                                                                                // 651
					childStyle = child.style,                                                                                         // 652
					parent = _doc.body || _tempDiv,                                                                                   // 653
					val;                                                                                                              // 654
				childStyle.display = "inline-block";                                                                               // 655
				childStyle.position = "relative";                                                                                  // 656
				div.style.cssText = child.innerHTML = "width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden";  // 657
				div.appendChild(child);                                                                                            // 658
				parent.appendChild(div);                                                                                           // 659
				_addPaddingBR = (child.offsetHeight + 18 > div.scrollHeight); //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.
				childStyle.width = "100%";                                                                                         // 661
				if (!_transformProp) {                                                                                             // 662
					childStyle.paddingRight = "500px";                                                                                // 663
					val = div.scrollLeft = div.scrollWidth - div.clientWidth;                                                         // 664
					childStyle.left = "-90px";                                                                                        // 665
					val = (val !== div.scrollLeft);                                                                                   // 666
				}                                                                                                                  // 667
				parent.removeChild(div);                                                                                           // 668
				return val;                                                                                                        // 669
			}()),                                                                                                               // 670
                                                                                                                       // 671
                                                                                                                       // 672
                                                                                                                       // 673
                                                                                                                       // 674
			//The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
			ScrollProxy = function(element, vars) {                                                                             // 676
				element = _unwrapElement(element);                                                                                 // 677
				vars = vars || {};                                                                                                 // 678
				var content = _doc.createElement("div"),                                                                           // 679
					style = content.style,                                                                                            // 680
					node = element.firstChild,                                                                                        // 681
					offsetTop = 0,                                                                                                    // 682
					offsetLeft = 0,                                                                                                   // 683
					prevTop = element.scrollTop,                                                                                      // 684
					prevLeft = element.scrollLeft,                                                                                    // 685
					scrollWidth = element.scrollWidth,                                                                                // 686
					scrollHeight = element.scrollHeight,                                                                              // 687
					extraPadRight = 0,                                                                                                // 688
					maxLeft = 0,                                                                                                      // 689
					maxTop = 0,                                                                                                       // 690
					elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;                               // 691
                                                                                                                       // 692
				if (_supports3D && vars.force3D !== false) {                                                                       // 693
					transformStart = "translate3d(";                                                                                  // 694
					transformEnd = "px,0px)";                                                                                         // 695
				} else if (_transformProp) {                                                                                       // 696
					transformStart = "translate(";                                                                                    // 697
					transformEnd = "px)";                                                                                             // 698
				}                                                                                                                  // 699
                                                                                                                       // 700
				this.scrollTop = function(value, force) {                                                                          // 701
					if (!arguments.length) {                                                                                          // 702
						return -this.top();                                                                                              // 703
					}                                                                                                                 // 704
					this.top(-value, force);                                                                                          // 705
				};                                                                                                                 // 706
                                                                                                                       // 707
				this.scrollLeft = function(value, force) {                                                                         // 708
					if (!arguments.length) {                                                                                          // 709
						return -this.left();                                                                                             // 710
					}                                                                                                                 // 711
					this.left(-value, force);                                                                                         // 712
				};                                                                                                                 // 713
                                                                                                                       // 714
				this.left = function(value, force) {                                                                               // 715
					if (!arguments.length) {                                                                                          // 716
						return -(element.scrollLeft + offsetLeft);                                                                       // 717
					}                                                                                                                 // 718
					var dif = element.scrollLeft - prevLeft,                                                                          // 719
						oldOffset = offsetLeft;                                                                                          // 720
					if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
						prevLeft = element.scrollLeft;                                                                                   // 722
						TweenLite.killTweensOf(this, true, {left:1, scrollLeft:1});                                                      // 723
						this.left(-prevLeft);                                                                                            // 724
						if (vars.onKill) {                                                                                               // 725
							vars.onKill();                                                                                                  // 726
						}                                                                                                                // 727
						return;                                                                                                          // 728
					}                                                                                                                 // 729
					value = -value; //invert because scrolling works in the opposite direction                                        // 730
					if (value < 0) {                                                                                                  // 731
						offsetLeft = (value - 0.5) | 0;                                                                                  // 732
						value = 0;                                                                                                       // 733
					} else if (value > maxLeft) {                                                                                     // 734
						offsetLeft = (value - maxLeft) | 0;                                                                              // 735
						value = maxLeft;                                                                                                 // 736
					} else {                                                                                                          // 737
						offsetLeft = 0;                                                                                                  // 738
					}                                                                                                                 // 739
					if (offsetLeft || oldOffset) {                                                                                    // 740
						if (transformStart) {                                                                                            // 741
							if (!this._suspendTransforms) {                                                                                 // 742
								style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;                      // 743
							}                                                                                                               // 744
						} else {                                                                                                         // 745
							style.left = -offsetLeft + "px";                                                                                // 746
						}                                                                                                                // 747
						if (_addPaddingLeft && offsetLeft + extraPadRight >= 0) {                                                        // 748
							style.paddingRight = offsetLeft + extraPadRight + "px";                                                         // 749
						}                                                                                                                // 750
					}                                                                                                                 // 751
					element.scrollLeft = value | 0;                                                                                   // 752
					prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjsut the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
				};                                                                                                                 // 754
                                                                                                                       // 755
				this.top = function(value, force) {                                                                                // 756
					if (!arguments.length) {                                                                                          // 757
						return -(element.scrollTop + offsetTop);                                                                         // 758
					}                                                                                                                 // 759
					var dif = element.scrollTop - prevTop,                                                                            // 760
						oldOffset = offsetTop;                                                                                           // 761
					if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
						prevTop = element.scrollTop;                                                                                     // 763
						TweenLite.killTweensOf(this, true, {top:1, scrollTop:1});                                                        // 764
						this.top(-prevTop);                                                                                              // 765
						if (vars.onKill) {                                                                                               // 766
							vars.onKill();                                                                                                  // 767
						}                                                                                                                // 768
						return;                                                                                                          // 769
					}                                                                                                                 // 770
					value = -value; //invert because scrolling works in the opposite direction                                        // 771
					if (value < 0) {                                                                                                  // 772
						offsetTop = (value - 0.5) | 0;                                                                                   // 773
						value = 0;                                                                                                       // 774
					} else if (value > maxTop) {                                                                                      // 775
						offsetTop = (value - maxTop) | 0;                                                                                // 776
						value = maxTop;                                                                                                  // 777
					} else {                                                                                                          // 778
						offsetTop = 0;                                                                                                   // 779
					}                                                                                                                 // 780
					if (offsetTop || oldOffset) {                                                                                     // 781
						if (transformStart) {                                                                                            // 782
							if (!this._suspendTransforms) {                                                                                 // 783
								style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;                      // 784
							}                                                                                                               // 785
						} else {                                                                                                         // 786
							style.top = -offsetTop + "px";                                                                                  // 787
						}                                                                                                                // 788
					}                                                                                                                 // 789
					element.scrollTop = value | 0;                                                                                    // 790
					prevTop = element.scrollTop;                                                                                      // 791
				};                                                                                                                 // 792
                                                                                                                       // 793
				this.maxScrollTop = function() {                                                                                   // 794
					return maxTop;                                                                                                    // 795
				};                                                                                                                 // 796
                                                                                                                       // 797
				this.maxScrollLeft = function() {                                                                                  // 798
					return maxLeft;                                                                                                   // 799
				};                                                                                                                 // 800
                                                                                                                       // 801
				this.disable = function() {                                                                                        // 802
					node = content.firstChild;                                                                                        // 803
					while (node) {                                                                                                    // 804
						nextNode = node.nextSibling;                                                                                     // 805
						element.appendChild(node);                                                                                       // 806
						node = nextNode;                                                                                                 // 807
					}                                                                                                                 // 808
					if (element === content.parentNode) { //in case disable() is called when it's already disabled.                   // 809
						element.removeChild(content);                                                                                    // 810
					}                                                                                                                 // 811
				};                                                                                                                 // 812
                                                                                                                       // 813
				this.enable = function() {                                                                                         // 814
					node = element.firstChild;                                                                                        // 815
					if (node === content) {                                                                                           // 816
						return;                                                                                                          // 817
					}                                                                                                                 // 818
					while (node) {                                                                                                    // 819
						nextNode = node.nextSibling;                                                                                     // 820
						content.appendChild(node);                                                                                       // 821
						node = nextNode;                                                                                                 // 822
					}                                                                                                                 // 823
					element.appendChild(content);                                                                                     // 824
					this.calibrate();                                                                                                 // 825
				};                                                                                                                 // 826
                                                                                                                       // 827
				this.calibrate = function(force) {                                                                                 // 828
					var widthMatches = (element.clientWidth === elementWidth),                                                        // 829
						x, y;                                                                                                            // 830
					prevTop = element.scrollTop;                                                                                      // 831
					prevLeft = element.scrollLeft;                                                                                    // 832
					if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
						return; //no need to recalculate things if the width and height haven't changed.                                 // 834
					}                                                                                                                 // 835
					if (offsetTop || offsetLeft) {                                                                                    // 836
						x = this.left();                                                                                                 // 837
						y = this.top();                                                                                                  // 838
						this.left(-element.scrollLeft);                                                                                  // 839
						this.top(-element.scrollTop);                                                                                    // 840
					}                                                                                                                 // 841
					//first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)
					if (!widthMatches || force) {                                                                                     // 843
						style.display = "block";                                                                                         // 844
						style.width = "auto";                                                                                            // 845
						style.paddingRight = "0px";                                                                                      // 846
						extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);                                          // 847
						//if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.
						if (extraPadRight) {                                                                                             // 849
							extraPadRight += _getStyle(element, "paddingLeft") + (_addPaddingBR ? _getStyle(element, "paddingRight") : 0);  // 850
						}                                                                                                                // 851
					}                                                                                                                 // 852
					style.display = "inline-block";                                                                                   // 853
					style.position = "relative";                                                                                      // 854
					style.overflow = "visible";                                                                                       // 855
					style.verticalAlign = "top";                                                                                      // 856
					style.width = "100%";                                                                                             // 857
					style.paddingRight = extraPadRight + "px";                                                                        // 858
					//some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error
					if (_addPaddingBR) {                                                                                              // 860
						style.paddingBottom = _getStyle(element, "paddingBottom", true);                                                 // 861
					}                                                                                                                 // 862
					if (_isOldIE) {                                                                                                   // 863
						style.zoom = "1";                                                                                                // 864
					}                                                                                                                 // 865
					elementWidth = element.clientWidth;                                                                               // 866
					elementHeight = element.clientHeight;                                                                             // 867
					scrollWidth = element.scrollWidth;                                                                                // 868
					scrollHeight = element.scrollHeight;                                                                              // 869
					maxLeft = element.scrollWidth - elementWidth;                                                                     // 870
					maxTop = element.scrollHeight - elementHeight;                                                                    // 871
					contentHeight = content.offsetHeight;                                                                             // 872
					style.display = "block";                                                                                          // 873
					if (x || y) {                                                                                                     // 874
						this.left(x);                                                                                                    // 875
						this.top(y);                                                                                                     // 876
					}                                                                                                                 // 877
				};                                                                                                                 // 878
                                                                                                                       // 879
				this.content = content;                                                                                            // 880
				this.element = element;                                                                                            // 881
				this._suspendTransforms = false;                                                                                   // 882
				this.enable();                                                                                                     // 883
			},                                                                                                                  // 884
                                                                                                                       // 885
                                                                                                                       // 886
                                                                                                                       // 887
                                                                                                                       // 888
                                                                                                                       // 889
			Draggable = function(target, vars) {                                                                                // 890
				EventDispatcher.call(this, target);                                                                                // 891
				target = _unwrapElement(target); //in case the target is a selector object or selector text                        // 892
				if (!ThrowPropsPlugin) {                                                                                           // 893
					ThrowPropsPlugin = _globals.com.greensock.plugins.ThrowPropsPlugin;                                               // 894
				}                                                                                                                  // 895
				this.vars = vars = vars || {};                                                                                     // 896
				this.target = target;                                                                                              // 897
				this.x = this.y = this.rotation = 0;                                                                               // 898
				this.dragResistance = parseFloat(vars.dragResistance) || 0;                                                        // 899
				this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;                       // 900
				this.lockAxis = vars.lockAxis;                                                                                     // 901
				this.autoScroll = vars.autoScroll || 0;                                                                            // 902
				this.lockedAxis = null;                                                                                            // 903
				var type = (vars.type || (_isOldIE ? "top,left" : "x,y")).toLowerCase(),                                           // 904
					xyMode = (type.indexOf("x") !== -1 || type.indexOf("y") !== -1),                                                  // 905
					rotationMode = (type.indexOf("rotation") !== -1),                                                                 // 906
					xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",                                                        // 907
					yProp = xyMode ? "y" : "top",                                                                                     // 908
					allowX = (type.indexOf("x") !== -1 || type.indexOf("left") !== -1 || type === "scroll"),                          // 909
					allowY = (type.indexOf("y") !== -1 || type.indexOf("top") !== -1 || type === "scroll"),                           // 910
					minimumMovement = vars.minimumMovement || 2,                                                                      // 911
					self = this,                                                                                                      // 912
					triggers = _slice(vars.trigger || vars.handle || target),                                                         // 913
					killProps = {},                                                                                                   // 914
					dragEndTime = 0,                                                                                                  // 915
					checkAutoScrollBounds = false,                                                                                    // 916
					isClickable = vars.clickableTest || _isClickable,                                                                 // 917
					enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, maxX, minX, maxY, minY, tempVars, cssVars, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, isClicking, touchEventTarget, matrix, interrupted, clickTime, startScrollTop, startScrollLeft, applyObj,
                                                                                                                       // 919
					//this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
					render = function(suppressEvents) {                                                                               // 921
						if (self.autoScroll && self.isDragging && (dirty || checkAutoScrollBounds)) {                                    // 922
							var e = target,                                                                                                 // 923
								autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better "feel" speed-wise.         // 924
								parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;                                               // 925
							checkAutoScrollBounds = false;                                                                                  // 926
							_windowProxy.scrollTop = ((window.pageYOffset != null) ? window.pageYOffset : (_docElement.scrollTop != null) ? _docElement.scrollTop : _doc.body.scrollTop);
							_windowProxy.scrollLeft = ((window.pageXOffset != null) ? window.pageXOffset : (_docElement.scrollLeft != null) ? _docElement.scrollLeft : _doc.body.scrollLeft);
							pointerX = self.pointerX - _windowProxy.scrollLeft;                                                             // 929
							pointerY = self.pointerY - _windowProxy.scrollTop;                                                              // 930
							while (e && !isRoot) { //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
								isRoot = _isRoot(e.parentNode);                                                                                // 932
								parent = isRoot ? _windowProxy : e.parentNode;                                                                 // 933
								rect = isRoot ? {bottom:Math.max(_docElement.clientHeight, window.innerHeight || 0), right: Math.max(_docElement.clientWidth, window.innerWidth || 0), left:0, top:0} : parent.getBoundingClientRect();
								changeX = changeY = 0;                                                                                         // 935
								if (allowY) {                                                                                                  // 936
									if (pointerY > rect.bottom - 40 && (gap = parent._gsMaxScrollY - parent.scrollTop)) {                         // 937
										checkAutoScrollBounds = true;                                                                                // 938
										changeY = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.bottom - pointerY)) / 40)) | 0);          // 939
									} else if (pointerY < rect.top + 40 && parent.scrollTop) {                                                    // 940
										checkAutoScrollBounds = true;                                                                                // 941
										changeY = -Math.min(parent.scrollTop, (autoScrollFactor * (1 - Math.max(0, (pointerY - rect.top)) / 40)) | 0);
									}                                                                                                             // 943
									if (changeY) {                                                                                                // 944
										parent.scrollTop += changeY;                                                                                 // 945
									}                                                                                                             // 946
								}                                                                                                              // 947
                                                                                                                       // 948
								if (allowX) {                                                                                                  // 949
									if (pointerX > rect.right - 40 && (gap = parent._gsMaxScrollX - parent.scrollLeft)) {                         // 950
										checkAutoScrollBounds = true;                                                                                // 951
										changeX = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.right - pointerX)) / 40)) | 0);           // 952
									} else if (pointerX < rect.left + 40 && parent.scrollLeft) {                                                  // 953
										checkAutoScrollBounds = true;                                                                                // 954
										changeX = -Math.min(parent.scrollLeft, (autoScrollFactor * (1 - Math.max(0, (pointerX - rect.left)) / 40)) | 0);
									}                                                                                                             // 956
									if (changeX) {                                                                                                // 957
										parent.scrollLeft += changeX;                                                                                // 958
									}                                                                                                             // 959
								}                                                                                                              // 960
                                                                                                                       // 961
								if (isRoot && (changeX || changeY)) {                                                                          // 962
									window.scrollTo(parent.scrollLeft, parent.scrollTop);                                                         // 963
									setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);                                         // 964
								}                                                                                                              // 965
								e = parent;                                                                                                    // 966
							}                                                                                                               // 967
						}                                                                                                                // 968
						if (dirty) {                                                                                                     // 969
							var x = self.x,                                                                                                 // 970
								y = self.y,                                                                                                    // 971
								min = 0.000001;                                                                                                // 972
							if (x < min && x > -min) { //browsers don't handle super small decimals well.                                   // 973
								x = 0;                                                                                                         // 974
							}                                                                                                               // 975
							if (y < min && y > -min) {                                                                                      // 976
								y = 0;                                                                                                         // 977
							}                                                                                                               // 978
							if (rotationMode) {                                                                                             // 979
								applyObj.data.rotation = self.rotation = x;                                                                    // 980
								applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
							} else {                                                                                                        // 982
								if (scrollProxy) {                                                                                             // 983
									if (allowY) {                                                                                                 // 984
										scrollProxy.top(y);                                                                                          // 985
									}                                                                                                             // 986
									if (allowX) {                                                                                                 // 987
										scrollProxy.left(x);                                                                                         // 988
									}                                                                                                             // 989
								} else if (xyMode) {                                                                                           // 990
									if (allowY) {                                                                                                 // 991
										applyObj.data.y = y;                                                                                         // 992
									}                                                                                                             // 993
									if (allowX) {                                                                                                 // 994
										applyObj.data.x = x;                                                                                         // 995
									}                                                                                                             // 996
									applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
								} else {                                                                                                       // 998
									if (allowY) {                                                                                                 // 999
										target.style.top = y + "px";                                                                                 // 1000
									}                                                                                                             // 1001
									if (allowX) {                                                                                                 // 1002
										target.style.left = x + "px";                                                                                // 1003
									}                                                                                                             // 1004
								}                                                                                                              // 1005
							}                                                                                                               // 1006
							if (hasDragCallback && !suppressEvents) {                                                                       // 1007
								_dispatchEvent(self, "drag", "onDrag");                                                                        // 1008
							}                                                                                                               // 1009
						}                                                                                                                // 1010
						dirty = false;                                                                                                   // 1011
					},                                                                                                                // 1012
                                                                                                                       // 1013
					//copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the ThrowPropsPlugin tween in an onUpdate to ensure things are synced and snapped.
					syncXY = function(skipOnUpdate, skipSnap) {                                                                       // 1015
						var snappedValue;                                                                                                // 1016
						if (!target._gsTransform && (xyMode || rotationMode)) { //just in case the _gsTransform got wiped, like if the user called clearProps on the transform or something (very rare), doing an x tween forces a re-parsing of the transforms and population of the _gsTransform.
							TweenLite.set(target, {x:"+=0"});                                                                               // 1018
						}                                                                                                                // 1019
						if (xyMode) {                                                                                                    // 1020
							self.y = target._gsTransform.y;                                                                                 // 1021
							self.x = target._gsTransform.x;                                                                                 // 1022
						} else if (rotationMode) {                                                                                       // 1023
							self.x = self.rotation = target._gsTransform.rotation;                                                          // 1024
						} else if (scrollProxy) {                                                                                        // 1025
							self.y = scrollProxy.top();                                                                                     // 1026
							self.x = scrollProxy.left();                                                                                    // 1027
						} else {                                                                                                         // 1028
							self.y = parseInt(target.style.top, 10) || 0;                                                                   // 1029
							self.x = parseInt(target.style.left, 10) || 0;                                                                  // 1030
						}                                                                                                                // 1031
						if ((snapX || snapY) && !skipSnap) {                                                                             // 1032
							if (snapX) {                                                                                                    // 1033
								snappedValue = snapX(self.x);                                                                                  // 1034
								if (snappedValue !== self.x) {                                                                                 // 1035
									self.x = snappedValue;                                                                                        // 1036
									if (rotationMode) {                                                                                           // 1037
										self.rotation = snappedValue;                                                                                // 1038
									}                                                                                                             // 1039
									dirty = true;                                                                                                 // 1040
								}                                                                                                              // 1041
							}                                                                                                               // 1042
							if (snapY) {                                                                                                    // 1043
								snappedValue = snapY(self.y);                                                                                  // 1044
								if (snappedValue !== self.y) {                                                                                 // 1045
									self.y = snappedValue;                                                                                        // 1046
									dirty = true;                                                                                                 // 1047
								}                                                                                                              // 1048
							}                                                                                                               // 1049
							if (dirty) {                                                                                                    // 1050
								render(true);                                                                                                  // 1051
							}                                                                                                               // 1052
						}                                                                                                                // 1053
						if (vars.onThrowUpdate && !skipOnUpdate) {                                                                       // 1054
							vars.onThrowUpdate.apply(vars.onThrowUpdateScope || self, vars.onThrowUpdateParams || _emptyArray);             // 1055
						}                                                                                                                // 1056
					},                                                                                                                // 1057
                                                                                                                       // 1058
					calculateBounds = function() {                                                                                    // 1059
						var bounds, targetBounds, snap, snapIsRaw;                                                                       // 1060
						hasBounds = false;                                                                                               // 1061
						if (scrollProxy) {                                                                                               // 1062
							scrollProxy.calibrate();                                                                                        // 1063
							self.minX = minX = -scrollProxy.maxScrollLeft();                                                                // 1064
							self.minY = minY = -scrollProxy.maxScrollTop();                                                                 // 1065
							self.maxX = maxX = self.maxY = maxY = 0;                                                                        // 1066
							hasBounds = true;                                                                                               // 1067
						} else if (!!vars.bounds) {                                                                                      // 1068
							bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}
							if (rotationMode) {                                                                                             // 1070
								self.minX = minX = bounds.left;                                                                                // 1071
								self.maxX = maxX = bounds.left + bounds.width;                                                                 // 1072
								self.minY = minY = self.maxY = maxY = 0;                                                                       // 1073
							} else if (vars.bounds.maxX !== undefined || vars.bounds.maxY !== undefined) {                                  // 1074
								bounds = vars.bounds;                                                                                          // 1075
								self.minX = minX = bounds.minX;                                                                                // 1076
								self.minY = minY = bounds.minY;                                                                                // 1077
								self.maxX = maxX = bounds.maxX;                                                                                // 1078
								self.maxY = maxY = bounds.maxY;                                                                                // 1079
							} else {                                                                                                        // 1080
								targetBounds = _getBounds(target, target.parentNode);                                                          // 1081
								self.minX = minX = _getStyle(target, xProp) + bounds.left - targetBounds.left;                                 // 1082
								self.minY = minY = _getStyle(target, yProp) + bounds.top - targetBounds.top;                                   // 1083
								self.maxX = maxX = minX + (bounds.width - targetBounds.width);                                                 // 1084
								self.maxY = maxY = minY + (bounds.height - targetBounds.height);                                               // 1085
							}                                                                                                               // 1086
							if (minX > maxX) {                                                                                              // 1087
								self.minX = maxX;                                                                                              // 1088
								self.maxX = maxX = minX;                                                                                       // 1089
								minX = self.minX;                                                                                              // 1090
							}                                                                                                               // 1091
							if (minY > maxY) {                                                                                              // 1092
								self.minY = maxY;                                                                                              // 1093
								self.maxY = maxY = minY;                                                                                       // 1094
								minY = self.minY;                                                                                              // 1095
							}                                                                                                               // 1096
							if (rotationMode) {                                                                                             // 1097
								self.minRotation = minX;                                                                                       // 1098
								self.maxRotation = maxX;                                                                                       // 1099
							}                                                                                                               // 1100
							hasBounds = true;                                                                                               // 1101
						}                                                                                                                // 1102
						if (vars.liveSnap) {                                                                                             // 1103
							snap = (vars.liveSnap === true) ? (vars.snap || {}) : vars.liveSnap;                                            // 1104
							snapIsRaw = (snap instanceof Array || typeof(snap) === "function");                                             // 1105
							if (rotationMode) {                                                                                             // 1106
								snapX = buildSnapFunc((snapIsRaw ? snap : snap.rotation), minX, maxX, 1);                                      // 1107
								snapY = null;                                                                                                  // 1108
							} else {                                                                                                        // 1109
								if (allowX) {                                                                                                  // 1110
									snapX = buildSnapFunc((snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft), minX, maxX, scrollProxy ? -1 : 1);
								}                                                                                                              // 1112
								if (allowY) {                                                                                                  // 1113
									snapY = buildSnapFunc((snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop), minY, maxY, scrollProxy ? -1 : 1);
								}                                                                                                              // 1115
							}                                                                                                               // 1116
						}                                                                                                                // 1117
                                                                                                                       // 1118
					},                                                                                                                // 1119
                                                                                                                       // 1120
					animate = function(throwProps, forceZeroVelocity) {                                                               // 1121
						var snap, snapIsRaw, tween;                                                                                      // 1122
						if (throwProps && ThrowPropsPlugin) {                                                                            // 1123
							if (throwProps === true) {                                                                                      // 1124
								snap = vars.snap || {};                                                                                        // 1125
								snapIsRaw = (snap instanceof Array || typeof(snap) === "function");                                            // 1126
								throwProps = {resistance:(vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)};         // 1127
								if (rotationMode) {                                                                                            // 1128
									throwProps.rotation = _parseThrowProps(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
								} else {                                                                                                       // 1130
									if (allowX) {                                                                                                 // 1131
										throwProps[xProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockAxis && self.lockedAxis === "x"));
									}                                                                                                             // 1133
									if (allowY) {                                                                                                 // 1134
										throwProps[yProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockAxis && self.lockedAxis === "y"));
									}                                                                                                             // 1136
								}                                                                                                              // 1137
							}                                                                                                               // 1138
							self.tween = tween = ThrowPropsPlugin.to(scrollProxy || target, {throwProps:throwProps, ease:(vars.ease || _globals.Power3.easeOut), onComplete:vars.onThrowComplete, onCompleteParams:vars.onThrowCompleteParams, onCompleteScope:(vars.onThrowCompleteScope || self), onUpdate:(vars.fastMode ? vars.onThrowUpdate : syncXY), onUpdateParams:(vars.fastMode ? vars.onThrowUpdateParams : null), onUpdateScope:(vars.onThrowUpdateScope || self)}, (isNaN(vars.maxDuration) ? 2 : vars.maxDuration), (isNaN(vars.minDuration) ? 0.5 : vars.minDuration), (isNaN(vars.overshootTolerance) ? (1 - self.edgeResistance) + 0.2 : vars.overshootTolerance));
							if (!vars.fastMode) {                                                                                           // 1140
								//to populate the end values, we just scrub the tween to the end, record the values, and then jump back to the beginning.
								if (scrollProxy) {                                                                                             // 1142
									scrollProxy._suspendTransforms = true; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
								}                                                                                                              // 1144
								tween.render(tween.duration(), true, true);                                                                    // 1145
								syncXY(true, true);                                                                                            // 1146
								self.endX = self.x;                                                                                            // 1147
								self.endY = self.y;                                                                                            // 1148
								if (rotationMode) {                                                                                            // 1149
									self.endRotation = self.x;                                                                                    // 1150
								}                                                                                                              // 1151
								tween.play(0);                                                                                                 // 1152
								syncXY(true, true);                                                                                            // 1153
								if (scrollProxy) {                                                                                             // 1154
									scrollProxy._suspendTransforms = false;                                                                       // 1155
								}                                                                                                              // 1156
							}                                                                                                               // 1157
						} else if (hasBounds) {                                                                                          // 1158
							self.applyBounds();                                                                                             // 1159
						}                                                                                                                // 1160
					},                                                                                                                // 1161
                                                                                                                       // 1162
					updateMatrix = function() {                                                                                       // 1163
						matrix = _getConcatenatedMatrix(target.parentNode, true);                                                        // 1164
						if (!matrix[1] && !matrix[2] && matrix[0] == 1 && matrix[3] == 1 && matrix[4] == 0 && matrix[5] == 0) { //if there are no transforms, we can optimize performance by not factoring in the matrix
							matrix = null;                                                                                                  // 1166
						}                                                                                                                // 1167
					},                                                                                                                // 1168
                                                                                                                       // 1169
					recordStartPositions = function() {                                                                               // 1170
						var edgeTolerance = 1 - self.edgeResistance;                                                                     // 1171
						updateMatrix();                                                                                                  // 1172
						if (scrollProxy) {                                                                                               // 1173
							calculateBounds();                                                                                              // 1174
							startElementY = scrollProxy.top();                                                                              // 1175
							startElementX = scrollProxy.left();                                                                             // 1176
						} else {                                                                                                         // 1177
							//if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
							if (isTweening()) {                                                                                             // 1179
								syncXY(true, true);                                                                                            // 1180
								calculateBounds();                                                                                             // 1181
							} else {                                                                                                        // 1182
								self.applyBounds();                                                                                            // 1183
							}                                                                                                               // 1184
							if (rotationMode) {                                                                                             // 1185
								rotationOrigin = _localToGlobal(target, {x:0, y:0});                                                           // 1186
								syncXY(true, true);                                                                                            // 1187
								startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)
								startElementY = self.y = Math.atan2(rotationOrigin.y - startPointerY, startPointerX - rotationOrigin.x) * _RAD2DEG;
							} else {                                                                                                        // 1190
								startScrollTop = target.parentNode ? target.parentNode.scrollTop || 0 : 0;                                     // 1191
								startScrollLeft = target.parentNode ? target.parentNode.scrollLeft || 0 : 0;                                   // 1192
								startElementY = _getStyle(target, yProp); //record the starting top and left values so that we can just add the mouse's movement to them later.
								startElementX = _getStyle(target, xProp);                                                                      // 1194
							}                                                                                                               // 1195
						}                                                                                                                // 1196
						if (hasBounds && edgeTolerance) {                                                                                // 1197
							if (startElementX > maxX) {                                                                                     // 1198
								startElementX = maxX + (startElementX - maxX) / edgeTolerance;                                                 // 1199
							} else if (startElementX < minX) {                                                                              // 1200
								startElementX = minX - (minX - startElementX) / edgeTolerance;                                                 // 1201
							}                                                                                                               // 1202
							if (!rotationMode) {                                                                                            // 1203
								if (startElementY > maxY) {                                                                                    // 1204
									startElementY = maxY + (startElementY - maxY) / edgeTolerance;                                                // 1205
								} else if (startElementY < minY) {                                                                             // 1206
									startElementY = minY - (minY - startElementY) / edgeTolerance;                                                // 1207
								}                                                                                                              // 1208
							}                                                                                                               // 1209
						}                                                                                                                // 1210
					},                                                                                                                // 1211
                                                                                                                       // 1212
					isTweening = function() {                                                                                         // 1213
						return (self.tween && self.tween.isActive());                                                                    // 1214
					},                                                                                                                // 1215
                                                                                                                       // 1216
					buildSnapFunc = function(snap, min, max, factor) {                                                                // 1217
						if (typeof(snap) === "function") {                                                                               // 1218
							return function(n) {                                                                                            // 1219
								var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
								return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : (n < min) ? min + (n - min) * edgeTolerance : n)) * factor;
							};                                                                                                              // 1222
						}                                                                                                                // 1223
						if (snap instanceof Array) {                                                                                     // 1224
							return function(n) {                                                                                            // 1225
								var i = snap.length,                                                                                           // 1226
									closest = 0,                                                                                                  // 1227
									absDif = _max,                                                                                                // 1228
									val, dif;                                                                                                     // 1229
								while (--i > -1) {                                                                                             // 1230
									val = snap[i];                                                                                                // 1231
									dif = val - n;                                                                                                // 1232
									if (dif < 0) {                                                                                                // 1233
										dif = -dif;                                                                                                  // 1234
									}                                                                                                             // 1235
									if (dif < absDif && val >= min && val <= max) {                                                               // 1236
										closest = i;                                                                                                 // 1237
										absDif = dif;                                                                                                // 1238
									}                                                                                                             // 1239
								}                                                                                                              // 1240
								return snap[closest];                                                                                          // 1241
							};                                                                                                              // 1242
						}                                                                                                                // 1243
						return isNaN(snap) ? function(n) { return n; } : function() { return snap * factor; };                           // 1244
					},                                                                                                                // 1245
                                                                                                                       // 1246
					//called when the mouse is pressed (or touch starts)                                                              // 1247
					onPress = function(e) {                                                                                           // 1248
						var temp, i;                                                                                                     // 1249
						if (!enabled || self.isPressed || !e) { //just in case the browser dispatches a "touchstart" and "mousedown" (some browsers emulate mouse events when using touches)
							return;                                                                                                         // 1251
						}                                                                                                                // 1252
						interrupted = isTweening();                                                                                      // 1253
						self.pointerEvent = e;                                                                                           // 1254
						if (_touchEventLookup[e.type]) { //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
							touchEventTarget = (e.type.indexOf("touch") !== -1) ? e.currentTarget : _doc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".
							_addListener(touchEventTarget, "touchend", onRelease);                                                          // 1257
							_addListener(touchEventTarget, "touchmove", onMove);                                                            // 1258
							_addListener(touchEventTarget, "touchcancel", onRelease);                                                       // 1259
							_addListener(_doc, "touchstart", _onMultiTouchDocument);                                                        // 1260
						} else {                                                                                                         // 1261
							touchEventTarget = null;                                                                                        // 1262
							_addListener(_doc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.
                                                                                                                       // 1264
						}                                                                                                                // 1265
						_addListener(_doc, "mouseup", onRelease);                                                                        // 1266
						if (e && e.target) {                                                                                             // 1267
							_addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
						}                                                                                                                // 1269
						isClicking = (isClickable.call(self, e.target) && !vars.dragClickables);                                         // 1270
						if (isClicking) {                                                                                                // 1271
							_addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.
							_dispatchEvent(self, "press", "onPress");                                                                       // 1273
							_setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)
							return;                                                                                                         // 1275
						}                                                                                                                // 1276
						if (_isOldIE) {                                                                                                  // 1277
							e = _populateIEEvent(e, true);                                                                                  // 1278
						} else { //if (scrollProxy && !(e.touches && e.touches.length > _dragCount + 1)) { //in some mobile browsers, e.preventDefault() when pressing on a link (or element with an onclick) will cause the link not to work. Only preventDefault() on scroll-type interactions, otherwise things like touch checkboxes and inputs don't work.
							e.preventDefault();                                                                                             // 1280
							if (e.preventManipulation) {                                                                                    // 1281
								e.preventManipulation();  //for some Microsoft browsers                                                        // 1282
							}                                                                                                               // 1283
						}                                                                                                                // 1284
						if (e.changedTouches) { //touch events store the data slightly differently                                       // 1285
							e = touch = e.changedTouches[0];                                                                                // 1286
							touchID = e.identifier;                                                                                         // 1287
						} else if (e.pointerId) {                                                                                        // 1288
							touchID = e.pointerId; //for some Microsoft browsers                                                            // 1289
						} else {                                                                                                         // 1290
							touch = null;                                                                                                   // 1291
						}                                                                                                                // 1292
						_dragCount++;                                                                                                    // 1293
						_addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)
						startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove
						startPointerX = self.pointerX = e.pageX;                                                                         // 1296
						if (self.autoScroll && !rotationMode && !scrollProxy && target.parentNode && !target.getBBox) {                  // 1297
							_recordMaxScrolls(target.parentNode);                                                                           // 1298
							if (target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode) { //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
								_placeholderDiv.style.width = (target.parentNode.scrollWidth) + "px";                                          // 1300
								target.parentNode.appendChild(_placeholderDiv);                                                                // 1301
							}                                                                                                               // 1302
						}                                                                                                                // 1303
						recordStartPositions();                                                                                          // 1304
						if (matrix) {                                                                                                    // 1305
							temp = startPointerX * matrix[0] + startPointerY * matrix[2] + matrix[4];                                       // 1306
							startPointerY = startPointerX * matrix[1] + startPointerY * matrix[3] + matrix[5];                              // 1307
							startPointerX = temp;                                                                                           // 1308
						}                                                                                                                // 1309
						if (self.tween) {                                                                                                // 1310
							self.tween.kill();                                                                                              // 1311
						}                                                                                                                // 1312
						TweenLite.killTweensOf(scrollProxy || target, true, killProps); //in case the user tries to drag it before the last tween is done.
						if (scrollProxy) {                                                                                               // 1314
							TweenLite.killTweensOf(target, true, {scrollTo:1}); //just in case the original target's scroll position is being tweened somewhere else.
						}                                                                                                                // 1316
						self.tween = self.lockedAxis = null;                                                                             // 1317
						if (vars.zIndexBoost || (!rotationMode && !scrollProxy && vars.zIndexBoost !== false)) {                         // 1318
							target.style.zIndex = Draggable.zIndex++;                                                                       // 1319
						}                                                                                                                // 1320
						self.isPressed = true;                                                                                           // 1321
						hasDragCallback = !!(vars.onDrag || self._listeners.drag);                                                       // 1322
						if (!rotationMode) {                                                                                             // 1323
							i = triggers.length;                                                                                            // 1324
							while (--i > -1) {                                                                                              // 1325
								_setStyle(triggers[i], "cursor", vars.cursor || "move");                                                       // 1326
							}                                                                                                               // 1327
						}                                                                                                                // 1328
						_dispatchEvent(self, "press", "onPress");                                                                        // 1329
					},                                                                                                                // 1330
                                                                                                                       // 1331
					//called every time the mouse/touch moves                                                                         // 1332
					onMove = function(e) {                                                                                            // 1333
						if (!enabled || _isMultiTouching || !self.isPressed || !e) {                                                     // 1334
							return;                                                                                                         // 1335
						}                                                                                                                // 1336
						if (_isOldIE) {                                                                                                  // 1337
							e = _populateIEEvent(e, true);                                                                                  // 1338
						} else {                                                                                                         // 1339
							e.preventDefault();                                                                                             // 1340
							if (e.preventManipulation) { //for some Microsoft browsers                                                      // 1341
								e.preventManipulation();                                                                                       // 1342
							}                                                                                                               // 1343
						}                                                                                                                // 1344
						self.pointerEvent = e;                                                                                           // 1345
						var touches = e.changedTouches,                                                                                  // 1346
							i;                                                                                                              // 1347
						if (touches) { //touch events store the data slightly differently                                                // 1348
							e = touches[0];                                                                                                 // 1349
							if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
								i = touches.length;                                                                                            // 1351
								while (--i > -1 && (e = touches[i]).identifier !== touchID) {}                                                 // 1352
								if (i < 0) {                                                                                                   // 1353
									return;                                                                                                       // 1354
								}                                                                                                              // 1355
							}                                                                                                               // 1356
						} else if (e.pointerId && touchID && e.pointerId !== touchID) { //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
							return;                                                                                                         // 1358
						}                                                                                                                // 1359
						if (self.autoScroll) {                                                                                           // 1360
							checkAutoScrollBounds = true;                                                                                   // 1361
						}                                                                                                                // 1362
						setPointerPosition(e.pageX, e.pageY);                                                                            // 1363
					},                                                                                                                // 1364
                                                                                                                       // 1365
					setPointerPosition = function(pointerX, pointerY) {                                                               // 1366
						var dragTolerance = 1 - self.dragResistance,                                                                     // 1367
							edgeTolerance = 1 - self.edgeResistance,                                                                        // 1368
							xChange, yChange, x, y, dif, temp;                                                                              // 1369
                                                                                                                       // 1370
						self.pointerX = pointerX;                                                                                        // 1371
						self.pointerY = pointerY;                                                                                        // 1372
                                                                                                                       // 1373
						if (rotationMode) {                                                                                              // 1374
							y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;                            // 1375
							dif = self.y - y;                                                                                               // 1376
							self.y = y;                                                                                                     // 1377
							if (dif > 180) {                                                                                                // 1378
								startElementY -= 360;                                                                                          // 1379
							} else if (dif < -180) {                                                                                        // 1380
								startElementY += 360;                                                                                          // 1381
							}                                                                                                               // 1382
							x = startElementX + (startElementY - y) * dragTolerance;                                                        // 1383
                                                                                                                       // 1384
						} else {                                                                                                         // 1385
							if (matrix) {                                                                                                   // 1386
								temp = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];                                                // 1387
								pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];                                            // 1388
								pointerX = temp;                                                                                               // 1389
							}                                                                                                               // 1390
							yChange = (pointerY - startPointerY);                                                                           // 1391
							xChange = (pointerX - startPointerX);                                                                           // 1392
							if (yChange < minimumMovement && yChange > -minimumMovement) {                                                  // 1393
								yChange = 0;                                                                                                   // 1394
							}                                                                                                               // 1395
							if (xChange < minimumMovement && xChange > -minimumMovement) {                                                  // 1396
								xChange = 0;                                                                                                   // 1397
							}                                                                                                               // 1398
							if (self.lockAxis && (xChange || yChange)) {                                                                    // 1399
								if (self.lockedAxis === "y" || (!self.lockedAxis && Math.abs(xChange) > Math.abs(yChange) && allowX)) {        // 1400
									yChange = 0;                                                                                                  // 1401
									self.lockedAxis = "y";                                                                                        // 1402
								} else if (allowY) {                                                                                           // 1403
									xChange = 0;                                                                                                  // 1404
									self.lockedAxis = "x";                                                                                        // 1405
								}                                                                                                              // 1406
							}                                                                                                               // 1407
							x = startElementX + xChange * dragTolerance;                                                                    // 1408
							y = startElementY + yChange * dragTolerance;                                                                    // 1409
						}                                                                                                                // 1410
                                                                                                                       // 1411
						if (snapX || snapY) {                                                                                            // 1412
							if (snapX) {                                                                                                    // 1413
								x = snapX(x);                                                                                                  // 1414
							}                                                                                                               // 1415
							if (snapY) {                                                                                                    // 1416
								y = snapY(y);                                                                                                  // 1417
							}                                                                                                               // 1418
						} else if (hasBounds) {                                                                                          // 1419
							if (x > maxX) {                                                                                                 // 1420
								x = maxX + (x - maxX) * edgeTolerance;                                                                         // 1421
							} else if (x < minX) {                                                                                          // 1422
								x = minX + (x - minX) * edgeTolerance;                                                                         // 1423
							}                                                                                                               // 1424
							if (!rotationMode) {                                                                                            // 1425
								if (y > maxY) {                                                                                                // 1426
									y = maxY + (y - maxY) * edgeTolerance;                                                                        // 1427
								} else if (y < minY) {                                                                                         // 1428
									y = minY + (y - minY) * edgeTolerance;                                                                        // 1429
								}                                                                                                              // 1430
							}                                                                                                               // 1431
						}                                                                                                                // 1432
						if (!rotationMode) {                                                                                             // 1433
							x = Math.round(x); //helps work around an issue with some Win Touch devices                                     // 1434
							y = Math.round(y);                                                                                              // 1435
						}                                                                                                                // 1436
						if (self.x !== x || (self.y !== y && !rotationMode)) {                                                           // 1437
							self.x = self.endX = x;                                                                                         // 1438
							if (rotationMode) {                                                                                             // 1439
								self.endRotation = x;                                                                                          // 1440
							} else {                                                                                                        // 1441
								self.y = self.endY = y;                                                                                        // 1442
							}                                                                                                               // 1443
							dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
							if (!self.isDragging) {                                                                                         // 1445
								self.isDragging = true;                                                                                        // 1446
								_dispatchEvent(self, "dragstart", "onDragStart");                                                              // 1447
							}                                                                                                               // 1448
						}                                                                                                                // 1449
					},                                                                                                                // 1450
                                                                                                                       // 1451
					//called when the mouse/touch is released                                                                         // 1452
					onRelease = function(e, force) {                                                                                  // 1453
						if (!enabled || e && touchID && !force && e.pointerId && e.pointerId !== touchID) {  //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
							return;                                                                                                         // 1455
						}                                                                                                                // 1456
						self.isPressed = false;                                                                                          // 1457
						var originalEvent = e,                                                                                           // 1458
							wasDragging = self.isDragging,                                                                                  // 1459
							touches, i, syntheticEvent, eventTarget;                                                                        // 1460
						if (touchEventTarget) {                                                                                          // 1461
							_removeListener(touchEventTarget, "touchend", onRelease);                                                       // 1462
							_removeListener(touchEventTarget, "touchmove", onMove);                                                         // 1463
							_removeListener(touchEventTarget, "touchcancel", onRelease);                                                    // 1464
							_removeListener(_doc, "touchstart", _onMultiTouchDocument);                                                     // 1465
						} else {                                                                                                         // 1466
							_removeListener(_doc, "mousemove", onMove);                                                                     // 1467
						}                                                                                                                // 1468
						_removeListener(_doc, "mouseup", onRelease);                                                                     // 1469
						if (e && e.target) {                                                                                             // 1470
							_removeListener(e.target, "mouseup", onRelease);                                                                // 1471
						}                                                                                                                // 1472
						dirty = false;                                                                                                   // 1473
						if (_placeholderDiv.parentNode) { //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up.
							_placeholderDiv.parentNode.removeChild(_placeholderDiv);                                                        // 1475
						}                                                                                                                // 1476
						if (isClicking) {                                                                                                // 1477
							if (e) {                                                                                                        // 1478
								_removeListener(e.target, "change", onRelease);                                                                // 1479
							}                                                                                                               // 1480
							_setSelectable(triggers, false);                                                                                // 1481
							_dispatchEvent(self, "release", "onRelease");                                                                   // 1482
							_dispatchEvent(self, "click", "onClick");                                                                       // 1483
							isClicking = false;                                                                                             // 1484
							return;                                                                                                         // 1485
						}                                                                                                                // 1486
						_removeFromRenderQueue(render);                                                                                  // 1487
						if (!rotationMode) {                                                                                             // 1488
							i = triggers.length;                                                                                            // 1489
							while (--i > -1) {                                                                                              // 1490
								_setStyle(triggers[i], "cursor", vars.cursor || "move");                                                       // 1491
							}                                                                                                               // 1492
						}                                                                                                                // 1493
						if (wasDragging) {                                                                                               // 1494
							dragEndTime = _lastDragTime = _getTime();                                                                       // 1495
							self.isDragging = false;                                                                                        // 1496
						}                                                                                                                // 1497
						_dragCount--;                                                                                                    // 1498
						if (e) {                                                                                                         // 1499
							if (_isOldIE) {                                                                                                 // 1500
								e = _populateIEEvent(e, false);                                                                                // 1501
							}                                                                                                               // 1502
							touches = e.changedTouches;                                                                                     // 1503
							if (touches) { //touch events store the data slightly differently                                               // 1504
								e = touches[0];                                                                                                // 1505
								if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
									i = touches.length;                                                                                           // 1507
									while (--i > -1 && (e = touches[i]).identifier !== touchID) {}                                                // 1508
									if (i < 0) {                                                                                                  // 1509
										return;                                                                                                      // 1510
									}                                                                                                             // 1511
								}                                                                                                              // 1512
							}                                                                                                               // 1513
							self.pointerEvent = originalEvent;                                                                              // 1514
							self.pointerX = e.pageX;                                                                                        // 1515
							self.pointerY = e.pageY;                                                                                        // 1516
						}                                                                                                                // 1517
						if (originalEvent && !wasDragging) {                                                                             // 1518
							if (interrupted && (vars.snap || vars.bounds)) { //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
								animate(vars.throwProps);                                                                                      // 1520
							}                                                                                                               // 1521
							_dispatchEvent(self, "release", "onRelease");                                                                   // 1522
							_dispatchEvent(self, "click", "onClick");                                                                       // 1523
							eventTarget = originalEvent.target || originalEvent.srcElement || target; //old IE uses srcElement              // 1524
							if (eventTarget.click) { //some browsers (like mobile Safari) don't properly trigger the click event            // 1525
								eventTarget.click();                                                                                           // 1526
							} else if (_doc.createEvent) {                                                                                  // 1527
								syntheticEvent = _doc.createEvent("MouseEvents");                                                              // 1528
								syntheticEvent.initEvent("click", true, true);                                                                 // 1529
								eventTarget.dispatchEvent(syntheticEvent);                                                                     // 1530
							}                                                                                                               // 1531
							clickTime = _getTime();                                                                                         // 1532
						} else {                                                                                                         // 1533
							animate(vars.throwProps); //will skip if throwProps isn't defined or ThrowPropsPlugin isn't loaded.             // 1534
							if (!_isOldIE && originalEvent && (vars.dragClickables || !isClickable.call(self, originalEvent.target)) && wasDragging) {
								originalEvent.preventDefault();                                                                                // 1536
								if (originalEvent.preventManipulation) {                                                                       // 1537
									originalEvent.preventManipulation();  //for some Microsoft browsers                                           // 1538
								}                                                                                                              // 1539
							}                                                                                                               // 1540
							_dispatchEvent(self, "release", "onRelease");                                                                   // 1541
						}                                                                                                                // 1542
						if (wasDragging) {                                                                                               // 1543
							_dispatchEvent(self, "dragend", "onDragEnd");                                                                   // 1544
						}                                                                                                                // 1545
						return true;                                                                                                     // 1546
					},                                                                                                                // 1547
                                                                                                                       // 1548
					updateScroll = function(e) {                                                                                      // 1549
						if (e && self.isDragging) {                                                                                      // 1550
							var parent = e.target || e.srcElement || target.parentNode,                                                     // 1551
								deltaX = parent.scrollLeft - parent._gsScrollX,                                                                // 1552
								deltaY = parent.scrollTop - parent._gsScrollY;                                                                 // 1553
							if (deltaX || deltaY) {                                                                                         // 1554
								startPointerX -= deltaX;                                                                                       // 1555
								startPointerY -= deltaY;                                                                                       // 1556
								parent._gsScrollX += deltaX;                                                                                   // 1557
								parent._gsScrollY += deltaY;                                                                                   // 1558
								setPointerPosition(self.pointerX, self.pointerY);                                                              // 1559
							}                                                                                                               // 1560
						}                                                                                                                // 1561
					},                                                                                                                // 1562
                                                                                                                       // 1563
					onClick = function(e) {                                                                                           // 1564
						var time = _getTime(),                                                                                           // 1565
							recentlyClicked = time - clickTime < 40;                                                                        // 1566
						if (self.isPressed || time - dragEndTime < 20 || recentlyClicked) {                                              // 1567
							if (e.preventDefault) {                                                                                         // 1568
								e.preventDefault();                                                                                            // 1569
								if (recentlyClicked) {                                                                                         // 1570
									e.stopImmediatePropagation(); //otherwise some browsers bubble up click events, creating a duplicate.         // 1571
								}                                                                                                              // 1572
							} else {                                                                                                        // 1573
								e.returnValue = false;                                                                                         // 1574
							}                                                                                                               // 1575
							if (e.preventManipulation) {                                                                                    // 1576
								e.preventManipulation();  //for some Microsoft browsers                                                        // 1577
							}                                                                                                               // 1578
						}                                                                                                                // 1579
					};                                                                                                                // 1580
                                                                                                                       // 1581
				old = Draggable.get(this.target);                                                                                  // 1582
				if (old) {                                                                                                         // 1583
					old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)                             // 1584
				}                                                                                                                  // 1585
                                                                                                                       // 1586
				//give the user access to start/stop dragging...                                                                   // 1587
				this.startDrag = function(e) {                                                                                     // 1588
					onPress(e);                                                                                                       // 1589
					if (!self.isDragging) {                                                                                           // 1590
						self.isDragging = true;                                                                                          // 1591
						_dispatchEvent(self, "dragstart", "onDragStart");                                                                // 1592
					}                                                                                                                 // 1593
				};                                                                                                                 // 1594
				this.drag = onMove;                                                                                                // 1595
				this.endDrag = function(e) {                                                                                       // 1596
					onRelease(e, true);                                                                                               // 1597
				};                                                                                                                 // 1598
				this.timeSinceDrag = function() {                                                                                  // 1599
					return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;                                                   // 1600
				};                                                                                                                 // 1601
				this.hitTest = function(target, threshold) {                                                                       // 1602
					return Draggable.hitTest(self.target, target, threshold);                                                         // 1603
				};                                                                                                                 // 1604
                                                                                                                       // 1605
				this.getDirection = function(from, diagonalThreshold) { //from can be "start" (default), "velocity", or an element // 1606
					var mode = (from === "velocity" && ThrowPropsPlugin) ? from : (typeof(from) === "object" && !rotationMode) ? "element" : "start",
						xChange, yChange, ratio, direction, r1, r2;                                                                      // 1608
					if (mode === "element") {                                                                                         // 1609
						r1 = _parseRect(self.target);                                                                                    // 1610
						r2 = _parseRect(from);                                                                                           // 1611
					}                                                                                                                 // 1612
					xChange = (mode === "start") ? self.x - startElementX : (mode === "velocity") ? ThrowPropsPlugin.getVelocity(this.target, xProp) : (r1.left + r1.width / 2) - (r2.left + r2.width / 2);
					if (rotationMode) {                                                                                               // 1614
						return xChange < 0 ? "counter-clockwise" : "clockwise";                                                          // 1615
					} else {                                                                                                          // 1616
						diagonalThreshold = diagonalThreshold || 2;                                                                      // 1617
						yChange = (mode === "start") ? self.y - startElementY : (mode === "velocity") ? ThrowPropsPlugin.getVelocity(this.target, yProp) : (r1.top + r1.height / 2) - (r2.top + r2.height / 2);
						ratio = Math.abs(xChange / yChange);                                                                             // 1619
						direction = (ratio < 1 / diagonalThreshold) ? "" : (xChange < 0) ? "left" : "right";                             // 1620
						if (ratio < diagonalThreshold) {                                                                                 // 1621
							if (direction !== "") {                                                                                         // 1622
								direction += "-";                                                                                              // 1623
							}                                                                                                               // 1624
							direction += (yChange < 0) ? "up" : "down";                                                                     // 1625
						}                                                                                                                // 1626
					}                                                                                                                 // 1627
					return direction;                                                                                                 // 1628
				};                                                                                                                 // 1629
                                                                                                                       // 1630
                                                                                                                       // 1631
				this.applyBounds = function(newBounds) {                                                                           // 1632
					var x, y;                                                                                                         // 1633
					if (newBounds && vars.bounds !== newBounds) {                                                                     // 1634
						vars.bounds = newBounds;                                                                                         // 1635
						return self.update(true);                                                                                        // 1636
					}                                                                                                                 // 1637
					syncXY(true);                                                                                                     // 1638
					calculateBounds();                                                                                                // 1639
					if (hasBounds) {                                                                                                  // 1640
						x = self.x;                                                                                                      // 1641
						y = self.y;                                                                                                      // 1642
						if (hasBounds) {                                                                                                 // 1643
							if (x > maxX) {                                                                                                 // 1644
								x = maxX;                                                                                                      // 1645
							} else if (x < minX) {                                                                                          // 1646
								x = minX;                                                                                                      // 1647
							}                                                                                                               // 1648
							if (y > maxY) {                                                                                                 // 1649
								y = maxY;                                                                                                      // 1650
							} else if (y < minY) {                                                                                          // 1651
								y = minY;                                                                                                      // 1652
							}                                                                                                               // 1653
						}                                                                                                                // 1654
						if (self.x !== x || self.y !== y) {                                                                              // 1655
							self.x = self.endX = x;                                                                                         // 1656
							if (rotationMode) {                                                                                             // 1657
								self.endRotation = x;                                                                                          // 1658
							} else {                                                                                                        // 1659
								self.y = self.endY = y;                                                                                        // 1660
							}                                                                                                               // 1661
							dirty = true;                                                                                                   // 1662
							render();                                                                                                       // 1663
						}                                                                                                                // 1664
					}                                                                                                                 // 1665
					return self;                                                                                                      // 1666
				};                                                                                                                 // 1667
                                                                                                                       // 1668
				this.update = function(applyBounds) {                                                                              // 1669
					var x = self.x,                                                                                                   // 1670
						y = self.y;                                                                                                      // 1671
					updateMatrix();                                                                                                   // 1672
					updateScroll();                                                                                                   // 1673
					if (applyBounds) {                                                                                                // 1674
						self.applyBounds();                                                                                              // 1675
					} else {                                                                                                          // 1676
						if (dirty) {                                                                                                     // 1677
							render();                                                                                                       // 1678
						}                                                                                                                // 1679
						syncXY(true);                                                                                                    // 1680
					}                                                                                                                 // 1681
					if (self.isPressed && ((allowX && Math.abs(x - self.x) > 0.01) || (allowY && (Math.abs(y - self.y) > 0.01 && !rotationMode)))) {
						recordStartPositions();                                                                                          // 1683
					}                                                                                                                 // 1684
					return self;                                                                                                      // 1685
				};                                                                                                                 // 1686
                                                                                                                       // 1687
				this.enable = function(type) {                                                                                     // 1688
					var id, i, trigger;                                                                                               // 1689
					if (type !== "soft") {                                                                                            // 1690
						i = triggers.length;                                                                                             // 1691
						while (--i > -1) {                                                                                               // 1692
							trigger = triggers[i];                                                                                          // 1693
							_addListener(trigger, "mousedown", onPress);                                                                    // 1694
							_addListener(trigger, "touchstart", onPress);                                                                   // 1695
							_addListener(trigger, "click", onClick);                                                                        // 1696
							if (!rotationMode) {                                                                                            // 1697
								_setStyle(trigger, "cursor", vars.cursor || "move");                                                           // 1698
							}                                                                                                               // 1699
							_setStyle(trigger, "touchCallout", "none");                                                                     // 1700
							_setStyle(trigger, "touchAction", "none");                                                                      // 1701
						}                                                                                                                // 1702
						_setSelectable(triggers, false);                                                                                 // 1703
					}                                                                                                                 // 1704
					_addScrollListener(self.target, updateScroll);                                                                    // 1705
					enabled = true;                                                                                                   // 1706
					if (ThrowPropsPlugin && type !== "soft") {                                                                        // 1707
						ThrowPropsPlugin.track(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));        // 1708
					}                                                                                                                 // 1709
					if (scrollProxy) {                                                                                                // 1710
						scrollProxy.enable();                                                                                            // 1711
					}                                                                                                                 // 1712
					target._gsDragID = id = "d" + (_lookupCount++);                                                                   // 1713
					_lookup[id] = this;                                                                                               // 1714
					if (scrollProxy) {                                                                                                // 1715
						scrollProxy.element._gsDragID = id;                                                                              // 1716
					}                                                                                                                 // 1717
					TweenLite.set(target, {x:"+=0"}); //simply ensures that there's a _gsTransform on the element.                    // 1718
					applyObj = {                                                                                                      // 1719
						t:target,                                                                                                        // 1720
						data:_isOldIE ? cssVars : target._gsTransform,                                                                   // 1721
						tween:{},                                                                                                        // 1722
						setRatio:(_isOldIE ? function() { TweenLite.set(target, tempVars); } : CSSPlugin._internals.set3DTransformRatio) // 1723
					};                                                                                                                // 1724
					this.update(true);                                                                                                // 1725
					return self;                                                                                                      // 1726
				};                                                                                                                 // 1727
                                                                                                                       // 1728
				this.disable = function(type) {                                                                                    // 1729
					var dragging = this.isDragging,                                                                                   // 1730
						i, trigger;                                                                                                      // 1731
					if (!rotationMode) {                                                                                              // 1732
						i = triggers.length;                                                                                             // 1733
						while (--i > -1) {                                                                                               // 1734
							_setStyle(triggers[i], "cursor", null);                                                                         // 1735
						}                                                                                                                // 1736
					}                                                                                                                 // 1737
					if (type !== "soft") {                                                                                            // 1738
						i = triggers.length;                                                                                             // 1739
						while (--i > -1) {                                                                                               // 1740
							trigger = triggers[i];                                                                                          // 1741
							_setStyle(trigger, "touchCallout", "default");                                                                  // 1742
							_setStyle(trigger, "MSTouchAction", "auto");                                                                    // 1743
							_removeListener(trigger, "mousedown", onPress);                                                                 // 1744
							_removeListener(trigger, "touchstart", onPress);                                                                // 1745
							_removeListener(trigger, "click", onClick);                                                                     // 1746
						}                                                                                                                // 1747
						_setSelectable(triggers, true);                                                                                  // 1748
						if (touchEventTarget) {                                                                                          // 1749
							_removeListener(touchEventTarget, "touchcancel", onRelease);                                                    // 1750
							_removeListener(touchEventTarget, "touchend", onRelease);                                                       // 1751
							_removeListener(touchEventTarget, "touchmove", onMove);                                                         // 1752
						}                                                                                                                // 1753
						_removeListener(_doc, "mouseup", onRelease);                                                                     // 1754
						_removeListener(_doc, "mousemove", onMove);                                                                      // 1755
					}                                                                                                                 // 1756
					_removeScrollListener(target, updateScroll);                                                                      // 1757
					enabled = false;                                                                                                  // 1758
					if (ThrowPropsPlugin && type !== "soft") {                                                                        // 1759
						ThrowPropsPlugin.untrack(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));      // 1760
					}                                                                                                                 // 1761
					if (scrollProxy) {                                                                                                // 1762
						scrollProxy.disable();                                                                                           // 1763
					}                                                                                                                 // 1764
					_removeFromRenderQueue(render);                                                                                   // 1765
					this.isDragging = this.isPressed = isClicking = false;                                                            // 1766
					if (dragging) {                                                                                                   // 1767
						_dispatchEvent(this, "dragend", "onDragEnd");                                                                    // 1768
					}                                                                                                                 // 1769
					return self;                                                                                                      // 1770
				};                                                                                                                 // 1771
                                                                                                                       // 1772
				this.enabled = function(value, type) {                                                                             // 1773
					return arguments.length ? (value ? this.enable(type) : this.disable(type)) : enabled;                             // 1774
				};                                                                                                                 // 1775
                                                                                                                       // 1776
				this.kill = function() {                                                                                           // 1777
					TweenLite.killTweensOf(scrollProxy || target, true, killProps);                                                   // 1778
					self.disable();                                                                                                   // 1779
					delete _lookup[target._gsDragID];                                                                                 // 1780
					return self;                                                                                                      // 1781
				};                                                                                                                 // 1782
                                                                                                                       // 1783
				if (type.indexOf("scroll") !== -1) {                                                                               // 1784
					scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({onKill:function() { //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
						if (self.isPressed) {                                                                                            // 1786
							onRelease(null);                                                                                                // 1787
						}}}, vars));                                                                                                     // 1788
					//a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)
					target.style.overflowY = (allowY && !_isTouchDevice) ? "auto" : "hidden";                                         // 1790
					target.style.overflowX = (allowX && !_isTouchDevice) ? "auto" : "hidden";                                         // 1791
					target = scrollProxy.content;                                                                                     // 1792
				}                                                                                                                  // 1793
                                                                                                                       // 1794
				if (vars.force3D !== false) {                                                                                      // 1795
					TweenLite.set(target, {force3D:true}); //improve performance by forcing a GPU layer when possible                 // 1796
				}                                                                                                                  // 1797
				if (rotationMode) {                                                                                                // 1798
					killProps.rotation = 1;                                                                                           // 1799
				} else {                                                                                                           // 1800
					if (allowX) {                                                                                                     // 1801
						killProps[xProp] = 1;                                                                                            // 1802
					}                                                                                                                 // 1803
					if (allowY) {                                                                                                     // 1804
						killProps[yProp] = 1;                                                                                            // 1805
					}                                                                                                                 // 1806
				}                                                                                                                  // 1807
				if (rotationMode) {                                                                                                // 1808
					tempVars = _tempVarsRotation;                                                                                     // 1809
					cssVars = tempVars.css;                                                                                           // 1810
					tempVars.overwrite = false;                                                                                       // 1811
				} else if (xyMode) {                                                                                               // 1812
					tempVars = (allowX && allowY) ? _tempVarsXY : allowX ? _tempVarsX : _tempVarsY;                                   // 1813
					cssVars = tempVars.css;                                                                                           // 1814
					tempVars.overwrite = false;                                                                                       // 1815
				}                                                                                                                  // 1816
                                                                                                                       // 1817
				this.enable();                                                                                                     // 1818
			},                                                                                                                  // 1819
			p = Draggable.prototype = new EventDispatcher();                                                                    // 1820
                                                                                                                       // 1821
		p.constructor = Draggable;                                                                                           // 1822
		p.pointerX = p.pointerY = 0;                                                                                         // 1823
		p.isDragging = p.isPressed = false;                                                                                  // 1824
		Draggable.version = "0.12.0";                                                                                        // 1825
		Draggable.zIndex = 1000;                                                                                             // 1826
                                                                                                                       // 1827
		_addListener(_doc, "touchcancel", function() {                                                                       // 1828
			//some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.
		});                                                                                                                  // 1830
		_addListener(_doc, "contextmenu", function(e) {                                                                      // 1831
			var p;                                                                                                              // 1832
			for (p in _lookup) {                                                                                                // 1833
				if (_lookup[p].isPressed) {                                                                                        // 1834
					_lookup[p].endDrag();                                                                                             // 1835
				}                                                                                                                  // 1836
			}                                                                                                                   // 1837
		});                                                                                                                  // 1838
                                                                                                                       // 1839
		Draggable.create = function(targets, vars) {                                                                         // 1840
			if (typeof(targets) === "string") {                                                                                 // 1841
				targets = TweenLite.selector(targets);                                                                             // 1842
			}                                                                                                                   // 1843
			var a = _isArrayLike(targets) ? _flattenArray(targets) : [targets],                                                 // 1844
				i = a.length;                                                                                                      // 1845
			while (--i > -1) {                                                                                                  // 1846
				a[i] = new Draggable(a[i], vars);                                                                                  // 1847
			}                                                                                                                   // 1848
			return a;                                                                                                           // 1849
		};                                                                                                                   // 1850
                                                                                                                       // 1851
		Draggable.get = function(target) {                                                                                   // 1852
			return _lookup[(_unwrapElement(target) || {})._gsDragID];                                                           // 1853
		};                                                                                                                   // 1854
                                                                                                                       // 1855
		Draggable.timeSinceDrag = function() {                                                                               // 1856
			return (_getTime() - _lastDragTime) / 1000;                                                                         // 1857
		};                                                                                                                   // 1858
                                                                                                                       // 1859
		var _parseRect = function(e, undefined) { //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
			var r = (e.pageX !== undefined) ? {left:e.pageX, top:e.pageY, right:e.pageX + 1, bottom:e.pageY + 1} : (!e.nodeType && e.left !== undefined && e.top !== undefined) ? e : _unwrapElement(e).getBoundingClientRect();
			if (r.right === undefined && r.width !== undefined) {                                                               // 1862
				r.right = r.left + r.width;                                                                                        // 1863
				r.bottom = r.top + r.height;                                                                                       // 1864
			} else if (r.width === undefined) { //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
				r = {width: r.right - r.left, height: r.bottom - r.top, right: r.right, left: r.left, bottom: r.bottom, top: r.top};
			}                                                                                                                   // 1867
			return r;                                                                                                           // 1868
		};                                                                                                                   // 1869
                                                                                                                       // 1870
		Draggable.hitTest = function(obj1, obj2, threshold) {                                                                // 1871
			if (obj1 === obj2) {                                                                                                // 1872
				return false;                                                                                                      // 1873
			}                                                                                                                   // 1874
			var r1 = _parseRect(obj1),                                                                                          // 1875
				r2 = _parseRect(obj2),                                                                                             // 1876
				isOutside = (r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top),                // 1877
				overlap, area, isRatio;                                                                                            // 1878
			if (isOutside || !threshold) {                                                                                      // 1879
				return !isOutside;                                                                                                 // 1880
			}                                                                                                                   // 1881
			isRatio = ((threshold + "").indexOf("%") !== -1);                                                                   // 1882
			threshold = parseFloat(threshold) || 0;                                                                             // 1883
			overlap = {left:Math.max(r1.left, r2.left), top:Math.max(r1.top, r2.top)};                                          // 1884
			overlap.width = Math.min(r1.right, r2.right) - overlap.left;                                                        // 1885
			overlap.height = Math.min(r1.bottom, r2.bottom) - overlap.top;                                                      // 1886
			if (overlap.width < 0 || overlap.height < 0) {                                                                      // 1887
				return false;                                                                                                      // 1888
			}                                                                                                                   // 1889
			if (isRatio) {                                                                                                      // 1890
				threshold *= 0.01;                                                                                                 // 1891
				area = overlap.width * overlap.height;                                                                             // 1892
				return (area >= r1.width * r1.height * threshold || area >= r2.width * r2.height * threshold);                     // 1893
			}                                                                                                                   // 1894
			return (overlap.width > threshold && overlap.height > threshold);                                                   // 1895
		};                                                                                                                   // 1896
                                                                                                                       // 1897
		_placeholderDiv.style.cssText = "visibility:hidden; height:1px; top:-1px; pointer-events:none; position:relative; clear:both;";
                                                                                                                       // 1899
		return Draggable;                                                                                                    // 1900
                                                                                                                       // 1901
	}, true);                                                                                                             // 1902
                                                                                                                       // 1903
                                                                                                                       // 1904
}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }                                                             // 1905
                                                                                                                       // 1906
//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)            // 1907
(function(name) {                                                                                                      // 1908
	"use strict";                                                                                                         // 1909
	var getGlobal = function() {                                                                                          // 1910
		return (_gsScope.GreenSockGlobals || _gsScope)[name];                                                                // 1911
	};                                                                                                                    // 1912
	if (typeof(define) === "function" && define.amd) { //AMD                                                              // 1913
		define(["TweenLite"], getGlobal);                                                                                    // 1914
	} else if (typeof(module) !== "undefined" && module.exports) { //node                                                 // 1915
		require("../TweenLite.js");                                                                                          // 1916
		require("../plugins/CSSPlugin.js");                                                                                  // 1917
		module.exports = getGlobal();                                                                                        // 1918
	}                                                                                                                     // 1919
}("Draggable"));                                                                                                       // 1920
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/infinitedg:gsap/vendor/TweenMax_client.js                                                                  //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*!                                                                                                                    // 1
 * VERSION: 1.16.0                                                                                                     // 2
 * DATE: 2015-03-01                                                                                                    // 3
 * UPDATES AND DOCS AT: http://greensock.com                                                                           // 4
 *                                                                                                                     // 5
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *                                                                                                                     // 7
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.                                                   // 8
 * This work is subject to the terms at http://greensock.com/standard-license or for                                   // 9
 * Club GreenSock members, the software agreement that was issued with your membership.                                // 10
 *                                                                                                                     // 11
 * @author: Jack Doyle, jack@greensock.com                                                                             // 12
 **/                                                                                                                   // 13
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {                                                     // 15
                                                                                                                       // 16
	"use strict";                                                                                                         // 17
                                                                                                                       // 18
	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
                                                                                                                       // 20
		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],                                                                                                        // 22
					l = a.length,                                                                                                     // 23
					i;                                                                                                                // 24
				for (i = 0; i !== l; b.push(a[i++]));                                                                              // 25
				return b;                                                                                                          // 26
			},                                                                                                                  // 27
			TweenMax = function(target, duration, vars) {                                                                       // 28
				TweenLite.call(this, target, duration, vars);                                                                      // 29
				this._cycle = 0;                                                                                                   // 30
				this._yoyo = (this.vars.yoyo === true);                                                                            // 31
				this._repeat = this.vars.repeat || 0;                                                                              // 32
				this._repeatDelay = this.vars.repeatDelay || 0;                                                                    // 33
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)        // 35
			},                                                                                                                  // 36
			_tinyNum = 0.0000000001,                                                                                            // 37
			TweenLiteInternals = TweenLite._internals,                                                                          // 38
			_isSelector = TweenLiteInternals.isSelector,                                                                        // 39
			_isArray = TweenLiteInternals.isArray,                                                                              // 40
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),                                                                 // 41
			_blankArray = [];                                                                                                   // 42
                                                                                                                       // 43
		TweenMax.version = "1.16.0";                                                                                         // 44
		p.constructor = TweenMax;                                                                                            // 45
		p.kill()._gc = false;                                                                                                // 46
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;                                        // 47
		TweenMax.getTweensOf = TweenLite.getTweensOf;                                                                        // 48
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;                                                                      // 49
		TweenMax.ticker = TweenLite.ticker;                                                                                  // 50
		TweenMax.render = TweenLite.render;                                                                                  // 51
                                                                                                                       // 52
		p.invalidate = function() {                                                                                          // 53
			this._yoyo = (this.vars.yoyo === true);                                                                             // 54
			this._repeat = this.vars.repeat || 0;                                                                               // 55
			this._repeatDelay = this.vars.repeatDelay || 0;                                                                     // 56
			this._uncache(true);                                                                                                // 57
			return TweenLite.prototype.invalidate.call(this);                                                                   // 58
		};                                                                                                                   // 59
		                                                                                                                     // 60
		p.updateTo = function(vars, resetDuration) {                                                                         // 61
			var curRatio = this.ratio,                                                                                          // 62
				immediate = this.vars.immediateRender || vars.immediateRender,                                                     // 63
				p;                                                                                                                 // 64
			if (resetDuration && this._startTime < this._timeline._time) {                                                      // 65
				this._startTime = this._timeline._time;                                                                            // 66
				this._uncache(false);                                                                                              // 67
				if (this._gc) {                                                                                                    // 68
					this._enabled(true, false);                                                                                       // 69
				} else {                                                                                                           // 70
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}                                                                                                                  // 72
			}                                                                                                                   // 73
			for (p in vars) {                                                                                                   // 74
				this.vars[p] = vars[p];                                                                                            // 75
			}                                                                                                                   // 76
			if (this._initted || immediate) {                                                                                   // 77
				if (resetDuration) {                                                                                               // 78
					this._initted = false;                                                                                            // 79
					if (immediate) {                                                                                                  // 80
						this.render(0, true, true);                                                                                      // 81
					}                                                                                                                 // 82
				} else {                                                                                                           // 83
					if (this._gc) {                                                                                                   // 84
						this._enabled(true, false);                                                                                      // 85
					}                                                                                                                 // 86
					if (this._notifyPluginsOfEnabled && this._firstPT) {                                                              // 87
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks // 88
					}                                                                                                                 // 89
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._time;                                                                                       // 91
						this.render(0, true, false);                                                                                     // 92
						this._initted = false;                                                                                           // 93
						this.render(prevTime, true, false);                                                                              // 94
					} else if (this._time > 0 || immediate) {                                                                         // 95
						this._initted = false;                                                                                           // 96
						this._init();                                                                                                    // 97
						var inv = 1 / (1 - curRatio),                                                                                    // 98
							pt = this._firstPT, endValue;                                                                                   // 99
						while (pt) {                                                                                                     // 100
							endValue = pt.s + pt.c;                                                                                         // 101
							pt.c *= inv;                                                                                                    // 102
							pt.s = endValue - pt.c;                                                                                         // 103
							pt = pt._next;                                                                                                  // 104
						}                                                                                                                // 105
					}                                                                                                                 // 106
				}                                                                                                                  // 107
			}                                                                                                                   // 108
			return this;                                                                                                        // 109
		};                                                                                                                   // 110
				                                                                                                                   // 111
		p.render = function(time, suppressEvents, force) {                                                                   // 112
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();                                                                                                 // 114
			}                                                                                                                   // 115
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),                                         // 116
				prevTime = this._time,                                                                                             // 117
				prevTotalTime = this._totalTime,                                                                                   // 118
				prevCycle = this._cycle,                                                                                           // 119
				duration = this._duration,                                                                                         // 120
				prevRawPrevTime = this._rawPrevTime,                                                                               // 121
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, i;                                             // 122
			if (time >= totalDur) {                                                                                             // 123
				this._totalTime = totalDur;                                                                                        // 124
				this._cycle = this._repeat;                                                                                        // 125
				if (this._yoyo && (this._cycle & 1) !== 0) {                                                                       // 126
					this._time = 0;                                                                                                   // 127
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;                                                    // 128
				} else {                                                                                                           // 129
					this._time = duration;                                                                                            // 130
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;                                                    // 131
				}                                                                                                                  // 132
				if (!this._reversed) {                                                                                             // 133
					isComplete = true;                                                                                                // 134
					callback = "onComplete";                                                                                          // 135
				}                                                                                                                  // 136
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;                                                                                                        // 139
					}                                                                                                                 // 140
					if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time) {            // 141
						force = true;                                                                                                    // 142
						if (prevRawPrevTime > _tinyNum) {                                                                                // 143
							callback = "onReverseComplete";                                                                                 // 144
						}                                                                                                                // 145
					}                                                                                                                 // 146
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}                                                                                                                  // 148
				                                                                                                                   // 149
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;                                                                    // 151
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;                                                     // 152
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {                                              // 153
					callback = "onReverseComplete";                                                                                   // 154
					isComplete = this._reversed;                                                                                      // 155
				}                                                                                                                  // 156
				if (time < 0) {                                                                                                    // 157
					this._active = false;                                                                                             // 158
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {                                                                                      // 160
							force = true;                                                                                                   // 161
						}                                                                                                                // 162
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}                                                                                                                 // 164
				}                                                                                                                  // 165
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;                                                                                                     // 167
				}                                                                                                                  // 168
			} else {                                                                                                            // 169
				this._totalTime = this._time = time;                                                                               // 170
				                                                                                                                   // 171
				if (this._repeat !== 0) {                                                                                          // 172
					cycleDuration = duration + this._repeatDelay;                                                                     // 173
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but Flash reports it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {                                     // 175
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}                                                                                                                 // 177
					this._time = this._totalTime - (this._cycle * cycleDuration);                                                     // 178
					if (this._yoyo) if ((this._cycle & 1) !== 0) {                                                                    // 179
						this._time = duration - this._time;                                                                              // 180
					}                                                                                                                 // 181
					if (this._time > duration) {                                                                                      // 182
						this._time = duration;                                                                                           // 183
					} else if (this._time < 0) {                                                                                      // 184
						this._time = 0;                                                                                                  // 185
					}                                                                                                                 // 186
				}                                                                                                                  // 187
                                                                                                                       // 188
				if (this._easeType) {                                                                                              // 189
					r = this._time / duration;                                                                                        // 190
					type = this._easeType;                                                                                            // 191
					pow = this._easePower;                                                                                            // 192
					if (type === 1 || (type === 3 && r >= 0.5)) {                                                                     // 193
						r = 1 - r;                                                                                                       // 194
					}                                                                                                                 // 195
					if (type === 3) {                                                                                                 // 196
						r *= 2;                                                                                                          // 197
					}                                                                                                                 // 198
					if (pow === 1) {                                                                                                  // 199
						r *= r;                                                                                                          // 200
					} else if (pow === 2) {                                                                                           // 201
						r *= r * r;                                                                                                      // 202
					} else if (pow === 3) {                                                                                           // 203
						r *= r * r * r;                                                                                                  // 204
					} else if (pow === 4) {                                                                                           // 205
						r *= r * r * r * r;                                                                                              // 206
					}                                                                                                                 // 207
                                                                                                                       // 208
					if (type === 1) {                                                                                                 // 209
						this.ratio = 1 - r;                                                                                              // 210
					} else if (type === 2) {                                                                                          // 211
						this.ratio = r;                                                                                                  // 212
					} else if (this._time / duration < 0.5) {                                                                         // 213
						this.ratio = r / 2;                                                                                              // 214
					} else {                                                                                                          // 215
						this.ratio = 1 - (r / 2);                                                                                        // 216
					}                                                                                                                 // 217
                                                                                                                       // 218
				} else {                                                                                                           // 219
					this.ratio = this._ease.getRatio(this._time / duration);                                                          // 220
				}                                                                                                                  // 221
				                                                                                                                   // 222
			}                                                                                                                   // 223
				                                                                                                                   // 224
			if (prevTime === this._time && !force && prevCycle === this._cycle) {                                               // 225
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);                   // 227
				}                                                                                                                  // 228
				return;                                                                                                            // 229
			} else if (!this._initted) {                                                                                        // 230
				this._init();                                                                                                      // 231
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;                                                                                                           // 233
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;                                                                                            // 235
					this._totalTime = prevTotalTime;                                                                                  // 236
					this._rawPrevTime = prevRawPrevTime;                                                                              // 237
					this._cycle = prevCycle;                                                                                          // 238
					TweenLiteInternals.lazyTweens.push(this);                                                                         // 239
					this._lazy = [time, suppressEvents];                                                                              // 240
					return;                                                                                                           // 241
				}                                                                                                                  // 242
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {                                                                                   // 244
					this.ratio = this._ease.getRatio(this._time / duration);                                                          // 245
				} else if (isComplete && this._ease._calcEnd) {                                                                    // 246
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);                                                     // 247
				}                                                                                                                  // 248
			}                                                                                                                   // 249
			if (this._lazy !== false) {                                                                                         // 250
				this._lazy = false;                                                                                                // 251
			}                                                                                                                   // 252
                                                                                                                       // 253
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {                                     // 254
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}                                                                                                                   // 256
			if (prevTotalTime === 0) {                                                                                          // 257
				if (this._initted === 2 && time > 0) {                                                                             // 258
					//this.invalidate();                                                                                              // 259
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}                                                                                                                  // 261
				if (this._startAt) {                                                                                               // 262
					if (time >= 0) {                                                                                                  // 263
						this._startAt.render(time, suppressEvents, force);                                                               // 264
					} else if (!callback) {                                                                                           // 265
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}                                                                                                                 // 267
				}                                                                                                                  // 268
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {                         // 269
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);                  // 270
				}                                                                                                                  // 271
			}                                                                                                                   // 272
			                                                                                                                    // 273
			pt = this._firstPT;                                                                                                 // 274
			while (pt) {                                                                                                        // 275
				if (pt.f) {                                                                                                        // 276
					pt.t[pt.p](pt.c * this.ratio + pt.s);                                                                             // 277
				} else {                                                                                                           // 278
					pt.t[pt.p] = pt.c * this.ratio + pt.s;                                                                            // 279
				}                                                                                                                  // 280
				pt = pt._next;                                                                                                     // 281
			}                                                                                                                   // 282
			                                                                                                                    // 283
			if (this._onUpdate) {                                                                                               // 284
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}                                                                                                                  // 287
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || isComplete) {                                        // 288
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);                   // 289
				}                                                                                                                  // 290
			}                                                                                                                   // 291
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {                        // 292
				this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);                // 293
			}                                                                                                                   // 294
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);                                                                // 297
				}                                                                                                                  // 298
				if (isComplete) {                                                                                                  // 299
					if (this._timeline.autoRemoveChildren) {                                                                          // 300
						this._enabled(false, false);                                                                                     // 301
					}                                                                                                                 // 302
					this._active = false;                                                                                             // 303
				}                                                                                                                  // 304
				if (!suppressEvents && this.vars[callback]) {                                                                      // 305
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);  // 306
				}                                                                                                                  // 307
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;                                                                                            // 309
				}                                                                                                                  // 310
			}                                                                                                                   // 311
		};                                                                                                                   // 312
		                                                                                                                     // 313
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		                                                                                                                     // 315
		TweenMax.to = function(target, duration, vars) {                                                                     // 316
			return new TweenMax(target, duration, vars);                                                                        // 317
		};                                                                                                                   // 318
		                                                                                                                     // 319
		TweenMax.from = function(target, duration, vars) {                                                                   // 320
			vars.runBackwards = true;                                                                                           // 321
			vars.immediateRender = (vars.immediateRender != false);                                                             // 322
			return new TweenMax(target, duration, vars);                                                                        // 323
		};                                                                                                                   // 324
		                                                                                                                     // 325
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {                                                     // 326
			toVars.startAt = fromVars;                                                                                          // 327
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);                    // 328
			return new TweenMax(target, duration, toVars);                                                                      // 329
		};                                                                                                                   // 330
		                                                                                                                     // 331
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;                                                                                             // 333
			var delay = vars.delay || 0,                                                                                        // 334
				a = [],                                                                                                            // 335
				finalComplete = function() {                                                                                       // 336
					if (vars.onComplete) {                                                                                            // 337
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);                                                  // 338
					}                                                                                                                 // 339
					onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray);                              // 340
				},                                                                                                                 // 341
				l, copy, i, p;                                                                                                     // 342
			if (!_isArray(targets)) {                                                                                           // 343
				if (typeof(targets) === "string") {                                                                                // 344
					targets = TweenLite.selector(targets) || targets;                                                                 // 345
				}                                                                                                                  // 346
				if (_isSelector(targets)) {                                                                                        // 347
					targets = _slice(targets);                                                                                        // 348
				}                                                                                                                  // 349
			}                                                                                                                   // 350
			targets = targets || [];                                                                                            // 351
			if (stagger < 0) {                                                                                                  // 352
				targets = _slice(targets);                                                                                         // 353
				targets.reverse();                                                                                                 // 354
				stagger *= -1;                                                                                                     // 355
			}                                                                                                                   // 356
			l = targets.length - 1;                                                                                             // 357
			for (i = 0; i <= l; i++) {                                                                                          // 358
				copy = {};                                                                                                         // 359
				for (p in vars) {                                                                                                  // 360
					copy[p] = vars[p];                                                                                                // 361
				}                                                                                                                  // 362
				copy.delay = delay;                                                                                                // 363
				if (i === l && onCompleteAll) {                                                                                    // 364
					copy.onComplete = finalComplete;                                                                                  // 365
				}                                                                                                                  // 366
				a[i] = new TweenMax(targets[i], duration, copy);                                                                   // 367
				delay += stagger;                                                                                                  // 368
			}                                                                                                                   // 369
			return a;                                                                                                           // 370
		};                                                                                                                   // 371
		                                                                                                                     // 372
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;                                                                                           // 374
			vars.immediateRender = (vars.immediateRender != false);                                                             // 375
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};                                                                                                                   // 377
		                                                                                                                     // 378
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;                                                                                          // 380
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);                    // 381
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};                                                                                                                   // 383
				                                                                                                                   // 384
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {                                         // 385
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, useFrames:useFrames, overwrite:0});
		};                                                                                                                   // 387
		                                                                                                                     // 388
		TweenMax.set = function(target, vars) {                                                                              // 389
			return new TweenMax(target, 0, vars);                                                                               // 390
		};                                                                                                                   // 391
		                                                                                                                     // 392
		TweenMax.isTweening = function(target) {                                                                             // 393
			return (TweenLite.getTweensOf(target, true).length > 0);                                                            // 394
		};                                                                                                                   // 395
		                                                                                                                     // 396
		var _getChildrenOf = function(timeline, includeTimelines) {                                                          // 397
				var a = [],                                                                                                        // 398
					cnt = 0,                                                                                                          // 399
					tween = timeline._first;                                                                                          // 400
				while (tween) {                                                                                                    // 401
					if (tween instanceof TweenLite) {                                                                                 // 402
						a[cnt++] = tween;                                                                                                // 403
					} else {                                                                                                          // 404
						if (includeTimelines) {                                                                                          // 405
							a[cnt++] = tween;                                                                                               // 406
						}                                                                                                                // 407
						a = a.concat(_getChildrenOf(tween, includeTimelines));                                                           // 408
						cnt = a.length;                                                                                                  // 409
					}                                                                                                                 // 410
					tween = tween._next;                                                                                              // 411
				}                                                                                                                  // 412
				return a;                                                                                                          // 413
			},                                                                                                                  // 414
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {                                                 // 415
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};                                                                                                                  // 417
		                                                                                                                     // 418
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {                                             // 419
			if (tweens == null) {                                                                                               // 420
				tweens = true;                                                                                                     // 421
			}                                                                                                                   // 422
			if (delayedCalls == null) {                                                                                         // 423
				delayedCalls = true;                                                                                               // 424
			}                                                                                                                   // 425
			var a = getAllTweens((timelines != false)),                                                                         // 426
				l = a.length,                                                                                                      // 427
				allTrue = (tweens && delayedCalls && timelines),                                                                   // 428
				isDC, tween, i;                                                                                                    // 429
			for (i = 0; i < l; i++) {                                                                                           // 430
				tween = a[i];                                                                                                      // 431
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {                                                                                                   // 433
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());                                                    // 434
					} else {                                                                                                          // 435
						tween._enabled(false, false);                                                                                    // 436
					}                                                                                                                 // 437
				}                                                                                                                  // 438
			}                                                                                                                   // 439
		};                                                                                                                   // 440
		                                                                                                                     // 441
		TweenMax.killChildTweensOf = function(parent, complete) {                                                            // 442
			if (parent == null) {                                                                                               // 443
				return;                                                                                                            // 444
			}                                                                                                                   // 445
			var tl = TweenLiteInternals.tweenLookup,                                                                            // 446
				a, curParent, p, i, l;                                                                                             // 447
			if (typeof(parent) === "string") {                                                                                  // 448
				parent = TweenLite.selector(parent) || parent;                                                                     // 449
			}                                                                                                                   // 450
			if (_isSelector(parent)) {                                                                                          // 451
				parent = _slice(parent);                                                                                           // 452
			}                                                                                                                   // 453
			if (_isArray(parent)) {                                                                                             // 454
				i = parent.length;                                                                                                 // 455
				while (--i > -1) {                                                                                                 // 456
					TweenMax.killChildTweensOf(parent[i], complete);                                                                  // 457
				}                                                                                                                  // 458
				return;                                                                                                            // 459
			}                                                                                                                   // 460
			a = [];                                                                                                             // 461
			for (p in tl) {                                                                                                     // 462
				curParent = tl[p].target.parentNode;                                                                               // 463
				while (curParent) {                                                                                                // 464
					if (curParent === parent) {                                                                                       // 465
						a = a.concat(tl[p].tweens);                                                                                      // 466
					}                                                                                                                 // 467
					curParent = curParent.parentNode;                                                                                 // 468
				}                                                                                                                  // 469
			}                                                                                                                   // 470
			l = a.length;                                                                                                       // 471
			for (i = 0; i < l; i++) {                                                                                           // 472
				if (complete) {                                                                                                    // 473
					a[i].totalTime(a[i].totalDuration());                                                                             // 474
				}                                                                                                                  // 475
				a[i]._enabled(false, false);                                                                                       // 476
			}                                                                                                                   // 477
		};                                                                                                                   // 478
                                                                                                                       // 479
		var _changePause = function(pause, tweens, delayedCalls, timelines) {                                                // 480
			tweens = (tweens !== false);                                                                                        // 481
			delayedCalls = (delayedCalls !== false);                                                                            // 482
			timelines = (timelines !== false);                                                                                  // 483
			var a = getAllTweens(timelines),                                                                                    // 484
				allTrue = (tweens && delayedCalls && timelines),                                                                   // 485
				i = a.length,                                                                                                      // 486
				isDC, tween;                                                                                                       // 487
			while (--i > -1) {                                                                                                  // 488
				tween = a[i];                                                                                                      // 489
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);                                                                                              // 491
				}                                                                                                                  // 492
			}                                                                                                                   // 493
		};                                                                                                                   // 494
		                                                                                                                     // 495
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {                                                      // 496
			_changePause(true, tweens, delayedCalls, timelines);                                                                // 497
		};                                                                                                                   // 498
		                                                                                                                     // 499
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {                                                     // 500
			_changePause(false, tweens, delayedCalls, timelines);                                                               // 501
		};                                                                                                                   // 502
                                                                                                                       // 503
		TweenMax.globalTimeScale = function(value) {                                                                         // 504
			var tl = Animation._rootTimeline,                                                                                   // 505
				t = TweenLite.ticker.time;                                                                                         // 506
			if (!arguments.length) {                                                                                            // 507
				return tl._timeScale;                                                                                              // 508
			}                                                                                                                   // 509
			value = value || _tinyNum; //can't allow zero because it'll throw the math off                                      // 510
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);                                                  // 511
			tl = Animation._rootFramesTimeline;                                                                                 // 512
			t = TweenLite.ticker.frame;                                                                                         // 513
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);                                                  // 514
			tl._timeScale = Animation._rootTimeline._timeScale = value;                                                         // 515
			return value;                                                                                                       // 516
		};                                                                                                                   // 517
		                                                                                                                     // 518
	                                                                                                                      // 519
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		                                                                                                                     // 521
		p.progress = function(value) {                                                                                       // 522
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), false);
		};                                                                                                                   // 524
		                                                                                                                     // 525
		p.totalProgress = function(value) {                                                                                  // 526
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, false);
		};                                                                                                                   // 528
		                                                                                                                     // 529
		p.time = function(value, suppressEvents) {                                                                           // 530
			if (!arguments.length) {                                                                                            // 531
				return this._time;                                                                                                 // 532
			}                                                                                                                   // 533
			if (this._dirty) {                                                                                                  // 534
				this.totalDuration();                                                                                              // 535
			}                                                                                                                   // 536
			if (value > this._duration) {                                                                                       // 537
				value = this._duration;                                                                                            // 538
			}                                                                                                                   // 539
			if (this._yoyo && (this._cycle & 1) !== 0) {                                                                        // 540
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));                           // 541
			} else if (this._repeat !== 0) {                                                                                    // 542
				value += this._cycle * (this._duration + this._repeatDelay);                                                       // 543
			}                                                                                                                   // 544
			return this.totalTime(value, suppressEvents);                                                                       // 545
		};                                                                                                                   // 546
                                                                                                                       // 547
		p.duration = function(value) {                                                                                       // 548
			if (!arguments.length) {                                                                                            // 549
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}                                                                                                                   // 551
			return Animation.prototype.duration.call(this, value);                                                              // 552
		};                                                                                                                   // 553
                                                                                                                       // 554
		p.totalDuration = function(value) {                                                                                  // 555
			if (!arguments.length) {                                                                                            // 556
				if (this._dirty) {                                                                                                 // 557
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses                                    // 558
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;                                                                                              // 560
				}                                                                                                                  // 561
				return this._totalDuration;                                                                                        // 562
			}                                                                                                                   // 563
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};                                                                                                                   // 565
		                                                                                                                     // 566
		p.repeat = function(value) {                                                                                         // 567
			if (!arguments.length) {                                                                                            // 568
				return this._repeat;                                                                                               // 569
			}                                                                                                                   // 570
			this._repeat = value;                                                                                               // 571
			return this._uncache(true);                                                                                         // 572
		};                                                                                                                   // 573
		                                                                                                                     // 574
		p.repeatDelay = function(value) {                                                                                    // 575
			if (!arguments.length) {                                                                                            // 576
				return this._repeatDelay;                                                                                          // 577
			}                                                                                                                   // 578
			this._repeatDelay = value;                                                                                          // 579
			return this._uncache(true);                                                                                         // 580
		};                                                                                                                   // 581
		                                                                                                                     // 582
		p.yoyo = function(value) {                                                                                           // 583
			if (!arguments.length) {                                                                                            // 584
				return this._yoyo;                                                                                                 // 585
			}                                                                                                                   // 586
			this._yoyo = value;                                                                                                 // 587
			return this;                                                                                                        // 588
		};                                                                                                                   // 589
		                                                                                                                     // 590
		                                                                                                                     // 591
		return TweenMax;                                                                                                     // 592
		                                                                                                                     // 593
	}, true);                                                                                                             // 594
                                                                                                                       // 595
                                                                                                                       // 596
                                                                                                                       // 597
                                                                                                                       // 598
                                                                                                                       // 599
                                                                                                                       // 600
                                                                                                                       // 601
                                                                                                                       // 602
/*                                                                                                                     // 603
 * ----------------------------------------------------------------                                                    // 604
 * TimelineLite                                                                                                        // 605
 * ----------------------------------------------------------------                                                    // 606
 */                                                                                                                    // 607
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
                                                                                                                       // 609
		var TimelineLite = function(vars) {                                                                                  // 610
				SimpleTimeline.call(this, vars);                                                                                   // 611
				this._labels = {};                                                                                                 // 612
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);                                                 // 613
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);                                                   // 614
				this._sortChildren = true;                                                                                         // 615
				this._onUpdate = this.vars.onUpdate;                                                                               // 616
				var v = this.vars,                                                                                                 // 617
					val, p;                                                                                                           // 618
				for (p in v) {                                                                                                     // 619
					val = v[p];                                                                                                       // 620
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {                                                   // 621
						v[p] = this._swapSelfInParams(val);                                                                              // 622
					}                                                                                                                 // 623
				}                                                                                                                  // 624
				if (_isArray(v.tweens)) {                                                                                          // 625
					this.add(v.tweens, 0, v.align, v.stagger);                                                                        // 626
				}                                                                                                                  // 627
			},                                                                                                                  // 628
			_tinyNum = 0.0000000001,                                                                                            // 629
			TweenLiteInternals = TweenLite._internals,                                                                          // 630
			_internals = TimelineLite._internals = {},                                                                          // 631
			_isSelector = TweenLiteInternals.isSelector,                                                                        // 632
			_isArray = TweenLiteInternals.isArray,                                                                              // 633
			_lazyTweens = TweenLiteInternals.lazyTweens,                                                                        // 634
			_lazyRender = TweenLiteInternals.lazyRender,                                                                        // 635
			_blankArray = [],                                                                                                   // 636
			_globals = _gsScope._gsDefine.globals,                                                                              // 637
			_copy = function(vars) {                                                                                            // 638
				var copy = {}, p;                                                                                                  // 639
				for (p in vars) {                                                                                                  // 640
					copy[p] = vars[p];                                                                                                // 641
				}                                                                                                                  // 642
				return copy;                                                                                                       // 643
			},                                                                                                                  // 644
			_pauseCallback = _internals.pauseCallback = function(tween, callback, params, scope) {                              // 645
				var tl = tween._timeline,                                                                                          // 646
					time = tl._totalTime,                                                                                             // 647
					startTime = tween._startTime,                                                                                     // 648
					next = tween.ratio ? _tinyNum : 0,                                                                                // 649
					prev = tween.ratio ? 0 : _tinyNum,                                                                                // 650
					sibling;                                                                                                          // 651
				if (callback || !this._forcingPlayhead) { //if the user calls a method that moves the playhead (like progress() or time()), it should honor that and skip any pauses (although if there's a callback positioned at that pause, it must jump there and make the call to ensure the time is EXACTLY what it is supposed to be, and then proceed to where the playhead is being forced). Otherwise, imagine placing a pause in the middle of a timeline and then doing timeline.progress(0.9) - it would get stuck where the pause is.
					tl.pause(startTime);                                                                                              // 653
					//now find sibling tweens that are EXACTLY at the same spot on the timeline and adjust the _rawPrevTime so that they fire (or don't fire) correctly on the next render. This is primarily to accommodate zero-duration tweens/callbacks that are positioned right on top of a pause. For example, tl.to(...).call(...).addPause(...).call(...) - notice that there's a call() on each side of the pause, so when it's running forward it should call the first one and then pause, and then when resumed, call the other. Zero-duration tweens use _rawPrevTime to sense momentum figure out if events were suppressed when arriving directly on top of that time.
					sibling = tween._prev;                                                                                            // 655
					while (sibling && sibling._startTime === startTime) {                                                             // 656
						sibling._rawPrevTime = prev;                                                                                     // 657
						sibling = sibling._prev;                                                                                         // 658
					}                                                                                                                 // 659
					sibling = tween._next;                                                                                            // 660
					while (sibling && sibling._startTime === startTime) {                                                             // 661
						sibling._rawPrevTime = next;                                                                                     // 662
						sibling = sibling._next;                                                                                         // 663
					}                                                                                                                 // 664
					if (callback) {                                                                                                   // 665
						callback.apply(scope || tl, params || _blankArray);                                                              // 666
					}                                                                                                                 // 667
					if (this._forcingPlayhead) {                                                                                      // 668
						tl.seek(time);                                                                                                   // 669
					}                                                                                                                 // 670
				}                                                                                                                  // 671
			},                                                                                                                  // 672
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],                                                                                                        // 674
					l = a.length,                                                                                                     // 675
					i;                                                                                                                // 676
				for (i = 0; i !== l; b.push(a[i++]));                                                                              // 677
				return b;                                                                                                          // 678
			},                                                                                                                  // 679
			p = TimelineLite.prototype = new SimpleTimeline();                                                                  // 680
                                                                                                                       // 681
		TimelineLite.version = "1.16.0";                                                                                     // 682
		p.constructor = TimelineLite;                                                                                        // 683
		p.kill()._gc = p._forcingPlayhead = false;                                                                           // 684
                                                                                                                       // 685
		/* might use later...                                                                                                // 686
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {                                                                            // 688
			while (animation) {                                                                                                 // 689
				time = (time / animation._timeScale) + animation._startTime;                                                       // 690
				animation = animation.timeline;                                                                                    // 691
			}                                                                                                                   // 692
			return time;                                                                                                        // 693
		}                                                                                                                    // 694
                                                                                                                       // 695
		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {                                                                            // 697
			var scale = 1;                                                                                                      // 698
			time -= localToGlobal(0, animation);                                                                                // 699
			while (animation) {                                                                                                 // 700
				scale *= animation._timeScale;                                                                                     // 701
				animation = animation.timeline;                                                                                    // 702
			}                                                                                                                   // 703
			return time * scale;                                                                                                // 704
		}                                                                                                                    // 705
		*/                                                                                                                   // 706
                                                                                                                       // 707
		p.to = function(target, duration, vars, position) {                                                                  // 708
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;                                                       // 709
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);       // 710
		};                                                                                                                   // 711
                                                                                                                       // 712
		p.from = function(target, duration, vars, position) {                                                                // 713
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);         // 714
		};                                                                                                                   // 715
                                                                                                                       // 716
		p.fromTo = function(target, duration, fromVars, toVars, position) {                                                  // 717
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;                                                     // 718
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};                                                                                                                   // 720
                                                                                                                       // 721
		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, onCompleteScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				i;                                                                                                                 // 724
			if (typeof(targets) === "string") {                                                                                 // 725
				targets = TweenLite.selector(targets) || targets;                                                                  // 726
			}                                                                                                                   // 727
			targets = targets || [];                                                                                            // 728
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);                                                                                         // 730
			}                                                                                                                   // 731
			stagger = stagger || 0;                                                                                             // 732
			if (stagger < 0) {                                                                                                  // 733
				targets = _slice(targets);                                                                                         // 734
				targets.reverse();                                                                                                 // 735
				stagger *= -1;                                                                                                     // 736
			}                                                                                                                   // 737
			for (i = 0; i < targets.length; i++) {                                                                              // 738
				if (vars.startAt) {                                                                                                // 739
					vars.startAt = _copy(vars.startAt);                                                                               // 740
				}                                                                                                                  // 741
				tl.to(targets[i], duration, _copy(vars), i * stagger);                                                             // 742
			}                                                                                                                   // 743
			return this.add(tl, position);                                                                                      // 744
		};                                                                                                                   // 745
                                                                                                                       // 746
		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);                                                             // 748
			vars.runBackwards = true;                                                                                           // 749
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};                                                                                                                   // 751
                                                                                                                       // 752
		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;                                                                                          // 754
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);                    // 755
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};                                                                                                                   // 757
                                                                                                                       // 758
		p.call = function(callback, params, scope, position) {                                                               // 759
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);                                      // 760
		};                                                                                                                   // 761
                                                                                                                       // 762
		p.set = function(target, vars, position) {                                                                           // 763
			position = this._parseTimeOrLabel(position, 0, true);                                                               // 764
			if (vars.immediateRender == null) {                                                                                 // 765
				vars.immediateRender = (position === this._time && !this._paused);                                                 // 766
			}                                                                                                                   // 767
			return this.add( new TweenLite(target, 0, vars), position);                                                         // 768
		};                                                                                                                   // 769
                                                                                                                       // 770
		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {                                                       // 771
			vars = vars || {};                                                                                                  // 772
			if (vars.smoothChildTiming == null) {                                                                               // 773
				vars.smoothChildTiming = true;                                                                                     // 774
			}                                                                                                                   // 775
			var tl = new TimelineLite(vars),                                                                                    // 776
				root = tl._timeline,                                                                                               // 777
				tween, next;                                                                                                       // 778
			if (ignoreDelayedCalls == null) {                                                                                   // 779
				ignoreDelayedCalls = true;                                                                                         // 780
			}                                                                                                                   // 781
			root._remove(tl, true);                                                                                             // 782
			tl._startTime = 0;                                                                                                  // 783
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;                                                            // 784
			tween = root._first;                                                                                                // 785
			while (tween) {                                                                                                     // 786
				next = tween._next;                                                                                                // 787
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {              // 788
					tl.add(tween, tween._startTime - tween._delay);                                                                   // 789
				}                                                                                                                  // 790
				tween = next;                                                                                                      // 791
			}                                                                                                                   // 792
			root.add(tl, 0);                                                                                                    // 793
			return tl;                                                                                                          // 794
		};                                                                                                                   // 795
                                                                                                                       // 796
		p.add = function(value, position, align, stagger) {                                                                  // 797
			var curTime, l, i, child, tl, beforeRawTime;                                                                        // 798
			if (typeof(position) !== "number") {                                                                                // 799
				position = this._parseTimeOrLabel(position, 0, true, value);                                                       // 800
			}                                                                                                                   // 801
			if (!(value instanceof Animation)) {                                                                                // 802
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {                                        // 803
					align = align || "normal";                                                                                        // 804
					stagger = stagger || 0;                                                                                           // 805
					curTime = position;                                                                                               // 806
					l = value.length;                                                                                                 // 807
					for (i = 0; i < l; i++) {                                                                                         // 808
						if (_isArray(child = value[i])) {                                                                                // 809
							child = new TimelineLite({tweens:child});                                                                       // 810
						}                                                                                                                // 811
						this.add(child, curTime);                                                                                        // 812
						if (typeof(child) !== "string" && typeof(child) !== "function") {                                                // 813
							if (align === "sequence") {                                                                                     // 814
								curTime = child._startTime + (child.totalDuration() / child._timeScale);                                       // 815
							} else if (align === "start") {                                                                                 // 816
								child._startTime -= child.delay();                                                                             // 817
							}                                                                                                               // 818
						}                                                                                                                // 819
						curTime += stagger;                                                                                              // 820
					}                                                                                                                 // 821
					return this._uncache(true);                                                                                       // 822
				} else if (typeof(value) === "string") {                                                                           // 823
					return this.addLabel(value, position);                                                                            // 824
				} else if (typeof(value) === "function") {                                                                         // 825
					value = TweenLite.delayedCall(0, value);                                                                          // 826
				} else {                                                                                                           // 827
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");           // 828
				}                                                                                                                  // 829
			}                                                                                                                   // 830
                                                                                                                       // 831
			SimpleTimeline.prototype.add.call(this, value, position);                                                           // 832
                                                                                                                       // 833
			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {           // 835
				//in case any of the ancestors had completed but should now be enabled...                                          // 836
				tl = this;                                                                                                         // 837
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {                                                                                             // 839
					if (beforeRawTime && tl._timeline.smoothChildTiming) {                                                            // 840
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {                                                                                              // 842
						tl._enabled(true, false);                                                                                        // 843
					}                                                                                                                 // 844
					tl = tl._timeline;                                                                                                // 845
				}                                                                                                                  // 846
			}                                                                                                                   // 847
                                                                                                                       // 848
			return this;                                                                                                        // 849
		};                                                                                                                   // 850
                                                                                                                       // 851
		p.remove = function(value) {                                                                                         // 852
			if (value instanceof Animation) {                                                                                   // 853
				return this._remove(value, false);                                                                                 // 854
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {                                    // 855
				var i = value.length;                                                                                              // 856
				while (--i > -1) {                                                                                                 // 857
					this.remove(value[i]);                                                                                            // 858
				}                                                                                                                  // 859
				return this;                                                                                                       // 860
			} else if (typeof(value) === "string") {                                                                            // 861
				return this.removeLabel(value);                                                                                    // 862
			}                                                                                                                   // 863
			return this.kill(null, value);                                                                                      // 864
		};                                                                                                                   // 865
                                                                                                                       // 866
		p._remove = function(tween, skipDisable) {                                                                           // 867
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);                                                    // 868
			var last = this._last;                                                                                              // 869
			if (!last) {                                                                                                        // 870
				this._time = this._totalTime = this._duration = this._totalDuration = 0;                                           // 871
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {                                  // 872
				this._time = this.duration();                                                                                      // 873
				this._totalTime = this._totalDuration;                                                                             // 874
			}                                                                                                                   // 875
			return this;                                                                                                        // 876
		};                                                                                                                   // 877
                                                                                                                       // 878
		p.append = function(value, offsetOrLabel) {                                                                          // 879
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));                                   // 880
		};                                                                                                                   // 881
                                                                                                                       // 882
		p.insert = p.insertMultiple = function(value, position, align, stagger) {                                            // 883
			return this.add(value, position || 0, align, stagger);                                                              // 884
		};                                                                                                                   // 885
                                                                                                                       // 886
		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {                                                 // 887
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);                 // 888
		};                                                                                                                   // 889
                                                                                                                       // 890
		p.addLabel = function(label, position) {                                                                             // 891
			this._labels[label] = this._parseTimeOrLabel(position);                                                             // 892
			return this;                                                                                                        // 893
		};                                                                                                                   // 894
                                                                                                                       // 895
		p.addPause = function(position, callback, params, scope) {                                                           // 896
			var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this);                        // 897
			t.data = "isPause"; // we use this flag in TweenLite's render() method to identify it as a special case that shouldn't be triggered when the virtual playhead is LEAVING the exact position where the pause is, otherwise timeline.addPause(1).play(1) would end up paused on the very next tick.
			return this.add(t, position);                                                                                       // 899
		};                                                                                                                   // 900
                                                                                                                       // 901
		p.removeLabel = function(label) {                                                                                    // 902
			delete this._labels[label];                                                                                         // 903
			return this;                                                                                                        // 904
		};                                                                                                                   // 905
                                                                                                                       // 906
		p.getLabelTime = function(label) {                                                                                   // 907
			return (this._labels[label] != null) ? this._labels[label] : -1;                                                    // 908
		};                                                                                                                   // 909
                                                                                                                       // 910
		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {                                 // 911
			var i;                                                                                                              // 912
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {                                                      // 914
				this.remove(ignore);                                                                                               // 915
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {                            // 916
				i = ignore.length;                                                                                                 // 917
				while (--i > -1) {                                                                                                 // 918
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {                                              // 919
						this.remove(ignore[i]);                                                                                          // 920
					}                                                                                                                 // 921
				}                                                                                                                  // 922
			}                                                                                                                   // 923
			if (typeof(offsetOrLabel) === "string") {                                                                           // 924
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}                                                                                                                   // 926
			offsetOrLabel = offsetOrLabel || 0;                                                                                 // 927
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");                                                                                      // 929
				if (i === -1) {                                                                                                    // 930
					if (this._labels[timeOrLabel] == null) {                                                                          // 931
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;           // 932
					}                                                                                                                 // 933
					return this._labels[timeOrLabel] + offsetOrLabel;                                                                 // 934
				}                                                                                                                  // 935
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));                     // 936
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();   // 937
			} else if (timeOrLabel == null) {                                                                                   // 938
				timeOrLabel = this.duration();                                                                                     // 939
			}                                                                                                                   // 940
			return Number(timeOrLabel) + offsetOrLabel;                                                                         // 941
		};                                                                                                                   // 942
                                                                                                                       // 943
		p.seek = function(position, suppressEvents) {                                                                        // 944
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};                                                                                                                   // 946
                                                                                                                       // 947
		p.stop = function() {                                                                                                // 948
			return this.paused(true);                                                                                           // 949
		};                                                                                                                   // 950
                                                                                                                       // 951
		p.gotoAndPlay = function(position, suppressEvents) {                                                                 // 952
			return this.play(position, suppressEvents);                                                                         // 953
		};                                                                                                                   // 954
                                                                                                                       // 955
		p.gotoAndStop = function(position, suppressEvents) {                                                                 // 956
			return this.pause(position, suppressEvents);                                                                        // 957
		};                                                                                                                   // 958
                                                                                                                       // 959
		p.render = function(time, suppressEvents, force) {                                                                   // 960
			if (this._gc) {                                                                                                     // 961
				this._enabled(true, false);                                                                                        // 962
			}                                                                                                                   // 963
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),                                         // 964
				prevTime = this._time,                                                                                             // 965
				prevStart = this._startTime,                                                                                       // 966
				prevTimeScale = this._timeScale,                                                                                   // 967
				prevPaused = this._paused,                                                                                         // 968
				tween, isComplete, next, callback, internalForce;                                                                  // 969
			if (time >= totalDur) {                                                                                             // 970
				this._totalTime = this._time = totalDur;                                                                           // 971
				if (!this._reversed) if (!this._hasPausedChild()) {                                                                // 972
					isComplete = true;                                                                                                // 973
					callback = "onComplete";                                                                                          // 974
					if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;                                                                                            // 976
						if (this._rawPrevTime > _tinyNum) {                                                                              // 977
							callback = "onReverseComplete";                                                                                 // 978
						}                                                                                                                // 979
					}                                                                                                                 // 980
				}                                                                                                                  // 981
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.
                                                                                                                       // 984
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;                                                                                  // 986
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";                                                                                   // 988
					isComplete = this._reversed;                                                                                      // 989
				}                                                                                                                  // 990
				if (time < 0) {                                                                                                    // 991
					this._active = false;                                                                                             // 992
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;                                                                               // 994
						callback = "onReverseComplete";                                                                                  // 995
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;                                                                                            // 997
					}                                                                                                                 // 998
					this._rawPrevTime = time;                                                                                         // 999
				} else {                                                                                                           // 1000
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;                                                                                             // 1003
						while (tween && tween._startTime === 0) {                                                                        // 1004
							if (!tween._duration) {                                                                                         // 1005
								isComplete = false;                                                                                            // 1006
							}                                                                                                               // 1007
							tween = tween._next;                                                                                            // 1008
						}                                                                                                                // 1009
					}                                                                                                                 // 1010
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {                                                                                             // 1012
						internalForce = true;                                                                                            // 1013
					}                                                                                                                 // 1014
				}                                                                                                                  // 1015
                                                                                                                       // 1016
			} else {                                                                                                            // 1017
				this._totalTime = this._time = this._rawPrevTime = time;                                                           // 1018
			}                                                                                                                   // 1019
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {                                        // 1020
				return;                                                                                                            // 1021
			} else if (!this._initted) {                                                                                        // 1022
				this._initted = true;                                                                                              // 1023
			}                                                                                                                   // 1024
                                                                                                                       // 1025
			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {                                      // 1026
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}                                                                                                                   // 1028
                                                                                                                       // 1029
			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {                             // 1030
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);                   // 1031
			}                                                                                                                   // 1032
                                                                                                                       // 1033
			if (this._time >= prevTime) {                                                                                       // 1034
				tween = this._first;                                                                                               // 1035
				while (tween) {                                                                                                    // 1036
					next = tween._next; //record it here because the value could change after rendering...                            // 1037
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering                           // 1038
						break;                                                                                                           // 1039
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {                   // 1040
						if (!tween._reversed) {                                                                                          // 1041
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);                              // 1042
						} else {                                                                                                         // 1043
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}                                                                                                                // 1045
					}                                                                                                                 // 1046
					tween = next;                                                                                                     // 1047
				}                                                                                                                  // 1048
			} else {                                                                                                            // 1049
				tween = this._last;                                                                                                // 1050
				while (tween) {                                                                                                    // 1051
					next = tween._prev; //record it here because the value could change after rendering...                            // 1052
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering                           // 1053
						break;                                                                                                           // 1054
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {                     // 1055
						if (!tween._reversed) {                                                                                          // 1056
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);                              // 1057
						} else {                                                                                                         // 1058
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}                                                                                                                // 1060
					}                                                                                                                 // 1061
					tween = next;                                                                                                     // 1062
				}                                                                                                                  // 1063
			}                                                                                                                   // 1064
                                                                                                                       // 1065
			if (this._onUpdate) if (!suppressEvents) {                                                                          // 1066
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();                                                                                                    // 1068
				}                                                                                                                  // 1069
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);                    // 1070
			}                                                                                                                   // 1071
                                                                                                                       // 1072
			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {                                                                                                  // 1074
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();                                                                                                   // 1076
					}                                                                                                                 // 1077
					if (this._timeline.autoRemoveChildren) {                                                                          // 1078
						this._enabled(false, false);                                                                                     // 1079
					}                                                                                                                 // 1080
					this._active = false;                                                                                             // 1081
				}                                                                                                                  // 1082
				if (!suppressEvents && this.vars[callback]) {                                                                      // 1083
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);  // 1084
				}                                                                                                                  // 1085
			}                                                                                                                   // 1086
		};                                                                                                                   // 1087
                                                                                                                       // 1088
		p._hasPausedChild = function() {                                                                                     // 1089
			var tween = this._first;                                                                                            // 1090
			while (tween) {                                                                                                     // 1091
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {                               // 1092
					return true;                                                                                                      // 1093
				}                                                                                                                  // 1094
				tween = tween._next;                                                                                               // 1095
			}                                                                                                                   // 1096
			return false;                                                                                                       // 1097
		};                                                                                                                   // 1098
                                                                                                                       // 1099
		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {                                              // 1100
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;                                                                 // 1101
			var a = [],                                                                                                         // 1102
				tween = this._first,                                                                                               // 1103
				cnt = 0;                                                                                                           // 1104
			while (tween) {                                                                                                     // 1105
				if (tween._startTime < ignoreBeforeTime) {                                                                         // 1106
					//do nothing                                                                                                      // 1107
				} else if (tween instanceof TweenLite) {                                                                           // 1108
					if (tweens !== false) {                                                                                           // 1109
						a[cnt++] = tween;                                                                                                // 1110
					}                                                                                                                 // 1111
				} else {                                                                                                           // 1112
					if (timelines !== false) {                                                                                        // 1113
						a[cnt++] = tween;                                                                                                // 1114
					}                                                                                                                 // 1115
					if (nested !== false) {                                                                                           // 1116
						a = a.concat(tween.getChildren(true, tweens, timelines));                                                        // 1117
						cnt = a.length;                                                                                                  // 1118
					}                                                                                                                 // 1119
				}                                                                                                                  // 1120
				tween = tween._next;                                                                                               // 1121
			}                                                                                                                   // 1122
			return a;                                                                                                           // 1123
		};                                                                                                                   // 1124
                                                                                                                       // 1125
		p.getTweensOf = function(target, nested) {                                                                           // 1126
			var disabled = this._gc,                                                                                            // 1127
				a = [],                                                                                                            // 1128
				cnt = 0,                                                                                                           // 1129
				tweens, i;                                                                                                         // 1130
			if (disabled) {                                                                                                     // 1131
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}                                                                                                                   // 1133
			tweens = TweenLite.getTweensOf(target);                                                                             // 1134
			i = tweens.length;                                                                                                  // 1135
			while (--i > -1) {                                                                                                  // 1136
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {                                        // 1137
					a[cnt++] = tweens[i];                                                                                             // 1138
				}                                                                                                                  // 1139
			}                                                                                                                   // 1140
			if (disabled) {                                                                                                     // 1141
				this._enabled(false, true);                                                                                        // 1142
			}                                                                                                                   // 1143
			return a;                                                                                                           // 1144
		};                                                                                                                   // 1145
                                                                                                                       // 1146
		p.recent = function() {                                                                                              // 1147
			return this._recent;                                                                                                // 1148
		};                                                                                                                   // 1149
                                                                                                                       // 1150
		p._contains = function(tween) {                                                                                      // 1151
			var tl = tween.timeline;                                                                                            // 1152
			while (tl) {                                                                                                        // 1153
				if (tl === this) {                                                                                                 // 1154
					return true;                                                                                                      // 1155
				}                                                                                                                  // 1156
				tl = tl.timeline;                                                                                                  // 1157
			}                                                                                                                   // 1158
			return false;                                                                                                       // 1159
		};                                                                                                                   // 1160
                                                                                                                       // 1161
		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {                                                 // 1162
			ignoreBeforeTime = ignoreBeforeTime || 0;                                                                           // 1163
			var tween = this._first,                                                                                            // 1164
				labels = this._labels,                                                                                             // 1165
				p;                                                                                                                 // 1166
			while (tween) {                                                                                                     // 1167
				if (tween._startTime >= ignoreBeforeTime) {                                                                        // 1168
					tween._startTime += amount;                                                                                       // 1169
				}                                                                                                                  // 1170
				tween = tween._next;                                                                                               // 1171
			}                                                                                                                   // 1172
			if (adjustLabels) {                                                                                                 // 1173
				for (p in labels) {                                                                                                // 1174
					if (labels[p] >= ignoreBeforeTime) {                                                                              // 1175
						labels[p] += amount;                                                                                             // 1176
					}                                                                                                                 // 1177
				}                                                                                                                  // 1178
			}                                                                                                                   // 1179
			return this._uncache(true);                                                                                         // 1180
		};                                                                                                                   // 1181
                                                                                                                       // 1182
		p._kill = function(vars, target) {                                                                                   // 1183
			if (!vars && !target) {                                                                                             // 1184
				return this._enabled(false, false);                                                                                // 1185
			}                                                                                                                   // 1186
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),                            // 1187
				i = tweens.length,                                                                                                 // 1188
				changed = false;                                                                                                   // 1189
			while (--i > -1) {                                                                                                  // 1190
				if (tweens[i]._kill(vars, target)) {                                                                               // 1191
					changed = true;                                                                                                   // 1192
				}                                                                                                                  // 1193
			}                                                                                                                   // 1194
			return changed;                                                                                                     // 1195
		};                                                                                                                   // 1196
                                                                                                                       // 1197
		p.clear = function(labels) {                                                                                         // 1198
			var tweens = this.getChildren(false, true, true),                                                                   // 1199
				i = tweens.length;                                                                                                 // 1200
			this._time = this._totalTime = 0;                                                                                   // 1201
			while (--i > -1) {                                                                                                  // 1202
				tweens[i]._enabled(false, false);                                                                                  // 1203
			}                                                                                                                   // 1204
			if (labels !== false) {                                                                                             // 1205
				this._labels = {};                                                                                                 // 1206
			}                                                                                                                   // 1207
			return this._uncache(true);                                                                                         // 1208
		};                                                                                                                   // 1209
                                                                                                                       // 1210
		p.invalidate = function() {                                                                                          // 1211
			var tween = this._first;                                                                                            // 1212
			while (tween) {                                                                                                     // 1213
				tween.invalidate();                                                                                                // 1214
				tween = tween._next;                                                                                               // 1215
			}                                                                                                                   // 1216
			return Animation.prototype.invalidate.call(this);;                                                                  // 1217
		};                                                                                                                   // 1218
                                                                                                                       // 1219
		p._enabled = function(enabled, ignoreTimeline) {                                                                     // 1220
			if (enabled === this._gc) {                                                                                         // 1221
				var tween = this._first;                                                                                           // 1222
				while (tween) {                                                                                                    // 1223
					tween._enabled(enabled, true);                                                                                    // 1224
					tween = tween._next;                                                                                              // 1225
				}                                                                                                                  // 1226
			}                                                                                                                   // 1227
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);                                       // 1228
		};                                                                                                                   // 1229
                                                                                                                       // 1230
		p.totalTime = function(time, suppressEvents, uncapped) {                                                             // 1231
			this._forcingPlayhead = true;                                                                                       // 1232
			var val = Animation.prototype.totalTime.apply(this, arguments);                                                     // 1233
			this._forcingPlayhead = false;                                                                                      // 1234
			return val;                                                                                                         // 1235
		};                                                                                                                   // 1236
                                                                                                                       // 1237
		p.duration = function(value) {                                                                                       // 1238
			if (!arguments.length) {                                                                                            // 1239
				if (this._dirty) {                                                                                                 // 1240
					this.totalDuration(); //just triggers recalculation                                                               // 1241
				}                                                                                                                  // 1242
				return this._duration;                                                                                             // 1243
			}                                                                                                                   // 1244
			if (this.duration() !== 0 && value !== 0) {                                                                         // 1245
				this.timeScale(this._duration / value);                                                                            // 1246
			}                                                                                                                   // 1247
			return this;                                                                                                        // 1248
		};                                                                                                                   // 1249
                                                                                                                       // 1250
		p.totalDuration = function(value) {                                                                                  // 1251
			if (!arguments.length) {                                                                                            // 1252
				if (this._dirty) {                                                                                                 // 1253
					var max = 0,                                                                                                      // 1254
						tween = this._last,                                                                                              // 1255
						prevStart = 999999999999,                                                                                        // 1256
						prev, end;                                                                                                       // 1257
					while (tween) {                                                                                                   // 1258
						prev = tween._prev; //record it here in case the tween changes position in the sequence...                       // 1259
						if (tween._dirty) {                                                                                              // 1260
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}                                                                                                                // 1262
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);                                                               // 1264
						} else {                                                                                                         // 1265
							prevStart = tween._startTime;                                                                                   // 1266
						}                                                                                                                // 1267
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;                                                                                        // 1269
							if (this._timeline.smoothChildTiming) {                                                                         // 1270
								this._startTime += tween._startTime / this._timeScale;                                                         // 1271
							}                                                                                                               // 1272
							this.shiftChildren(-tween._startTime, false, -9999999999);                                                      // 1273
							prevStart = 0;                                                                                                  // 1274
						}                                                                                                                // 1275
						end = tween._startTime + (tween._totalDuration / tween._timeScale);                                              // 1276
						if (end > max) {                                                                                                 // 1277
							max = end;                                                                                                      // 1278
						}                                                                                                                // 1279
						tween = prev;                                                                                                    // 1280
					}                                                                                                                 // 1281
					this._duration = this._totalDuration = max;                                                                       // 1282
					this._dirty = false;                                                                                              // 1283
				}                                                                                                                  // 1284
				return this._totalDuration;                                                                                        // 1285
			}                                                                                                                   // 1286
			if (this.totalDuration() !== 0) if (value !== 0) {                                                                  // 1287
				this.timeScale(this._totalDuration / value);                                                                       // 1288
			}                                                                                                                   // 1289
			return this;                                                                                                        // 1290
		};                                                                                                                   // 1291
                                                                                                                       // 1292
		p.paused = function(value) {                                                                                         // 1293
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.                        // 1294
				var tween = this._first,                                                                                           // 1295
					time = this._time;                                                                                                // 1296
				while (tween) {                                                                                                    // 1297
					if (tween._startTime === time && tween.data === "isPause") {                                                      // 1298
						tween._rawPrevTime = time; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}                                                                                                                 // 1300
					tween = tween._next;                                                                                              // 1301
				}                                                                                                                  // 1302
			}                                                                                                                   // 1303
			return Animation.prototype.paused.apply(this, arguments);                                                           // 1304
		};                                                                                                                   // 1305
                                                                                                                       // 1306
		p.usesFrames = function() {                                                                                          // 1307
			var tl = this._timeline;                                                                                            // 1308
			while (tl._timeline) {                                                                                              // 1309
				tl = tl._timeline;                                                                                                 // 1310
			}                                                                                                                   // 1311
			return (tl === Animation._rootFramesTimeline);                                                                      // 1312
		};                                                                                                                   // 1313
                                                                                                                       // 1314
		p.rawTime = function() {                                                                                             // 1315
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;             // 1316
		};                                                                                                                   // 1317
                                                                                                                       // 1318
		return TimelineLite;                                                                                                 // 1319
                                                                                                                       // 1320
	}, true);                                                                                                             // 1321
	                                                                                                                      // 1322
                                                                                                                       // 1323
                                                                                                                       // 1324
                                                                                                                       // 1325
                                                                                                                       // 1326
                                                                                                                       // 1327
                                                                                                                       // 1328
                                                                                                                       // 1329
	                                                                                                                      // 1330
	                                                                                                                      // 1331
	                                                                                                                      // 1332
	                                                                                                                      // 1333
	                                                                                                                      // 1334
/*                                                                                                                     // 1335
 * ----------------------------------------------------------------                                                    // 1336
 * TimelineMax                                                                                                         // 1337
 * ----------------------------------------------------------------                                                    // 1338
 */                                                                                                                    // 1339
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {
                                                                                                                       // 1341
		var TimelineMax = function(vars) {                                                                                   // 1342
				TimelineLite.call(this, vars);                                                                                     // 1343
				this._repeat = this.vars.repeat || 0;                                                                              // 1344
				this._repeatDelay = this.vars.repeatDelay || 0;                                                                    // 1345
				this._cycle = 0;                                                                                                   // 1346
				this._yoyo = (this.vars.yoyo === true);                                                                            // 1347
				this._dirty = true;                                                                                                // 1348
			},                                                                                                                  // 1349
			_tinyNum = 0.0000000001,                                                                                            // 1350
			_blankArray = [],                                                                                                   // 1351
			TweenLiteInternals = TweenLite._internals,                                                                          // 1352
			_lazyTweens = TweenLiteInternals.lazyTweens,                                                                        // 1353
			_lazyRender = TweenLiteInternals.lazyRender,                                                                        // 1354
			_easeNone = new Ease(null, null, 1, 0),                                                                             // 1355
			p = TimelineMax.prototype = new TimelineLite();                                                                     // 1356
                                                                                                                       // 1357
		p.constructor = TimelineMax;                                                                                         // 1358
		p.kill()._gc = false;                                                                                                // 1359
		TimelineMax.version = "1.16.0";                                                                                      // 1360
                                                                                                                       // 1361
		p.invalidate = function() {                                                                                          // 1362
			this._yoyo = (this.vars.yoyo === true);                                                                             // 1363
			this._repeat = this.vars.repeat || 0;                                                                               // 1364
			this._repeatDelay = this.vars.repeatDelay || 0;                                                                     // 1365
			this._uncache(true);                                                                                                // 1366
			return TimelineLite.prototype.invalidate.call(this);                                                                // 1367
		};                                                                                                                   // 1368
                                                                                                                       // 1369
		p.addCallback = function(callback, position, params, scope) {                                                        // 1370
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);                                      // 1371
		};                                                                                                                   // 1372
                                                                                                                       // 1373
		p.removeCallback = function(callback, position) {                                                                    // 1374
			if (callback) {                                                                                                     // 1375
				if (position == null) {                                                                                            // 1376
					this._kill(null, callback);                                                                                       // 1377
				} else {                                                                                                           // 1378
					var a = this.getTweensOf(callback, false),                                                                        // 1379
						i = a.length,                                                                                                    // 1380
						time = this._parseTimeOrLabel(position);                                                                         // 1381
					while (--i > -1) {                                                                                                // 1382
						if (a[i]._startTime === time) {                                                                                  // 1383
							a[i]._enabled(false, false);                                                                                    // 1384
						}                                                                                                                // 1385
					}                                                                                                                 // 1386
				}                                                                                                                  // 1387
			}                                                                                                                   // 1388
			return this;                                                                                                        // 1389
		};                                                                                                                   // 1390
                                                                                                                       // 1391
		p.removePause = function(position) {                                                                                 // 1392
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);                                        // 1393
		};                                                                                                                   // 1394
                                                                                                                       // 1395
		p.tweenTo = function(position, vars) {                                                                               // 1396
			vars = vars || {};                                                                                                  // 1397
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},                                    // 1398
				duration, p, t;                                                                                                    // 1399
			for (p in vars) {                                                                                                   // 1400
				copy[p] = vars[p];                                                                                                 // 1401
			}                                                                                                                   // 1402
			copy.time = this._parseTimeOrLabel(position);                                                                       // 1403
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;                                   // 1404
			t = new TweenLite(this, duration, copy);                                                                            // 1405
			copy.onStart = function() {                                                                                         // 1406
				t.target.paused(true);                                                                                             // 1407
				if (t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );                                     // 1409
				}                                                                                                                  // 1410
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.                 // 1411
					vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray);                                    // 1412
				}                                                                                                                  // 1413
			};                                                                                                                  // 1414
			return t;                                                                                                           // 1415
		};                                                                                                                   // 1416
                                                                                                                       // 1417
		p.tweenFromTo = function(fromPosition, toPosition, vars) {                                                           // 1418
			vars = vars || {};                                                                                                  // 1419
			fromPosition = this._parseTimeOrLabel(fromPosition);                                                                // 1420
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], onCompleteScope:this};                       // 1421
			vars.immediateRender = (vars.immediateRender !== false);                                                            // 1422
			var t = this.tweenTo(toPosition, vars);                                                                             // 1423
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);                              // 1424
		};                                                                                                                   // 1425
                                                                                                                       // 1426
		p.render = function(time, suppressEvents, force) {                                                                   // 1427
			if (this._gc) {                                                                                                     // 1428
				this._enabled(true, false);                                                                                        // 1429
			}                                                                                                                   // 1430
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),                                         // 1431
				dur = this._duration,                                                                                              // 1432
				prevTime = this._time,                                                                                             // 1433
				prevTotalTime = this._totalTime,                                                                                   // 1434
				prevStart = this._startTime,                                                                                       // 1435
				prevTimeScale = this._timeScale,                                                                                   // 1436
				prevRawPrevTime = this._rawPrevTime,                                                                               // 1437
				prevPaused = this._paused,                                                                                         // 1438
				prevCycle = this._cycle,                                                                                           // 1439
				tween, isComplete, next, callback, internalForce, cycleDuration;                                                   // 1440
			if (time >= totalDur) {                                                                                             // 1441
				if (!this._locked) {                                                                                               // 1442
					this._totalTime = totalDur;                                                                                       // 1443
					this._cycle = this._repeat;                                                                                       // 1444
				}                                                                                                                  // 1445
				if (!this._reversed) if (!this._hasPausedChild()) {                                                                // 1446
					isComplete = true;                                                                                                // 1447
					callback = "onComplete";                                                                                          // 1448
					if (this._duration === 0) if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;                                                                                            // 1450
						if (prevRawPrevTime > _tinyNum) {                                                                                // 1451
							callback = "onReverseComplete";                                                                                 // 1452
						}                                                                                                                // 1453
					}                                                                                                                 // 1454
				}                                                                                                                  // 1455
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {                                                                       // 1457
					this._time = time = 0;                                                                                            // 1458
				} else {                                                                                                           // 1459
					this._time = dur;                                                                                                 // 1460
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}                                                                                                                  // 1462
                                                                                                                       // 1463
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {                                                                                               // 1465
					this._totalTime = this._cycle = 0;                                                                                // 1466
				}                                                                                                                  // 1467
				this._time = 0;                                                                                                    // 1468
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";                                                                                   // 1470
					isComplete = this._reversed;                                                                                      // 1471
				}                                                                                                                  // 1472
				if (time < 0) {                                                                                                    // 1473
					this._active = false;                                                                                             // 1474
					if (this._timeline.autoRemoveChildren && this._reversed) {                                                        // 1475
						internalForce = isComplete = true;                                                                               // 1476
						callback = "onReverseComplete";                                                                                  // 1477
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;                                                                                            // 1479
					}                                                                                                                 // 1480
					this._rawPrevTime = time;                                                                                         // 1481
				} else {                                                                                                           // 1482
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;                                                                                             // 1485
						while (tween && tween._startTime === 0) {                                                                        // 1486
							if (!tween._duration) {                                                                                         // 1487
								isComplete = false;                                                                                            // 1488
							}                                                                                                               // 1489
							tween = tween._next;                                                                                            // 1490
						}                                                                                                                // 1491
					}                                                                                                                 // 1492
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {                                                                                             // 1494
						internalForce = true;                                                                                            // 1495
					}                                                                                                                 // 1496
				}                                                                                                                  // 1497
                                                                                                                       // 1498
			} else {                                                                                                            // 1499
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;                                                                                             // 1501
				}                                                                                                                  // 1502
				this._time = this._rawPrevTime = time;                                                                             // 1503
				if (!this._locked) {                                                                                               // 1504
					this._totalTime = time;                                                                                           // 1505
					if (this._repeat !== 0) {                                                                                         // 1506
						cycleDuration = dur + this._repeatDelay;                                                                         // 1507
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {                                    // 1509
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}                                                                                                                // 1511
						this._time = this._totalTime - (this._cycle * cycleDuration);                                                    // 1512
						if (this._yoyo) if ((this._cycle & 1) !== 0) {                                                                   // 1513
							this._time = dur - this._time;                                                                                  // 1514
						}                                                                                                                // 1515
						if (this._time > dur) {                                                                                          // 1516
							this._time = dur;                                                                                               // 1517
							time = dur + 0.0001; //to avoid occasional floating point rounding error                                        // 1518
						} else if (this._time < 0) {                                                                                     // 1519
							this._time = time = 0;                                                                                          // 1520
						} else {                                                                                                         // 1521
							time = this._time;                                                                                              // 1522
						}                                                                                                                // 1523
					}                                                                                                                 // 1524
				}                                                                                                                  // 1525
			}                                                                                                                   // 1526
                                                                                                                       // 1527
			if (this._cycle !== prevCycle) if (!this._locked) {                                                                 // 1528
				/*                                                                                                                 // 1529
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,                    // 1530
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which                 // 1531
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there                 // 1532
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So                      // 1533
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must               // 1534
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.                             // 1535
				*/                                                                                                                 // 1536
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),                                                             // 1537
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),                                                   // 1538
					recTotalTime = this._totalTime,                                                                                   // 1539
					recCycle = this._cycle,                                                                                           // 1540
					recRawPrevTime = this._rawPrevTime,                                                                               // 1541
					recTime = this._time;                                                                                             // 1542
                                                                                                                       // 1543
				this._totalTime = prevCycle * dur;                                                                                 // 1544
				if (this._cycle < prevCycle) {                                                                                     // 1545
					backwards = !backwards;                                                                                           // 1546
				} else {                                                                                                           // 1547
					this._totalTime += dur;                                                                                           // 1548
				}                                                                                                                  // 1549
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.
                                                                                                                       // 1551
				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;                                      // 1552
				this._cycle = prevCycle;                                                                                           // 1553
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;                                                                                  // 1555
				this.render(prevTime, suppressEvents, (dur === 0));                                                                // 1556
				if (!suppressEvents) if (!this._gc) {                                                                              // 1557
					if (this.vars.onRepeat) {                                                                                         // 1558
						this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);              // 1559
					}                                                                                                                 // 1560
				}                                                                                                                  // 1561
				if (wrap) {                                                                                                        // 1562
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;                                                                  // 1563
					this.render(prevTime, true, false);                                                                               // 1564
				}                                                                                                                  // 1565
				this._locked = false;                                                                                              // 1566
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;                                                                                                           // 1568
				}                                                                                                                  // 1569
				this._time = recTime;                                                                                              // 1570
				this._totalTime = recTotalTime;                                                                                    // 1571
				this._cycle = recCycle;                                                                                            // 1572
				this._rawPrevTime = recRawPrevTime;                                                                                // 1573
			}                                                                                                                   // 1574
                                                                                                                       // 1575
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {                                        // 1576
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);                   // 1578
				}                                                                                                                  // 1579
				return;                                                                                                            // 1580
			} else if (!this._initted) {                                                                                        // 1581
				this._initted = true;                                                                                              // 1582
			}                                                                                                                   // 1583
                                                                                                                       // 1584
			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {                            // 1585
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}                                                                                                                   // 1587
                                                                                                                       // 1588
			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {                   // 1589
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);                   // 1590
			}                                                                                                                   // 1591
                                                                                                                       // 1592
			if (this._time >= prevTime) {                                                                                       // 1593
				tween = this._first;                                                                                               // 1594
				while (tween) {                                                                                                    // 1595
					next = tween._next; //record it here because the value could change after rendering...                            // 1596
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering                           // 1597
						break;                                                                                                           // 1598
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {                   // 1599
						if (!tween._reversed) {                                                                                          // 1600
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);                              // 1601
						} else {                                                                                                         // 1602
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}                                                                                                                // 1604
                                                                                                                       // 1605
					}                                                                                                                 // 1606
					tween = next;                                                                                                     // 1607
				}                                                                                                                  // 1608
			} else {                                                                                                            // 1609
				tween = this._last;                                                                                                // 1610
				while (tween) {                                                                                                    // 1611
					next = tween._prev; //record it here because the value could change after rendering...                            // 1612
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering                           // 1613
						break;                                                                                                           // 1614
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {                     // 1615
						if (!tween._reversed) {                                                                                          // 1616
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);                              // 1617
						} else {                                                                                                         // 1618
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}                                                                                                                // 1620
					}                                                                                                                 // 1621
					tween = next;                                                                                                     // 1622
				}                                                                                                                  // 1623
			}                                                                                                                   // 1624
                                                                                                                       // 1625
			if (this._onUpdate) if (!suppressEvents) {                                                                          // 1626
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();                                                                                                    // 1628
				}                                                                                                                  // 1629
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);                    // 1630
			}                                                                                                                   // 1631
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {                                                                                                  // 1633
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();                                                                                                   // 1635
					}                                                                                                                 // 1636
					if (this._timeline.autoRemoveChildren) {                                                                          // 1637
						this._enabled(false, false);                                                                                     // 1638
					}                                                                                                                 // 1639
					this._active = false;                                                                                             // 1640
				}                                                                                                                  // 1641
				if (!suppressEvents && this.vars[callback]) {                                                                      // 1642
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);  // 1643
				}                                                                                                                  // 1644
			}                                                                                                                   // 1645
		};                                                                                                                   // 1646
                                                                                                                       // 1647
		p.getActive = function(nested, tweens, timelines) {                                                                  // 1648
			if (nested == null) {                                                                                               // 1649
				nested = true;                                                                                                     // 1650
			}                                                                                                                   // 1651
			if (tweens == null) {                                                                                               // 1652
				tweens = true;                                                                                                     // 1653
			}                                                                                                                   // 1654
			if (timelines == null) {                                                                                            // 1655
				timelines = false;                                                                                                 // 1656
			}                                                                                                                   // 1657
			var a = [],                                                                                                         // 1658
				all = this.getChildren(nested, tweens, timelines),                                                                 // 1659
				cnt = 0,                                                                                                           // 1660
				l = all.length,                                                                                                    // 1661
				i, tween;                                                                                                          // 1662
			for (i = 0; i < l; i++) {                                                                                           // 1663
				tween = all[i];                                                                                                    // 1664
				if (tween.isActive()) {                                                                                            // 1665
					a[cnt++] = tween;                                                                                                 // 1666
				}                                                                                                                  // 1667
			}                                                                                                                   // 1668
			return a;                                                                                                           // 1669
		};                                                                                                                   // 1670
                                                                                                                       // 1671
                                                                                                                       // 1672
		p.getLabelAfter = function(time) {                                                                                   // 1673
			if (!time) if (time !== 0) { //faster than isNan()                                                                  // 1674
				time = this._time;                                                                                                 // 1675
			}                                                                                                                   // 1676
			var labels = this.getLabelsArray(),                                                                                 // 1677
				l = labels.length,                                                                                                 // 1678
				i;                                                                                                                 // 1679
			for (i = 0; i < l; i++) {                                                                                           // 1680
				if (labels[i].time > time) {                                                                                       // 1681
					return labels[i].name;                                                                                            // 1682
				}                                                                                                                  // 1683
			}                                                                                                                   // 1684
			return null;                                                                                                        // 1685
		};                                                                                                                   // 1686
                                                                                                                       // 1687
		p.getLabelBefore = function(time) {                                                                                  // 1688
			if (time == null) {                                                                                                 // 1689
				time = this._time;                                                                                                 // 1690
			}                                                                                                                   // 1691
			var labels = this.getLabelsArray(),                                                                                 // 1692
				i = labels.length;                                                                                                 // 1693
			while (--i > -1) {                                                                                                  // 1694
				if (labels[i].time < time) {                                                                                       // 1695
					return labels[i].name;                                                                                            // 1696
				}                                                                                                                  // 1697
			}                                                                                                                   // 1698
			return null;                                                                                                        // 1699
		};                                                                                                                   // 1700
                                                                                                                       // 1701
		p.getLabelsArray = function() {                                                                                      // 1702
			var a = [],                                                                                                         // 1703
				cnt = 0,                                                                                                           // 1704
				p;                                                                                                                 // 1705
			for (p in this._labels) {                                                                                           // 1706
				a[cnt++] = {time:this._labels[p], name:p};                                                                         // 1707
			}                                                                                                                   // 1708
			a.sort(function(a,b) {                                                                                              // 1709
				return a.time - b.time;                                                                                            // 1710
			});                                                                                                                 // 1711
			return a;                                                                                                           // 1712
		};                                                                                                                   // 1713
                                                                                                                       // 1714
                                                                                                                       // 1715
//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------
                                                                                                                       // 1717
		p.progress = function(value, suppressEvents) {                                                                       // 1718
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};                                                                                                                   // 1720
                                                                                                                       // 1721
		p.totalProgress = function(value, suppressEvents) {                                                                  // 1722
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};                                                                                                                   // 1724
                                                                                                                       // 1725
		p.totalDuration = function(value) {                                                                                  // 1726
			if (!arguments.length) {                                                                                            // 1727
				if (this._dirty) {                                                                                                 // 1728
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh                                            // 1729
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.                                   // 1730
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}                                                                                                                  // 1732
				return this._totalDuration;                                                                                        // 1733
			}                                                                                                                   // 1734
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};                                                                                                                   // 1736
                                                                                                                       // 1737
		p.time = function(value, suppressEvents) {                                                                           // 1738
			if (!arguments.length) {                                                                                            // 1739
				return this._time;                                                                                                 // 1740
			}                                                                                                                   // 1741
			if (this._dirty) {                                                                                                  // 1742
				this.totalDuration();                                                                                              // 1743
			}                                                                                                                   // 1744
			if (value > this._duration) {                                                                                       // 1745
				value = this._duration;                                                                                            // 1746
			}                                                                                                                   // 1747
			if (this._yoyo && (this._cycle & 1) !== 0) {                                                                        // 1748
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));                           // 1749
			} else if (this._repeat !== 0) {                                                                                    // 1750
				value += this._cycle * (this._duration + this._repeatDelay);                                                       // 1751
			}                                                                                                                   // 1752
			return this.totalTime(value, suppressEvents);                                                                       // 1753
		};                                                                                                                   // 1754
                                                                                                                       // 1755
		p.repeat = function(value) {                                                                                         // 1756
			if (!arguments.length) {                                                                                            // 1757
				return this._repeat;                                                                                               // 1758
			}                                                                                                                   // 1759
			this._repeat = value;                                                                                               // 1760
			return this._uncache(true);                                                                                         // 1761
		};                                                                                                                   // 1762
                                                                                                                       // 1763
		p.repeatDelay = function(value) {                                                                                    // 1764
			if (!arguments.length) {                                                                                            // 1765
				return this._repeatDelay;                                                                                          // 1766
			}                                                                                                                   // 1767
			this._repeatDelay = value;                                                                                          // 1768
			return this._uncache(true);                                                                                         // 1769
		};                                                                                                                   // 1770
                                                                                                                       // 1771
		p.yoyo = function(value) {                                                                                           // 1772
			if (!arguments.length) {                                                                                            // 1773
				return this._yoyo;                                                                                                 // 1774
			}                                                                                                                   // 1775
			this._yoyo = value;                                                                                                 // 1776
			return this;                                                                                                        // 1777
		};                                                                                                                   // 1778
                                                                                                                       // 1779
		p.currentLabel = function(value) {                                                                                   // 1780
			if (!arguments.length) {                                                                                            // 1781
				return this.getLabelBefore(this._time + 0.00000001);                                                               // 1782
			}                                                                                                                   // 1783
			return this.seek(value, true);                                                                                      // 1784
		};                                                                                                                   // 1785
                                                                                                                       // 1786
		return TimelineMax;                                                                                                  // 1787
                                                                                                                       // 1788
	}, true);                                                                                                             // 1789
	                                                                                                                      // 1790
                                                                                                                       // 1791
                                                                                                                       // 1792
                                                                                                                       // 1793
                                                                                                                       // 1794
	                                                                                                                      // 1795
	                                                                                                                      // 1796
	                                                                                                                      // 1797
	                                                                                                                      // 1798
	                                                                                                                      // 1799
	                                                                                                                      // 1800
	                                                                                                                      // 1801
/*                                                                                                                     // 1802
 * ----------------------------------------------------------------                                                    // 1803
 * BezierPlugin                                                                                                        // 1804
 * ----------------------------------------------------------------                                                    // 1805
 */                                                                                                                    // 1806
	(function() {                                                                                                         // 1807
                                                                                                                       // 1808
		var _RAD2DEG = 180 / Math.PI,                                                                                        // 1809
			_r1 = [],                                                                                                           // 1810
			_r2 = [],                                                                                                           // 1811
			_r3 = [],                                                                                                           // 1812
			_corProps = {},                                                                                                     // 1813
			_globals = _gsScope._gsDefine.globals,                                                                              // 1814
			Segment = function(a, b, c, d) {                                                                                    // 1815
				this.a = a;                                                                                                        // 1816
				this.b = b;                                                                                                        // 1817
				this.c = c;                                                                                                        // 1818
				this.d = d;                                                                                                        // 1819
				this.da = d - a;                                                                                                   // 1820
				this.ca = c - a;                                                                                                   // 1821
				this.ba = b - a;                                                                                                   // 1822
			},                                                                                                                  // 1823
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {                                                                           // 1825
				var q1 = {a:a},                                                                                                    // 1826
					q2 = {},                                                                                                          // 1827
					q3 = {},                                                                                                          // 1828
					q4 = {c:d},                                                                                                       // 1829
					mab = (a + b) / 2,                                                                                                // 1830
					mbc = (b + c) / 2,                                                                                                // 1831
					mcd = (c + d) / 2,                                                                                                // 1832
					mabc = (mab + mbc) / 2,                                                                                           // 1833
					mbcd = (mbc + mcd) / 2,                                                                                           // 1834
					m8 = (mbcd - mabc) / 8;                                                                                           // 1835
				q1.b = mab + (a - mab) / 4;                                                                                        // 1836
				q2.b = mabc + m8;                                                                                                  // 1837
				q1.c = q2.a = (q1.b + q2.b) / 2;                                                                                   // 1838
				q2.c = q3.a = (mabc + mbcd) / 2;                                                                                   // 1839
				q3.b = mbcd - m8;                                                                                                  // 1840
				q4.b = mcd + (d - mcd) / 4;                                                                                        // 1841
				q3.c = q4.a = (q3.b + q4.b) / 2;                                                                                   // 1842
				return [q1, q2, q3, q4];                                                                                           // 1843
			},                                                                                                                  // 1844
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {                                          // 1845
				var l = a.length - 1,                                                                                              // 1846
					ii = 0,                                                                                                           // 1847
					cp1 = a[0].a,                                                                                                     // 1848
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;                                                              // 1849
				for (i = 0; i < l; i++) {                                                                                          // 1850
					seg = a[ii];                                                                                                      // 1851
					p1 = seg.a;                                                                                                       // 1852
					p2 = seg.d;                                                                                                       // 1853
					p3 = a[ii+1].d;                                                                                                   // 1854
                                                                                                                       // 1855
					if (correlate) {                                                                                                  // 1856
						r1 = _r1[i];                                                                                                     // 1857
						r2 = _r2[i];                                                                                                     // 1858
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);                                             // 1859
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));                                      // 1860
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));                                      // 1861
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));                                          // 1862
					} else {                                                                                                          // 1863
						m1 = p2 - (p2 - p1) * curviness * 0.5;                                                                           // 1864
						m2 = p2 + (p3 - p2) * curviness * 0.5;                                                                           // 1865
						mm = p2 - (m1 + m2) / 2;                                                                                         // 1866
					}                                                                                                                 // 1867
					m1 += mm;                                                                                                         // 1868
					m2 += mm;                                                                                                         // 1869
                                                                                                                       // 1870
					seg.c = cp2 = m1;                                                                                                 // 1871
					if (i !== 0) {                                                                                                    // 1872
						seg.b = cp1;                                                                                                     // 1873
					} else {                                                                                                          // 1874
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}                                                                                                                 // 1876
                                                                                                                       // 1877
					seg.da = p2 - p1;                                                                                                 // 1878
					seg.ca = cp2 - p1;                                                                                                // 1879
					seg.ba = cp1 - p1;                                                                                                // 1880
                                                                                                                       // 1881
					if (quad) {                                                                                                       // 1882
						qb = cubicToQuadratic(p1, cp1, cp2, p2);                                                                         // 1883
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);                                                                     // 1884
						ii += 4;                                                                                                         // 1885
					} else {                                                                                                          // 1886
						ii++;                                                                                                            // 1887
					}                                                                                                                 // 1888
                                                                                                                       // 1889
					cp1 = m2;                                                                                                         // 1890
				}                                                                                                                  // 1891
				seg = a[ii];                                                                                                       // 1892
				seg.b = cp1;                                                                                                       // 1893
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;                                                                                            // 1895
				seg.ca = seg.c - seg.a;                                                                                            // 1896
				seg.ba = cp1 - seg.a;                                                                                              // 1897
				if (quad) {                                                                                                        // 1898
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);                                                                  // 1899
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);                                                                      // 1900
				}                                                                                                                  // 1901
			},                                                                                                                  // 1902
			_parseAnchors = function(values, p, correlate, prepend) {                                                           // 1903
				var a = [],                                                                                                        // 1904
					l, i, p1, p2, p3, tmp;                                                                                            // 1905
				if (prepend) {                                                                                                     // 1906
					values = [prepend].concat(values);                                                                                // 1907
					i = values.length;                                                                                                // 1908
					while (--i > -1) {                                                                                                // 1909
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {                                    // 1910
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}                                                                                                                // 1912
					}                                                                                                                 // 1913
				}                                                                                                                  // 1914
				l = values.length - 2;                                                                                             // 1915
				if (l < 0) {                                                                                                       // 1916
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);                                              // 1917
					return a;                                                                                                         // 1918
				}                                                                                                                  // 1919
				for (i = 0; i < l; i++) {                                                                                          // 1920
					p1 = values[i][p];                                                                                                // 1921
					p2 = values[i+1][p];                                                                                              // 1922
					a[i] = new Segment(p1, 0, 0, p2);                                                                                 // 1923
					if (correlate) {                                                                                                  // 1924
						p3 = values[i+2][p];                                                                                             // 1925
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);                                                                  // 1926
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);                                                                  // 1927
					}                                                                                                                 // 1928
				}                                                                                                                  // 1929
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);                                                            // 1930
				return a;                                                                                                          // 1931
			},                                                                                                                  // 1932
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {                                 // 1933
				var obj = {},                                                                                                      // 1934
					props = [],                                                                                                       // 1935
					first = prepend || values[0],                                                                                     // 1936
					i, p, a, j, r, l, seamless, last;                                                                                 // 1937
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;                                     // 1938
				if (curviness == null) {                                                                                           // 1939
					curviness = 1;                                                                                                    // 1940
				}                                                                                                                  // 1941
				for (p in values[0]) {                                                                                             // 1942
					props.push(p);                                                                                                    // 1943
				}                                                                                                                  // 1944
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {                                                                                           // 1946
					last = values[values.length - 1];                                                                                 // 1947
					seamless = true;                                                                                                  // 1948
					i = props.length;                                                                                                 // 1949
					while (--i > -1) {                                                                                                // 1950
						p = props[i];                                                                                                    // 1951
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
							seamless = false;                                                                                               // 1953
							break;                                                                                                          // 1954
						}                                                                                                                // 1955
					}                                                                                                                 // 1956
					if (seamless) {                                                                                                   // 1957
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {                                                                                                   // 1959
							values.unshift(prepend);                                                                                        // 1960
						}                                                                                                                // 1961
						values.push(values[1]);                                                                                          // 1962
						prepend = values[values.length - 3];                                                                             // 1963
					}                                                                                                                 // 1964
				}                                                                                                                  // 1965
				_r1.length = _r2.length = _r3.length = 0;                                                                          // 1966
				i = props.length;                                                                                                  // 1967
				while (--i > -1) {                                                                                                 // 1968
					p = props[i];                                                                                                     // 1969
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);                                                             // 1970
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);                                                         // 1971
				}                                                                                                                  // 1972
				i = _r1.length;                                                                                                    // 1973
				while (--i > -1) {                                                                                                 // 1974
					_r1[i] = Math.sqrt(_r1[i]);                                                                                       // 1975
					_r2[i] = Math.sqrt(_r2[i]);                                                                                       // 1976
				}                                                                                                                  // 1977
				if (!basic) {                                                                                                      // 1978
					i = props.length;                                                                                                 // 1979
					while (--i > -1) {                                                                                                // 1980
						if (_corProps[p]) {                                                                                              // 1981
							a = obj[props[i]];                                                                                              // 1982
							l = a.length - 1;                                                                                               // 1983
							for (j = 0; j < l; j++) {                                                                                       // 1984
								r = a[j+1].da / _r2[j] + a[j].da / _r1[j];                                                                     // 1985
								_r3[j] = (_r3[j] || 0) + r * r;                                                                                // 1986
							}                                                                                                               // 1987
						}                                                                                                                // 1988
					}                                                                                                                 // 1989
					i = _r3.length;                                                                                                   // 1990
					while (--i > -1) {                                                                                                // 1991
						_r3[i] = Math.sqrt(_r3[i]);                                                                                      // 1992
					}                                                                                                                 // 1993
				}                                                                                                                  // 1994
				i = props.length;                                                                                                  // 1995
				j = quadratic ? 4 : 1;                                                                                             // 1996
				while (--i > -1) {                                                                                                 // 1997
					p = props[i];                                                                                                     // 1998
					a = obj[p];                                                                                                       // 1999
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {                                                                                                   // 2001
						a.splice(0, j);                                                                                                  // 2002
						a.splice(a.length - j, j);                                                                                       // 2003
					}                                                                                                                 // 2004
				}                                                                                                                  // 2005
				return obj;                                                                                                        // 2006
			},                                                                                                                  // 2007
			_parseBezierData = function(values, type, prepend) {                                                                // 2008
				type = type || "soft";                                                                                             // 2009
				var obj = {},                                                                                                      // 2010
					inc = (type === "cubic") ? 3 : 2,                                                                                 // 2011
					soft = (type === "soft"),                                                                                         // 2012
					props = [],                                                                                                       // 2013
					a, b, c, d, cur, i, j, l, p, cnt, tmp;                                                                            // 2014
				if (soft && prepend) {                                                                                             // 2015
					values = [prepend].concat(values);                                                                                // 2016
				}                                                                                                                  // 2017
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }                                    // 2018
				for (p in values[0]) {                                                                                             // 2019
					props.push(p);                                                                                                    // 2020
				}                                                                                                                  // 2021
				i = props.length;                                                                                                  // 2022
				while (--i > -1) {                                                                                                 // 2023
					p = props[i];                                                                                                     // 2024
					obj[p] = cur = [];                                                                                                // 2025
					cnt = 0;                                                                                                          // 2026
					l = values.length;                                                                                                // 2027
					for (j = 0; j < l; j++) {                                                                                         // 2028
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {                                                                            // 2030
							cur[cnt++] = (a + cur[cnt-2]) / 2;                                                                              // 2031
						}                                                                                                                // 2032
						cur[cnt++] = a;                                                                                                  // 2033
					}                                                                                                                 // 2034
					l = cnt - inc + 1;                                                                                                // 2035
					cnt = 0;                                                                                                          // 2036
					for (j = 0; j < l; j += inc) {                                                                                    // 2037
						a = cur[j];                                                                                                      // 2038
						b = cur[j+1];                                                                                                    // 2039
						c = cur[j+2];                                                                                                    // 2040
						d = (inc === 2) ? 0 : cur[j+3];                                                                                  // 2041
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);  // 2042
					}                                                                                                                 // 2043
					cur.length = cnt;                                                                                                 // 2044
				}                                                                                                                  // 2045
				return obj;                                                                                                        // 2046
			},                                                                                                                  // 2047
			_addCubicLengths = function(a, steps, resolution) {                                                                 // 2048
				var inc = 1 / resolution,                                                                                          // 2049
					j = a.length,                                                                                                     // 2050
					d, d1, s, da, ca, ba, p, i, inv, bez, index;                                                                      // 2051
				while (--j > -1) {                                                                                                 // 2052
					bez = a[j];                                                                                                       // 2053
					s = bez.a;                                                                                                        // 2054
					da = bez.d - s;                                                                                                   // 2055
					ca = bez.c - s;                                                                                                   // 2056
					ba = bez.b - s;                                                                                                   // 2057
					d = d1 = 0;                                                                                                       // 2058
					for (i = 1; i <= resolution; i++) {                                                                               // 2059
						p = inc * i;                                                                                                     // 2060
						inv = 1 - p;                                                                                                     // 2061
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);                                                // 2062
						index = j * resolution + i - 1;                                                                                  // 2063
						steps[index] = (steps[index] || 0) + d * d;                                                                      // 2064
					}                                                                                                                 // 2065
				}                                                                                                                  // 2066
			},                                                                                                                  // 2067
			_parseLengthData = function(obj, resolution) {                                                                      // 2068
				resolution = resolution >> 0 || 6;                                                                                 // 2069
				var a = [],                                                                                                        // 2070
					lengths = [],                                                                                                     // 2071
					d = 0,                                                                                                            // 2072
					total = 0,                                                                                                        // 2073
					threshold = resolution - 1,                                                                                       // 2074
					segments = [],                                                                                                    // 2075
					curLS = [], //current length segments array                                                                       // 2076
					p, i, l, index;                                                                                                   // 2077
				for (p in obj) {                                                                                                   // 2078
					_addCubicLengths(obj[p], a, resolution);                                                                          // 2079
				}                                                                                                                  // 2080
				l = a.length;                                                                                                      // 2081
				for (i = 0; i < l; i++) {                                                                                          // 2082
					d += Math.sqrt(a[i]);                                                                                             // 2083
					index = i % resolution;                                                                                           // 2084
					curLS[index] = d;                                                                                                 // 2085
					if (index === threshold) {                                                                                        // 2086
						total += d;                                                                                                      // 2087
						index = (i / resolution) >> 0;                                                                                   // 2088
						segments[index] = curLS;                                                                                         // 2089
						lengths[index] = total;                                                                                          // 2090
						d = 0;                                                                                                           // 2091
						curLS = [];                                                                                                      // 2092
					}                                                                                                                 // 2093
				}                                                                                                                  // 2094
				return {length:total, lengths:lengths, segments:segments};                                                         // 2095
			},                                                                                                                  // 2096
                                                                                                                       // 2097
                                                                                                                       // 2098
                                                                                                                       // 2099
			BezierPlugin = _gsScope._gsDefine.plugin({                                                                          // 2100
					propName: "bezier",                                                                                               // 2101
					priority: -1,                                                                                                     // 2102
					version: "1.3.4",                                                                                                 // 2103
					API: 2,                                                                                                           // 2104
					global:true,                                                                                                      // 2105
                                                                                                                       // 2106
					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {                                                                             // 2108
						this._target = target;                                                                                           // 2109
						if (vars instanceof Array) {                                                                                     // 2110
							vars = {values:vars};                                                                                           // 2111
						}                                                                                                                // 2112
						this._func = {};                                                                                                 // 2113
						this._round = {};                                                                                                // 2114
						this._props = [];                                                                                                // 2115
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);                           // 2116
						var values = vars.values || [],                                                                                  // 2117
							first = {},                                                                                                     // 2118
							second = values[0],                                                                                             // 2119
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,                                                      // 2120
							p, isFunc, i, j, prepend;                                                                                       // 2121
                                                                                                                       // 2122
						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {                                                                                              // 2124
							this._props.push(p);                                                                                            // 2125
						}                                                                                                                // 2126
                                                                                                                       // 2127
						i = this._props.length;                                                                                          // 2128
						while (--i > -1) {                                                                                               // 2129
							p = this._props[i];                                                                                             // 2130
                                                                                                                       // 2131
							this._overwriteProps.push(p);                                                                                   // 2132
							isFunc = this._func[p] = (typeof(target[p]) === "function");                                                    // 2133
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {                                                                  // 2135
								prepend = first;                                                                                               // 2136
							}                                                                                                               // 2137
						}                                                                                                                // 2138
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;                                                                        // 2140
                                                                                                                       // 2141
						if (this._timeRes) {                                                                                             // 2142
							var ld = _parseLengthData(this._beziers, this._timeRes);                                                        // 2143
							this._length = ld.length;                                                                                       // 2144
							this._lengths = ld.lengths;                                                                                     // 2145
							this._segments = ld.segments;                                                                                   // 2146
							this._l1 = this._li = this._s1 = this._si = 0;                                                                  // 2147
							this._l2 = this._lengths[0];                                                                                    // 2148
							this._curSeg = this._segments[0];                                                                               // 2149
							this._s2 = this._curSeg[0];                                                                                     // 2150
							this._prec = 1 / this._curSeg.length;                                                                           // 2151
						}                                                                                                                // 2152
                                                                                                                       // 2153
						if ((autoRotate = this._autoRotate)) {                                                                           // 2154
							this._initialRotations = [];                                                                                    // 2155
							if (!(autoRotate[0] instanceof Array)) {                                                                        // 2156
								this._autoRotate = autoRotate = [autoRotate];                                                                  // 2157
							}                                                                                                               // 2158
							i = autoRotate.length;                                                                                          // 2159
							while (--i > -1) {                                                                                              // 2160
								for (j = 0; j < 3; j++) {                                                                                      // 2161
									p = autoRotate[i][j];                                                                                         // 2162
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}                                                                                                              // 2164
								p = autoRotate[i][2];                                                                                          // 2165
								this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];                // 2166
							}                                                                                                               // 2167
						}                                                                                                                // 2168
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;                                                                                                     // 2170
					},                                                                                                                // 2171
                                                                                                                       // 2172
					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {                                                                                                // 2174
						var segments = this._segCount,                                                                                   // 2175
							func = this._func,                                                                                              // 2176
							target = this._target,                                                                                          // 2177
							notStart = (v !== this._startRatio),                                                                            // 2178
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;                                                             // 2179
						if (!this._timeRes) {                                                                                            // 2180
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;                                         // 2181
							t = (v - (curIndex * (1 / segments))) * segments;                                                               // 2182
						} else {                                                                                                         // 2183
							lengths = this._lengths;                                                                                        // 2184
							curSeg = this._curSeg;                                                                                          // 2185
							v *= this._length;                                                                                              // 2186
							i = this._li;                                                                                                   // 2187
							//find the appropriate segment (if the currently cached one isn't correct)                                      // 2188
							if (v > this._l2 && i < segments - 1) {                                                                         // 2189
								l = segments - 1;                                                                                              // 2190
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}                                                            // 2191
								this._l1 = lengths[i-1];                                                                                       // 2192
								this._li = i;                                                                                                  // 2193
								this._curSeg = curSeg = this._segments[i];                                                                     // 2194
								this._s2 = curSeg[(this._s1 = this._si = 0)];                                                                  // 2195
							} else if (v < this._l1 && i > 0) {                                                                             // 2196
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }                                                            // 2197
								if (i === 0 && v < this._l1) {                                                                                 // 2198
									this._l1 = 0;                                                                                                 // 2199
								} else {                                                                                                       // 2200
									i++;                                                                                                          // 2201
								}                                                                                                              // 2202
								this._l2 = lengths[i];                                                                                         // 2203
								this._li = i;                                                                                                  // 2204
								this._curSeg = curSeg = this._segments[i];                                                                     // 2205
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;                                                    // 2206
								this._s2 = curSeg[this._si];                                                                                   // 2207
							}                                                                                                               // 2208
							curIndex = i;                                                                                                   // 2209
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;                                                                                                  // 2211
							i = this._si;                                                                                                   // 2212
							if (v > this._s2 && i < curSeg.length - 1) {                                                                    // 2213
								l = curSeg.length - 1;                                                                                         // 2214
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}                                                             // 2215
								this._s1 = curSeg[i-1];                                                                                        // 2216
								this._si = i;                                                                                                  // 2217
							} else if (v < this._s1 && i > 0) {                                                                             // 2218
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}                                                             // 2219
								if (i === 0 && v < this._s1) {                                                                                 // 2220
									this._s1 = 0;                                                                                                 // 2221
								} else {                                                                                                       // 2222
									i++;                                                                                                          // 2223
								}                                                                                                              // 2224
								this._s2 = curSeg[i];                                                                                          // 2225
								this._si = i;                                                                                                  // 2226
							}                                                                                                               // 2227
							t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;                                                  // 2228
						}                                                                                                                // 2229
						inv = 1 - t;                                                                                                     // 2230
                                                                                                                       // 2231
						i = this._props.length;                                                                                          // 2232
						while (--i > -1) {                                                                                               // 2233
							p = this._props[i];                                                                                             // 2234
							b = this._beziers[p][curIndex];                                                                                 // 2235
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;                                             // 2236
							if (this._round[p]) {                                                                                           // 2237
								val = Math.round(val);                                                                                         // 2238
							}                                                                                                               // 2239
							if (func[p]) {                                                                                                  // 2240
								target[p](val);                                                                                                // 2241
							} else {                                                                                                        // 2242
								target[p] = val;                                                                                               // 2243
							}                                                                                                               // 2244
						}                                                                                                                // 2245
                                                                                                                       // 2246
						if (this._autoRotate) {                                                                                          // 2247
							var ar = this._autoRotate,                                                                                      // 2248
								b2, x1, y1, x2, y2, add, conv;                                                                                 // 2249
							i = ar.length;                                                                                                  // 2250
							while (--i > -1) {                                                                                              // 2251
								p = ar[i][2];                                                                                                  // 2252
								add = ar[i][3] || 0;                                                                                           // 2253
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;                                                                     // 2254
								b = this._beziers[ar[i][0]];                                                                                   // 2255
								b2 = this._beziers[ar[i][1]];                                                                                  // 2256
                                                                                                                       // 2257
								if (b && b2) { //in case one of the properties got overwritten.                                                // 2258
									b = b[curIndex];                                                                                              // 2259
									b2 = b2[curIndex];                                                                                            // 2260
                                                                                                                       // 2261
									x1 = b.a + (b.b - b.a) * t;                                                                                   // 2262
									x2 = b.b + (b.c - b.b) * t;                                                                                   // 2263
									x1 += (x2 - x1) * t;                                                                                          // 2264
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;                                                                     // 2265
                                                                                                                       // 2266
									y1 = b2.a + (b2.b - b2.a) * t;                                                                                // 2267
									y2 = b2.b + (b2.c - b2.b) * t;                                                                                // 2268
									y1 += (y2 - y1) * t;                                                                                          // 2269
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;                                                                  // 2270
                                                                                                                       // 2271
									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];                       // 2272
                                                                                                                       // 2273
									if (func[p]) {                                                                                                // 2274
										target[p](val);                                                                                              // 2275
									} else {                                                                                                      // 2276
										target[p] = val;                                                                                             // 2277
									}                                                                                                             // 2278
								}                                                                                                              // 2279
							}                                                                                                               // 2280
						}                                                                                                                // 2281
					}                                                                                                                 // 2282
			}),                                                                                                                 // 2283
			p = BezierPlugin.prototype;                                                                                         // 2284
                                                                                                                       // 2285
                                                                                                                       // 2286
		BezierPlugin.bezierThrough = bezierThrough;                                                                          // 2287
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;                                                                    // 2288
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {                                                                  // 2290
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);                                                         // 2291
		};                                                                                                                   // 2292
                                                                                                                       // 2293
		BezierPlugin._cssRegister = function() {                                                                             // 2294
			var CSSPlugin = _globals.CSSPlugin;                                                                                 // 2295
			if (!CSSPlugin) {                                                                                                   // 2296
				return;                                                                                                            // 2297
			}                                                                                                                   // 2298
			var _internals = CSSPlugin._internals,                                                                              // 2299
				_parseToProxy = _internals._parseToProxy,                                                                          // 2300
				_setPluginRatio = _internals._setPluginRatio,                                                                      // 2301
				CSSPropTween = _internals.CSSPropTween;                                                                            // 2302
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {                   // 2303
				if (e instanceof Array) {                                                                                          // 2304
					e = {values:e};                                                                                                   // 2305
				}                                                                                                                  // 2306
				plugin = new BezierPlugin();                                                                                       // 2307
				var values = e.values,                                                                                             // 2308
					l = values.length - 1,                                                                                            // 2309
					pluginValues = [],                                                                                                // 2310
					v = {},                                                                                                           // 2311
					i, p, data;                                                                                                       // 2312
				if (l < 0) {                                                                                                       // 2313
					return pt;                                                                                                        // 2314
				}                                                                                                                  // 2315
				for (i = 0; i <= l; i++) {                                                                                         // 2316
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));                                                  // 2317
					pluginValues[i] = data.end;                                                                                       // 2318
				}                                                                                                                  // 2319
				for (p in e) {                                                                                                     // 2320
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}                                                                                                                  // 2322
				v.values = pluginValues;                                                                                           // 2323
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);                                                              // 2324
				pt.data = data;                                                                                                    // 2325
				pt.plugin = plugin;                                                                                                // 2326
				pt.setRatio = _setPluginRatio;                                                                                     // 2327
				if (v.autoRotate === 0) {                                                                                          // 2328
					v.autoRotate = true;                                                                                              // 2329
				}                                                                                                                  // 2330
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {                                                            // 2331
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);                                                           // 2332
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}                                                                                                                  // 2334
				if (v.autoRotate) {                                                                                                // 2335
					if (!cssp._transform) {                                                                                           // 2336
						cssp._enableTransforms(false);                                                                                   // 2337
					}                                                                                                                 // 2338
					data.autoRotate = cssp._target._gsTransform;                                                                      // 2339
				}                                                                                                                  // 2340
				plugin._onInitTween(data.proxy, v, cssp._tween);                                                                   // 2341
				return pt;                                                                                                         // 2342
			}});                                                                                                                // 2343
		};                                                                                                                   // 2344
                                                                                                                       // 2345
		p._roundProps = function(lookup, value) {                                                                            // 2346
			var op = this._overwriteProps,                                                                                      // 2347
				i = op.length;                                                                                                     // 2348
			while (--i > -1) {                                                                                                  // 2349
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {                                                      // 2350
					this._round[op[i]] = value;                                                                                       // 2351
				}                                                                                                                  // 2352
			}                                                                                                                   // 2353
		};                                                                                                                   // 2354
                                                                                                                       // 2355
		p._kill = function(lookup) {                                                                                         // 2356
			var a = this._props,                                                                                                // 2357
				p, i;                                                                                                              // 2358
			for (p in this._beziers) {                                                                                          // 2359
				if (p in lookup) {                                                                                                 // 2360
					delete this._beziers[p];                                                                                          // 2361
					delete this._func[p];                                                                                             // 2362
					i = a.length;                                                                                                     // 2363
					while (--i > -1) {                                                                                                // 2364
						if (a[i] === p) {                                                                                                // 2365
							a.splice(i, 1);                                                                                                 // 2366
						}                                                                                                                // 2367
					}                                                                                                                 // 2368
				}                                                                                                                  // 2369
			}                                                                                                                   // 2370
			return this._super._kill.call(this, lookup);                                                                        // 2371
		};                                                                                                                   // 2372
                                                                                                                       // 2373
	}());                                                                                                                 // 2374
                                                                                                                       // 2375
                                                                                                                       // 2376
                                                                                                                       // 2377
                                                                                                                       // 2378
                                                                                                                       // 2379
                                                                                                                       // 2380
	                                                                                                                      // 2381
	                                                                                                                      // 2382
	                                                                                                                      // 2383
	                                                                                                                      // 2384
	                                                                                                                      // 2385
	                                                                                                                      // 2386
	                                                                                                                      // 2387
	                                                                                                                      // 2388
/*                                                                                                                     // 2389
 * ----------------------------------------------------------------                                                    // 2390
 * CSSPlugin                                                                                                           // 2391
 * ----------------------------------------------------------------                                                    // 2392
 */                                                                                                                    // 2393
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {       // 2394
                                                                                                                       // 2395
		/** @constructor **/                                                                                                 // 2396
		var CSSPlugin = function() {                                                                                         // 2397
				TweenPlugin.call(this, "css");                                                                                     // 2398
				this._overwriteProps.length = 0;                                                                                   // 2399
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)   // 2400
			},                                                                                                                  // 2401
			_globals = _gsScope._gsDefine.globals,                                                                              // 2402
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter          // 2405
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},                                                                                                 // 2407
			p = CSSPlugin.prototype = new TweenPlugin("css");                                                                   // 2408
                                                                                                                       // 2409
		p.constructor = CSSPlugin;                                                                                           // 2410
		CSSPlugin.version = "1.16.0";                                                                                        // 2411
		CSSPlugin.API = 2;                                                                                                   // 2412
		CSSPlugin.defaultTransformPerspective = 0;                                                                           // 2413
		CSSPlugin.defaultSkewType = "compensated";                                                                           // 2414
		p = "px"; //we'll reuse the "p" variable to keep file size down                                                      // 2415
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};
                                                                                                                       // 2417
                                                                                                                       // 2418
		var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g,                                                                           // 2419
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,                                                // 2420
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,                                                                               // 2423
			_opacityExp = /opacity *= *([^)]*)/i,                                                                               // 2424
			_opacityValExp = /opacity:([^;]*)/i,                                                                                // 2425
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,                                                                        // 2426
			_rgbhslExp = /^(rgb|hsl)/,                                                                                          // 2427
			_capsExp = /([A-Z])/g,                                                                                              // 2428
			_camelExp = /-([a-z])/gi,                                                                                           // 2429
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },                                                            // 2431
			_horizExp = /(?:Left|Right|Width)/i,                                                                                // 2432
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,                                                                 // 2433
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,                                            // 2434
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis                // 2435
			_DEG2RAD = Math.PI / 180,                                                                                           // 2436
			_RAD2DEG = 180 / Math.PI,                                                                                           // 2437
			_forcePT = {},                                                                                                      // 2438
			_doc = document,                                                                                                    // 2439
			_createElement = function(type) {                                                                                   // 2440
				return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},                                                                                                                  // 2442
			_tempDiv = _createElement("div"),                                                                                   // 2443
			_tempImg = _createElement("img"),                                                                                   // 2444
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = navigator.userAgent,                                                                                       // 2446
			_autoRound,                                                                                                         // 2447
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).
                                                                                                                       // 2449
			_isSafari,                                                                                                          // 2450
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,                                                                                                            // 2453
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),                                                                                 // 2455
					a = _createElement("a");                                                                                          // 2456
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i+8, 1)) > 3));
				_isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/")+8, 1)) < 6));                        // 2458
				_isFirefox = (_agent.indexOf("Firefox") !== -1);                                                                   // 2459
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {       // 2460
					_ieVers = parseFloat( RegExp.$1 );                                                                                // 2461
				}                                                                                                                  // 2462
				if (!a) {                                                                                                          // 2463
					return false;                                                                                                     // 2464
				}                                                                                                                  // 2465
				a.style.cssText = "top:1px;opacity:.55;";                                                                          // 2466
				return /^0.55/.test(a.style.opacity);                                                                              // 2467
			}()),                                                                                                               // 2468
			_getIEOpacity = function(v) {                                                                                       // 2469
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},                                                                                                                  // 2471
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.             // 2472
				if (window.console) {                                                                                              // 2473
					console.log(s);                                                                                                   // 2474
				}                                                                                                                  // 2475
			},                                                                                                                  // 2476
                                                                                                                       // 2477
			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"                       // 2478
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".                                         // 2479
                                                                                                                       // 2480
			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {                                                                                 // 2482
				e = e || _tempDiv;                                                                                                 // 2483
				var s = e.style,                                                                                                   // 2484
					a, i;                                                                                                             // 2485
				if (s[p] !== undefined) {                                                                                          // 2486
					return p;                                                                                                         // 2487
				}                                                                                                                  // 2488
				p = p.charAt(0).toUpperCase() + p.substr(1);                                                                       // 2489
				a = ["O","Moz","ms","Ms","Webkit"];                                                                                // 2490
				i = 5;                                                                                                             // 2491
				while (--i > -1 && s[a[i]+p] === undefined) { }                                                                    // 2492
				if (i >= 0) {                                                                                                      // 2493
					_prefix = (i === 3) ? "ms" : a[i];                                                                                // 2494
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";                                                                   // 2495
					return _prefix + p;                                                                                               // 2496
				}                                                                                                                  // 2497
				return null;                                                                                                       // 2498
			},                                                                                                                  // 2499
                                                                                                                       // 2500
			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},                           // 2501
                                                                                                                       // 2502
			/**                                                                                                                 // 2503
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");                             // 2505
			 *                                                                                                                  // 2506
			 * @param {!Object} t Target element whose style property you want to query                                         // 2507
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)                                     // 2508
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto". // 2511
			 * @return {?string} The current property value                                                                     // 2512
			 */                                                                                                                 // 2513
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {                                                   // 2514
				var rv;                                                                                                            // 2515
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);                                                                                          // 2517
				}                                                                                                                  // 2518
				if (!calc && t.style[p]) {                                                                                         // 2519
					rv = t.style[p];                                                                                                  // 2520
				} else if ((cs = cs || _getComputedStyle(t))) {                                                                    // 2521
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());            // 2522
				} else if (t.currentStyle) {                                                                                       // 2523
					rv = t.currentStyle[p];                                                                                           // 2524
				}                                                                                                                  // 2525
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;                // 2526
			},                                                                                                                  // 2527
                                                                                                                       // 2528
			/**                                                                                                                 // 2529
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element                                                                                // 2531
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)                                        // 2532
			 * @param {!number} v Value                                                                                         // 2533
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")                                                           // 2534
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels                                                                                 // 2536
			 */                                                                                                                 // 2537
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {                                   // 2538
				if (sfx === "px" || !sfx) { return v; }                                                                            // 2539
				if (sfx === "auto" || !v) { return 0; }                                                                            // 2540
				var horiz = _horizExp.test(p),                                                                                     // 2541
					node = t,                                                                                                         // 2542
					style = _tempDiv.style,                                                                                           // 2543
					neg = (v < 0),                                                                                                    // 2544
					pix, cache, time;                                                                                                 // 2545
				if (neg) {                                                                                                         // 2546
					v = -v;                                                                                                           // 2547
				}                                                                                                                  // 2548
				if (sfx === "%" && p.indexOf("border") !== -1) {                                                                   // 2549
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);                                                       // 2550
				} else {                                                                                                           // 2551
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";                    // 2552
					if (sfx === "%" || !node.appendChild) {                                                                           // 2553
						node = t.parentNode || _doc.body;                                                                                // 2554
						cache = node._gsCache;                                                                                           // 2555
						time = TweenLite.ticker.frame;                                                                                   // 2556
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;                                                                                   // 2558
						}                                                                                                                // 2559
						style[(horiz ? "width" : "height")] = v + sfx;                                                                   // 2560
					} else {                                                                                                          // 2561
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;                                                 // 2562
					}                                                                                                                 // 2563
					node.appendChild(_tempDiv);                                                                                       // 2564
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);                                             // 2565
					node.removeChild(_tempDiv);                                                                                       // 2566
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {                                                    // 2567
						cache = node._gsCache = node._gsCache || {};                                                                     // 2568
						cache.time = time;                                                                                               // 2569
						cache.width = pix / v * 100;                                                                                     // 2570
					}                                                                                                                 // 2571
					if (pix === 0 && !recurse) {                                                                                      // 2572
						pix = _convertToPixels(t, p, v, sfx, true);                                                                      // 2573
					}                                                                                                                 // 2574
				}                                                                                                                  // 2575
				return neg ? -pix : pix;                                                                                           // 2576
			},                                                                                                                  // 2577
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }                                                     // 2579
				var dim = ((p === "left") ? "Left" : "Top"),                                                                       // 2580
					v = _getStyle(t, "margin" + dim, cs);                                                                             // 2581
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);                // 2582
			},                                                                                                                  // 2583
                                                                                                                       // 2584
			// @private returns at object containing ALL of the style properties in camelCase and their associated values.      // 2585
			_getAllStyles = function(t, cs) {                                                                                   // 2586
				var s = {},                                                                                                        // 2587
					i, tr, p;                                                                                                         // 2588
				if ((cs = cs || _getComputedStyle(t, null))) {                                                                     // 2589
					if ((i = cs.length)) {                                                                                            // 2590
						while (--i > -1) {                                                                                               // 2591
							p = cs[i];                                                                                                      // 2592
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);                                                  // 2594
							}                                                                                                               // 2595
						}                                                                                                                // 2596
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.               // 2597
						for (i in cs) {                                                                                                  // 2598
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];                                                                                                  // 2600
							}                                                                                                               // 2601
						}                                                                                                                // 2602
					}                                                                                                                 // 2603
				} else if ((cs = t.currentStyle || t.style)) {                                                                     // 2604
					for (i in cs) {                                                                                                   // 2605
						if (typeof(i) === "string" && s[i] === undefined) {                                                              // 2606
							s[i.replace(_camelExp, _camelFunc)] = cs[i];                                                                    // 2607
						}                                                                                                                // 2608
					}                                                                                                                 // 2609
				}                                                                                                                  // 2610
				if (!_supportsOpacity) {                                                                                           // 2611
					s.opacity = _getIEOpacity(t);                                                                                     // 2612
				}                                                                                                                  // 2613
				tr = _getTransform(t, cs, false);                                                                                  // 2614
				s.rotation = tr.rotation;                                                                                          // 2615
				s.skewX = tr.skewX;                                                                                                // 2616
				s.scaleX = tr.scaleX;                                                                                              // 2617
				s.scaleY = tr.scaleY;                                                                                              // 2618
				s.x = tr.x;                                                                                                        // 2619
				s.y = tr.y;                                                                                                        // 2620
				if (_supports3D) {                                                                                                 // 2621
					s.z = tr.z;                                                                                                       // 2622
					s.rotationX = tr.rotationX;                                                                                       // 2623
					s.rotationY = tr.rotationY;                                                                                       // 2624
					s.scaleZ = tr.scaleZ;                                                                                             // 2625
				}                                                                                                                  // 2626
				if (s.filters) {                                                                                                   // 2627
					delete s.filters;                                                                                                 // 2628
				}                                                                                                                  // 2629
				return s;                                                                                                          // 2630
			},                                                                                                                  // 2631
                                                                                                                       // 2632
			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {                                                                  // 2634
				var difs = {},                                                                                                     // 2635
					style = t.style,                                                                                                  // 2636
					val, p, mpt;                                                                                                      // 2637
				for (p in s2) {                                                                                                    // 2638
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);                                                               // 2642
						}                                                                                                                // 2643
					}                                                                                                                 // 2644
				}                                                                                                                  // 2645
				if (vars) {                                                                                                        // 2646
					for (p in vars) { //copy properties (except className)                                                            // 2647
						if (p !== "className") {                                                                                         // 2648
							difs[p] = vars[p];                                                                                              // 2649
						}                                                                                                                // 2650
					}                                                                                                                 // 2651
				}                                                                                                                  // 2652
				return {difs:difs, firstMPT:mpt};                                                                                  // 2653
			},                                                                                                                  // 2654
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},                                                    // 2655
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],                                                 // 2656
                                                                                                                       // 2657
			/**                                                                                                                 // 2658
			 * @private Gets the width or height of an element                                                                  // 2659
			 * @param {!Object} t Target element                                                                                // 2660
			 * @param {!string} p Property name ("width" or "height")                                                           // 2661
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.                            // 2662
			 * @return {number} Dimension (in pixels)                                                                           // 2663
			 */                                                                                                                 // 2664
			_getDimension = function(t, p, cs) {                                                                                // 2665
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),                                              // 2666
					a = _dimensions[p],                                                                                               // 2667
					i = a.length;                                                                                                     // 2668
				cs = cs || _getComputedStyle(t, null);                                                                             // 2669
				while (--i > -1) {                                                                                                 // 2670
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;                                                 // 2671
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;                                        // 2672
				}                                                                                                                  // 2673
				return v;                                                                                                          // 2674
			},                                                                                                                  // 2675
                                                                                                                       // 2676
			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {                                                                              // 2678
				if (v == null || v === "" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					v = "0 0";                                                                                                        // 2680
				}                                                                                                                  // 2681
				var a = v.split(" "),                                                                                              // 2682
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],                              // 2683
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];                              // 2684
				if (y == null) {                                                                                                   // 2685
					y = (x === "center") ? "50%" : "0";                                                                               // 2686
				} else if (y === "center") {                                                                                       // 2687
					y = "50%";                                                                                                        // 2688
				}                                                                                                                  // 2689
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";                                                                                                        // 2691
				}                                                                                                                  // 2692
				if (recObj) {                                                                                                      // 2693
					recObj.oxp = (x.indexOf("%") !== -1);                                                                             // 2694
					recObj.oyp = (y.indexOf("%") !== -1);                                                                             // 2695
					recObj.oxr = (x.charAt(1) === "=");                                                                               // 2696
					recObj.oyr = (y.charAt(1) === "=");                                                                               // 2697
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));                                                                   // 2698
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));                                                                   // 2699
				}                                                                                                                  // 2700
				return x + " " + y + ((a.length > 2) ? " " + a[2] : "");                                                           // 2701
			},                                                                                                                  // 2702
                                                                                                                       // 2703
			/**                                                                                                                 // 2704
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number                          // 2706
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number                     // 2707
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */                                                                                                                 // 2709
			_parseChange = function(e, b) {                                                                                     // 2710
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
			},                                                                                                                  // 2712
                                                                                                                       // 2713
			/**                                                                                                                 // 2714
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed                                                                             // 2716
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value                                                                                    // 2718
			 */                                                                                                                 // 2719
			_parseVal = function(v, d) {                                                                                        // 2720
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v);
			},                                                                                                                  // 2722
                                                                                                                       // 2723
			/**                                                                                                                 // 2724
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed                                                                             // 2726
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians                                                                         // 2730
			 */                                                                                                                 // 2731
			_parseAngle = function(v, d, p, directionalEnd) {                                                                   // 2732
				var min = 0.000001,                                                                                                // 2733
					cap, split, dif, result, isRelative;                                                                              // 2734
				if (v == null) {                                                                                                   // 2735
					result = d;                                                                                                       // 2736
				} else if (typeof(v) === "number") {                                                                               // 2737
					result = v;                                                                                                       // 2738
				} else {                                                                                                           // 2739
					cap = 360;                                                                                                        // 2740
					split = v.split("_");                                                                                             // 2741
					isRelative = (v.charAt(1) === "=");                                                                               // 2742
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {                                                                                               // 2744
						if (directionalEnd) {                                                                                            // 2745
							directionalEnd[p] = d + dif;                                                                                    // 2746
						}                                                                                                                // 2747
						if (v.indexOf("short") !== -1) {                                                                                 // 2748
							dif = dif % cap;                                                                                                // 2749
							if (dif !== dif % (cap / 2)) {                                                                                  // 2750
								dif = (dif < 0) ? dif + cap : dif - cap;                                                                       // 2751
							}                                                                                                               // 2752
						}                                                                                                                // 2753
						if (v.indexOf("_cw") !== -1 && dif < 0) {                                                                        // 2754
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;                                               // 2755
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {                                                                 // 2756
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;                                               // 2757
						}                                                                                                                // 2758
					}                                                                                                                 // 2759
					result = d + dif;                                                                                                 // 2760
				}                                                                                                                  // 2761
				if (result < min && result > -min) {                                                                               // 2762
					result = 0;                                                                                                       // 2763
				}                                                                                                                  // 2764
				return result;                                                                                                     // 2765
			},                                                                                                                  // 2766
                                                                                                                       // 2767
			_colorLookup = {aqua:[0,255,255],                                                                                   // 2768
				lime:[0,255,0],                                                                                                    // 2769
				silver:[192,192,192],                                                                                              // 2770
				black:[0,0,0],                                                                                                     // 2771
				maroon:[128,0,0],                                                                                                  // 2772
				teal:[0,128,128],                                                                                                  // 2773
				blue:[0,0,255],                                                                                                    // 2774
				navy:[0,0,128],                                                                                                    // 2775
				white:[255,255,255],                                                                                               // 2776
				fuchsia:[255,0,255],                                                                                               // 2777
				olive:[128,128,0],                                                                                                 // 2778
				yellow:[255,255,0],                                                                                                // 2779
				orange:[255,165,0],                                                                                                // 2780
				gray:[128,128,128],                                                                                                // 2781
				purple:[128,0,128],                                                                                                // 2782
				green:[0,128,0],                                                                                                   // 2783
				red:[255,0,0],                                                                                                     // 2784
				pink:[255,192,203],                                                                                                // 2785
				cyan:[0,255,255],                                                                                                  // 2786
				transparent:[255,255,255,0]},                                                                                      // 2787
                                                                                                                       // 2788
			_hue = function(h, m1, m2) {                                                                                        // 2789
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;                                                                         // 2790
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},                                                                                                                  // 2792
                                                                                                                       // 2793
			/**                                                                                                                 // 2794
			 * @private Parses a color (like #9F0, #FF9900, or rgb(255,51,153)) into an array with 3 elements for red, green, and blue. Also handles rgba() values (splits into array of 4 elements of course)
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order.          // 2797
			 */                                                                                                                 // 2798
			_parseColor = CSSPlugin.parseColor = function(v) {                                                                  // 2799
				var c1, c2, c3, h, s, l;                                                                                           // 2800
				if (!v || v === "") {                                                                                              // 2801
					return _colorLookup.black;                                                                                        // 2802
				}                                                                                                                  // 2803
				if (typeof(v) === "number") {                                                                                      // 2804
					return [v >> 16, (v >> 8) & 255, v & 255];                                                                        // 2805
				}                                                                                                                  // 2806
				if (v.charAt(v.length - 1) === ",") { //sometimes a trailing commma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);                                                                                    // 2808
				}                                                                                                                  // 2809
				if (_colorLookup[v]) {                                                                                             // 2810
					return _colorLookup[v];                                                                                           // 2811
				}                                                                                                                  // 2812
				if (v.charAt(0) === "#") {                                                                                         // 2813
					if (v.length === 4) { //for shorthand like #9F0                                                                   // 2814
						c1 = v.charAt(1),                                                                                                // 2815
						c2 = v.charAt(2),                                                                                                // 2816
						c3 = v.charAt(3);                                                                                                // 2817
						v = "#" + c1 + c1 + c2 + c2 + c3 + c3;                                                                           // 2818
					}                                                                                                                 // 2819
					v = parseInt(v.substr(1), 16);                                                                                    // 2820
					return [v >> 16, (v >> 8) & 255, v & 255];                                                                        // 2821
				}                                                                                                                  // 2822
				if (v.substr(0, 3) === "hsl") {                                                                                    // 2823
					v = v.match(_numExp);                                                                                             // 2824
					h = (Number(v[0]) % 360) / 360;                                                                                   // 2825
					s = Number(v[1]) / 100;                                                                                           // 2826
					l = Number(v[2]) / 100;                                                                                           // 2827
					c2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;                                                                    // 2828
					c1 = l * 2 - c2;                                                                                                  // 2829
					if (v.length > 3) {                                                                                               // 2830
						v[3] = Number(v[3]);                                                                                             // 2831
					}                                                                                                                 // 2832
					v[0] = _hue(h + 1 / 3, c1, c2);                                                                                   // 2833
					v[1] = _hue(h, c1, c2);                                                                                           // 2834
					v[2] = _hue(h - 1 / 3, c1, c2);                                                                                   // 2835
					return v;                                                                                                         // 2836
				}                                                                                                                  // 2837
				v = v.match(_numExp) || _colorLookup.transparent;                                                                  // 2838
				v[0] = Number(v[0]);                                                                                               // 2839
				v[1] = Number(v[1]);                                                                                               // 2840
				v[2] = Number(v[2]);                                                                                               // 2841
				if (v.length > 3) {                                                                                                // 2842
					v[3] = Number(v[3]);                                                                                              // 2843
				}                                                                                                                  // 2844
				return v;                                                                                                          // 2845
			},                                                                                                                  // 2846
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.
                                                                                                                       // 2848
		for (p in _colorLookup) {                                                                                            // 2849
			_colorExp += "|" + p + "\\b";                                                                                       // 2850
		}                                                                                                                    // 2851
		_colorExp = new RegExp(_colorExp+")", "gi");                                                                         // 2852
                                                                                                                       // 2853
		/**                                                                                                                  // 2854
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function                                                                             // 2859
		 */                                                                                                                  // 2860
		var _getFormatter = function(dflt, clr, collapsible, multi) {                                                        // 2861
				if (dflt == null) {                                                                                                // 2862
					return function(v) {return v;};                                                                                   // 2863
				}                                                                                                                  // 2864
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",                                                        // 2865
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],                                                      // 2866
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),                                                                     // 2867
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",                                                          // 2868
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",                                                                   // 2869
					numVals = dVals.length,                                                                                           // 2870
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",                                                        // 2871
					formatter;                                                                                                        // 2872
				if (!numVals) {                                                                                                    // 2873
					return function(v) {return v;};                                                                                   // 2874
				}                                                                                                                  // 2875
				if (clr) {                                                                                                         // 2876
					formatter = function(v) {                                                                                         // 2877
						var color, vals, i, a;                                                                                           // 2878
						if (typeof(v) === "number") {                                                                                    // 2879
							v += dSfx;                                                                                                      // 2880
						} else if (multi && _commasOutsideParenExp.test(v)) {                                                            // 2881
							a = v.replace(_commasOutsideParenExp, "|").split("|");                                                          // 2882
							for (i = 0; i < a.length; i++) {                                                                                // 2883
								a[i] = formatter(a[i]);                                                                                        // 2884
							}                                                                                                               // 2885
							return a.join(",");                                                                                             // 2886
						}                                                                                                                // 2887
						color = (v.match(_colorExp) || [dColor])[0];                                                                     // 2888
						vals = v.split(color).join("").match(_valuesExp) || [];                                                          // 2889
						i = vals.length;                                                                                                 // 2890
						if (numVals > i--) {                                                                                             // 2891
							while (++i < numVals) {                                                                                         // 2892
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];                                                  // 2893
							}                                                                                                               // 2894
						}                                                                                                                // 2895
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");               // 2896
					};                                                                                                                // 2897
					return formatter;                                                                                                 // 2898
                                                                                                                       // 2899
				}                                                                                                                  // 2900
				formatter = function(v) {                                                                                          // 2901
					var vals, a, i;                                                                                                   // 2902
					if (typeof(v) === "number") {                                                                                     // 2903
						v += dSfx;                                                                                                       // 2904
					} else if (multi && _commasOutsideParenExp.test(v)) {                                                             // 2905
						a = v.replace(_commasOutsideParenExp, "|").split("|");                                                           // 2906
						for (i = 0; i < a.length; i++) {                                                                                 // 2907
							a[i] = formatter(a[i]);                                                                                         // 2908
						}                                                                                                                // 2909
						return a.join(",");                                                                                              // 2910
					}                                                                                                                 // 2911
					vals = v.match(_valuesExp) || [];                                                                                 // 2912
					i = vals.length;                                                                                                  // 2913
					if (numVals > i--) {                                                                                              // 2914
						while (++i < numVals) {                                                                                          // 2915
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];                                                   // 2916
						}                                                                                                                // 2917
					}                                                                                                                 // 2918
					return pfx + vals.join(delim) + sfx;                                                                              // 2919
				};                                                                                                                 // 2920
				return formatter;                                                                                                  // 2921
			},                                                                                                                  // 2922
                                                                                                                       // 2923
			/**                                                                                                                 // 2924
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function                                                                          // 2927
			 */                                                                                                                 // 2928
			_getEdgeParser = function(props) {                                                                                  // 2929
				props = props.split(",");                                                                                          // 2930
				return function(t, e, p, cssp, pt, plugin, vars) {                                                                 // 2931
					var a = (e + "").split(" "),                                                                                      // 2932
						i;                                                                                                               // 2933
					vars = {};                                                                                                        // 2934
					for (i = 0; i < 4; i++) {                                                                                         // 2935
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];                                                         // 2936
					}                                                                                                                 // 2937
					return cssp.parse(t, vars, pt, plugin);                                                                           // 2938
				};                                                                                                                 // 2939
			},                                                                                                                  // 2940
                                                                                                                       // 2941
			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {                                                        // 2943
				this.plugin.setRatio(v);                                                                                           // 2944
				var d = this.data,                                                                                                 // 2945
					proxy = d.proxy,                                                                                                  // 2946
					mpt = d.firstMPT,                                                                                                 // 2947
					min = 0.000001,                                                                                                   // 2948
					val, pt, i, str;                                                                                                  // 2949
				while (mpt) {                                                                                                      // 2950
					val = proxy[mpt.v];                                                                                               // 2951
					if (mpt.r) {                                                                                                      // 2952
						val = Math.round(val);                                                                                           // 2953
					} else if (val < min && val > -min) {                                                                             // 2954
						val = 0;                                                                                                         // 2955
					}                                                                                                                 // 2956
					mpt.t[mpt.p] = val;                                                                                               // 2957
					mpt = mpt._next;                                                                                                  // 2958
				}                                                                                                                  // 2959
				if (d.autoRotate) {                                                                                                // 2960
					d.autoRotate.rotation = proxy.rotation;                                                                           // 2961
				}                                                                                                                  // 2962
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method.
				if (v === 1) {                                                                                                     // 2964
					mpt = d.firstMPT;                                                                                                 // 2965
					while (mpt) {                                                                                                     // 2966
						pt = mpt.t;                                                                                                      // 2967
						if (!pt.type) {                                                                                                  // 2968
							pt.e = pt.s + pt.xs0;                                                                                           // 2969
						} else if (pt.type === 1) {                                                                                      // 2970
							str = pt.xs0 + pt.s + pt.xs1;                                                                                   // 2971
							for (i = 1; i < pt.l; i++) {                                                                                    // 2972
								str += pt["xn"+i] + pt["xs"+(i+1)];                                                                            // 2973
							}                                                                                                               // 2974
							pt.e = str;                                                                                                     // 2975
						}                                                                                                                // 2976
						mpt = mpt._next;                                                                                                 // 2977
					}                                                                                                                 // 2978
				}                                                                                                                  // 2979
			},                                                                                                                  // 2980
                                                                                                                       // 2981
			/**                                                                                                                 // 2982
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)                            // 2984
			 * @param {!string} p property name                                                                                 // 2985
			 * @param {(number|string|object)} v value                                                                          // 2986
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list                                               // 2987
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer                          // 2988
			 */                                                                                                                 // 2989
			MiniPropTween = function(t, p, v, next, r) {                                                                        // 2990
				this.t = t;                                                                                                        // 2991
				this.p = p;                                                                                                        // 2992
				this.v = v;                                                                                                        // 2993
				this.r = r;                                                                                                        // 2994
				if (next) {                                                                                                        // 2995
					next._prev = this;                                                                                                // 2996
					this._next = next;                                                                                                // 2997
				}                                                                                                                  // 2998
			},                                                                                                                  // 2999
                                                                                                                       // 3000
			/**                                                                                                                 // 3001
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:                                                 // 3003
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list                                                          // 3006
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened                                                                   // 3008
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance                                                                  // 3010
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list                                               // 3011
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values // 3012
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions) // 3014
			 */                                                                                                                 // 3015
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {                           // 3016
				var bpt = pt,                                                                                                      // 3017
					start = {},                                                                                                       // 3018
					end = {},                                                                                                         // 3019
					transform = cssp._transform,                                                                                      // 3020
					oldForce = _forcePT,                                                                                              // 3021
					i, p, xp, mpt, firstPT;                                                                                           // 3022
				cssp._transform = null;                                                                                            // 3023
				_forcePT = vars;                                                                                                   // 3024
				pt = firstPT = cssp.parse(t, vars, pt, plugin);                                                                    // 3025
				_forcePT = oldForce;                                                                                               // 3026
				//break off from the linked list so the new ones are isolated.                                                     // 3027
				if (shallow) {                                                                                                     // 3028
					cssp._transform = transform;                                                                                      // 3029
					if (bpt) {                                                                                                        // 3030
						bpt._prev = null;                                                                                                // 3031
						if (bpt._prev) {                                                                                                 // 3032
							bpt._prev._next = null;                                                                                         // 3033
						}                                                                                                                // 3034
					}                                                                                                                 // 3035
				}                                                                                                                  // 3036
				while (pt && pt !== bpt) {                                                                                         // 3037
					if (pt.type <= 1) {                                                                                               // 3038
						p = pt.p;                                                                                                        // 3039
						end[p] = pt.s + pt.c;                                                                                            // 3040
						start[p] = pt.s;                                                                                                 // 3041
						if (!shallow) {                                                                                                  // 3042
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);                                                                 // 3043
							pt.c = 0;                                                                                                       // 3044
						}                                                                                                                // 3045
						if (pt.type === 1) {                                                                                             // 3046
							i = pt.l;                                                                                                       // 3047
							while (--i > 0) {                                                                                               // 3048
								xp = "xn" + i;                                                                                                 // 3049
								p = pt.p + "_" + xp;                                                                                           // 3050
								end[p] = pt.data[xp];                                                                                          // 3051
								start[p] = pt[xp];                                                                                             // 3052
								if (!shallow) {                                                                                                // 3053
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);                                                          // 3054
								}                                                                                                              // 3055
							}                                                                                                               // 3056
						}                                                                                                                // 3057
					}                                                                                                                 // 3058
					pt = pt._next;                                                                                                    // 3059
				}                                                                                                                  // 3060
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};                                                           // 3061
			},                                                                                                                  // 3062
                                                                                                                       // 3063
                                                                                                                       // 3064
                                                                                                                       // 3065
			/**                                                                                                                 // 3066
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):              // 3068
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".             // 3075
			 * @param {number} s Starting numeric value                                                                         // 3076
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded                                                      // 3081
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */                                                                                                                 // 3085
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {                         // 3086
				this.t = t; //target                                                                                               // 3087
				this.p = p; //property                                                                                             // 3088
				this.s = s; //starting value                                                                                       // 3089
				this.c = c; //change value                                                                                         // 3090
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {                                                                                // 3092
					_overwriteProps.push(this.n);                                                                                     // 3093
				}                                                                                                                  // 3094
				this.r = r; //round (boolean)                                                                                      // 3095
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {                                                                                                          // 3097
					this.pr = pr;                                                                                                     // 3098
					_hasPriority = true;                                                                                              // 3099
				}                                                                                                                  // 3100
				this.b = (b === undefined) ? s : b;                                                                                // 3101
				this.e = (e === undefined) ? s + c : e;                                                                            // 3102
				if (next) {                                                                                                        // 3103
					this._next = next;                                                                                                // 3104
					next._prev = this;                                                                                                // 3105
				}                                                                                                                  // 3106
			},                                                                                                                  // 3107
                                                                                                                       // 3108
			/**                                                                                                                 // 3109
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *                                                                                                                  // 3114
			 * @param {!Object} t Target whose property will be tweened                                                         // 3115
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")     // 3116
			 * @param {string} b Beginning value                                                                                // 3117
			 * @param {string} e Ending value                                                                                   // 3118
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */                                                                                                                 // 3126
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {               // 3127
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);                                                             // 3128
				b = b || dflt || "";                                                                                               // 3129
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);                                  // 3130
				e += ""; //ensures it's a string                                                                                   // 3131
				var ba = b.split(", ").join(",").split(" "), //beginning array                                                     // 3132
					ea = e.split(", ").join(",").split(" "), //ending array                                                           // 3133
					l = ba.length,                                                                                                    // 3134
					autoRound = (_autoRound !== false),                                                                               // 3135
					i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str;                                                         // 3136
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {                                                              // 3137
					ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");                                               // 3138
					ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");                                               // 3139
					l = ba.length;                                                                                                    // 3140
				}                                                                                                                  // 3141
				if (l !== ea.length) {                                                                                             // 3142
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");                            // 3143
					ba = (dflt || "").split(" ");                                                                                     // 3144
					l = ba.length;                                                                                                    // 3145
				}                                                                                                                  // 3146
				pt.plugin = plugin;                                                                                                // 3147
				pt.setRatio = setRatio;                                                                                            // 3148
				for (i = 0; i < l; i++) {                                                                                          // 3149
					bv = ba[i];                                                                                                       // 3150
					ev = ea[i];                                                                                                       // 3151
					bn = parseFloat(bv);                                                                                              // 3152
                                                                                                                       // 3153
					//if the value begins with a number (most common). It's fine if it has a suffix like px                           // 3154
					if (bn || bn === 0) {                                                                                             // 3155
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);
                                                                                                                       // 3157
					//if the value is a color                                                                                         // 3158
					} else if (clrs && (bv.charAt(0) === "#" || _colorLookup[bv] || _rgbhslExp.test(bv))) {                           // 3159
						str = ev.charAt(ev.length - 1) === "," ? ")," : ")"; //if there's a comma at the end, retain it.                 // 3160
						bv = _parseColor(bv);                                                                                            // 3161
						ev = _parseColor(ev);                                                                                            // 3162
						rgba = (bv.length + ev.length > 6);                                                                              // 3163
						if (rgba && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";                                                       // 3165
							pt.e = pt.e.split(ea[i]).join("transparent");                                                                   // 3166
						} else {                                                                                                         // 3167
							if (!_supportsOpacity) { //old versions of IE don't support rgba().                                             // 3168
								rgba = false;                                                                                                  // 3169
							}                                                                                                               // 3170
							pt.appendXtra((rgba ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)                                 // 3171
								.appendXtra("", bv[1], ev[1] - bv[1], ",", true)                                                               // 3172
								.appendXtra("", bv[2], ev[2] - bv[2], (rgba ? "," : str), true);                                               // 3173
							if (rgba) {                                                                                                     // 3174
								bv = (bv.length < 4) ? 1 : bv[3];                                                                              // 3175
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);                                         // 3176
							}                                                                                                               // 3177
						}                                                                                                                // 3178
                                                                                                                       // 3179
					} else {                                                                                                          // 3180
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array
                                                                                                                       // 3182
						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.          // 3183
						if (!bnums) {                                                                                                    // 3184
							pt["xs" + pt.l] += pt.l ? " " + bv : bv;                                                                        // 3185
                                                                                                                       // 3186
						//loop through all the numbers that are found and construct the extra values on the pt.                          // 3187
						} else {                                                                                                         // 3188
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {                                                                  // 3190
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");                         // 3191
								return pt;                                                                                                     // 3192
							}                                                                                                               // 3193
							ni = 0;                                                                                                         // 3194
							for (xi = 0; xi < bnums.length; xi++) {                                                                         // 3195
								cv = bnums[xi];                                                                                                // 3196
								temp = bv.indexOf(cv, ni);                                                                                     // 3197
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;                                                                                         // 3199
							}                                                                                                               // 3200
							pt["xs" + pt.l] += bv.substr(ni);                                                                               // 3201
						}                                                                                                                // 3202
					}                                                                                                                 // 3203
				}                                                                                                                  // 3204
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {                                                                          // 3206
					str = pt.xs0 + pt.data.s;                                                                                         // 3207
					for (i = 1; i < pt.l; i++) {                                                                                      // 3208
						str += pt["xs" + i] + pt.data["xn" + i];                                                                         // 3209
					}                                                                                                                 // 3210
					pt.e = str + pt["xs" + i];                                                                                        // 3211
				}                                                                                                                  // 3212
				if (!pt.l) {                                                                                                       // 3213
					pt.type = -1;                                                                                                     // 3214
					pt.xs0 = pt.e;                                                                                                    // 3215
				}                                                                                                                  // 3216
				return pt.xfirst || pt;                                                                                            // 3217
			},                                                                                                                  // 3218
			i = 9;                                                                                                              // 3219
                                                                                                                       // 3220
                                                                                                                       // 3221
		p = CSSPropTween.prototype;                                                                                          // 3222
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.                                        // 3223
		while (--i > 0) {                                                                                                    // 3224
			p["xn" + i] = 0;                                                                                                    // 3225
			p["xs" + i] = "";                                                                                                   // 3226
		}                                                                                                                    // 3227
		p.xs0 = "";                                                                                                          // 3228
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;                                        // 3229
                                                                                                                       // 3230
                                                                                                                       // 3231
		/**                                                                                                                  // 3232
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"                            // 3234
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).                         // 3235
		 * @param {string=} pfx Prefix (if any)                                                                              // 3236
		 * @param {!number} s Starting value                                                                                 // 3237
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)                                                                              // 3239
		 * @param {boolean=} r Round (if true).                                                                              // 3240
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.                           // 3242
		 */                                                                                                                  // 3243
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {                                                                    // 3244
			var pt = this,                                                                                                      // 3245
				l = pt.l;                                                                                                          // 3246
			pt["xs" + l] += (pad && l) ? " " + pfx : pfx || "";                                                                 // 3247
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");                                                                                   // 3249
				return pt;                                                                                                         // 3250
			}                                                                                                                   // 3251
			pt.l++;                                                                                                             // 3252
			pt.type = pt.setRatio ? 2 : 1;                                                                                      // 3253
			pt["xs" + pt.l] = sfx || "";                                                                                        // 3254
			if (l > 0) {                                                                                                        // 3255
				pt.data["xn" + l] = s + c;                                                                                         // 3256
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)              // 3257
				pt["xn" + l] = s;                                                                                                  // 3258
				if (!pt.plugin) {                                                                                                  // 3259
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);                             // 3260
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}                                                                                                                  // 3262
				return pt;                                                                                                         // 3263
			}                                                                                                                   // 3264
			pt.data = {s:s + c};                                                                                                // 3265
			pt.rxp = {};                                                                                                        // 3266
			pt.s = s;                                                                                                           // 3267
			pt.c = c;                                                                                                           // 3268
			pt.r = r;                                                                                                           // 3269
			return pt;                                                                                                          // 3270
		};                                                                                                                   // 3271
                                                                                                                       // 3272
		/**                                                                                                                  // 3273
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")                                               // 3275
		 * @param {Object=} options An object containing any of the following configuration options:                         // 3276
		 *                      - defaultValue: the default value                                                            // 3277
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */                                                                                                                  // 3286
		var SpecialProp = function(p, options) {                                                                             // 3287
				options = options || {};                                                                                           // 3288
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;                                                            // 3289
				_specialProps[p] = _specialProps[this.p] = this;                                                                   // 3290
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {                                                                                              // 3292
					this.parse = options.parser;                                                                                      // 3293
				}                                                                                                                  // 3294
				this.clrs = options.color;                                                                                         // 3295
				this.multi = options.multi;                                                                                        // 3296
				this.keyword = options.keyword;                                                                                    // 3297
				this.dflt = options.defaultValue;                                                                                  // 3298
				this.pr = options.priority || 0;                                                                                   // 3299
			},                                                                                                                  // 3300
                                                                                                                       // 3301
			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {             // 3303
				if (typeof(options) !== "object") {                                                                                // 3304
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}                                                                                                                  // 3306
				var a = p.split(","),                                                                                              // 3307
					d = options.defaultValue,                                                                                         // 3308
					i, temp;                                                                                                          // 3309
				defaults = defaults || [d];                                                                                        // 3310
				for (i = 0; i < a.length; i++) {                                                                                   // 3311
					options.prefix = (i === 0 && options.prefix);                                                                     // 3312
					options.defaultValue = defaults[i] || d;                                                                          // 3313
					temp = new SpecialProp(a[i], options);                                                                            // 3314
				}                                                                                                                  // 3315
			},                                                                                                                  // 3316
                                                                                                                       // 3317
			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = function(p) {                                                                                 // 3319
				if (!_specialProps[p]) {                                                                                           // 3320
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";                                              // 3321
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {                                // 3322
						var pluginClass = _globals.com.greensock.plugins[pluginName];                                                    // 3323
						if (!pluginClass) {                                                                                              // 3324
							_log("Error: " + pluginName + " js file not loaded.");                                                          // 3325
							return pt;                                                                                                      // 3326
						}                                                                                                                // 3327
						pluginClass._cssRegister();                                                                                      // 3328
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);                                                  // 3329
					}});                                                                                                              // 3330
				}                                                                                                                  // 3331
			};                                                                                                                  // 3332
                                                                                                                       // 3333
                                                                                                                       // 3334
		p = SpecialProp.prototype;                                                                                           // 3335
                                                                                                                       // 3336
		/**                                                                                                                  // 3337
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element                                                                                 // 3339
		 * @param {(string|number|object)} b beginning value                                                                 // 3340
		 * @param {(string|number|object)} e ending (destination) value                                                      // 3341
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list                                                    // 3342
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list                                                     // 3345
		 */                                                                                                                  // 3346
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {                                                           // 3347
			var kwd = this.keyword,                                                                                             // 3348
				i, ba, ea, l, bi, ei;                                                                                              // 3349
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {                             // 3351
				ba = b.replace(_commasOutsideParenExp, "|").split("|");                                                            // 3352
				ea = e.replace(_commasOutsideParenExp, "|").split("|");                                                            // 3353
			} else if (kwd) {                                                                                                   // 3354
				ba = [b];                                                                                                          // 3355
				ea = [e];                                                                                                          // 3356
			}                                                                                                                   // 3357
			if (ea) {                                                                                                           // 3358
				l = (ea.length > ba.length) ? ea.length : ba.length;                                                               // 3359
				for (i = 0; i < l; i++) {                                                                                          // 3360
					b = ba[i] = ba[i] || this.dflt;                                                                                   // 3361
					e = ea[i] = ea[i] || this.dflt;                                                                                   // 3362
					if (kwd) {                                                                                                        // 3363
						bi = b.indexOf(kwd);                                                                                             // 3364
						ei = e.indexOf(kwd);                                                                                             // 3365
						if (bi !== ei) {                                                                                                 // 3366
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.                     // 3367
								ba[i] = ba[i].split(kwd).join("");                                                                             // 3368
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.                                        // 3369
								ba[i] += " " + kwd;                                                                                            // 3370
							}                                                                                                               // 3371
						}                                                                                                                // 3372
					}                                                                                                                 // 3373
				}                                                                                                                  // 3374
				b = ba.join(", ");                                                                                                 // 3375
				e = ea.join(", ");                                                                                                 // 3376
			}                                                                                                                   // 3377
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);                         // 3378
		};                                                                                                                   // 3379
                                                                                                                       // 3380
		/**                                                                                                                  // 3381
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);                           // 3383
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened                                                  // 3385
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name                                                                                  // 3387
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.                        // 3388
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)      // 3389
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.     // 3390
		 * @param {Object=} vars Original vars object that contains the data for parsing.                                    // 3391
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */                                                                                                                  // 3393
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {                                                                // 3394
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};                                                                                                                   // 3396
                                                                                                                       // 3397
		/**                                                                                                                  // 3398
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)                                      // 3400
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)                           // 3401
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *                                                                                                                   // 3403
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *                                                                                                                   // 3405
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {                                    // 3406
		 *      var start = target.style.width;                                                                              // 3407
		 *      return function(ratio) {                                                                                     // 3408
		 *              target.style.width = (start + value * ratio) + "px";                                                 // 3409
		 *              console.log("set width to " + target.style.width);                                                   // 3410
		 *          }                                                                                                        // 3411
		 * }, 0);                                                                                                            // 3412
		 *                                                                                                                   // 3413
		 * Then, when I do this tween, it will trigger my special property:                                                  // 3414
		 *                                                                                                                   // 3415
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});                                                               // 3416
		 *                                                                                                                   // 3417
		 * In the example, of course, we're just changing the width, but you can do anything you want.                       // 3418
		 *                                                                                                                   // 3419
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */                                                                                                                  // 3423
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {                                              // 3424
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {                               // 3425
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);                                                  // 3426
				rv.plugin = plugin;                                                                                                // 3427
				rv.setRatio = onInitTween(t, e, cssp._tween, p);                                                                   // 3428
				return rv;                                                                                                         // 3429
			}, priority:priority});                                                                                             // 3430
		};                                                                                                                   // 3431
                                                                                                                       // 3432
                                                                                                                       // 3433
                                                                                                                       // 3434
                                                                                                                       // 3435
                                                                                                                       // 3436
                                                                                                                       // 3437
		//transform-related methods and properties                                                                           // 3438
		CSSPlugin.useSVGTransformAttr = _isSafari; //Safari has some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead.
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",                                                                       // 3442
			_transformOriginProp = _checkPropPrefix("transformOrigin"),                                                         // 3443
			_supports3D = (_checkPropPrefix("perspective") !== null),                                                           // 3444
			Transform = _internals.Transform = function() {                                                                     // 3445
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;                                         // 3446
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";  // 3447
			},                                                                                                                  // 3448
			_SVGElement = window.SVGElement,                                                                                    // 3449
			_useSVGTransformAttr,                                                                                               // 3450
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.
                                                                                                                       // 3452
			_createSVG = function(type, container, attributes) {                                                                // 3453
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),                                            // 3454
					reg = /([a-z])([A-Z])/g,                                                                                          // 3455
					p;                                                                                                                // 3456
				for (p in attributes) {                                                                                            // 3457
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);                               // 3458
				}                                                                                                                  // 3459
				container.appendChild(element);                                                                                    // 3460
				return element;                                                                                                    // 3461
			},                                                                                                                  // 3462
			_docElement = _doc.documentElement,                                                                                 // 3463
			_forceSVGTransformAttr = (function() {                                                                              // 3464
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),                                                // 3466
					svg, rect, width;                                                                                                 // 3467
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway                                 // 3468
					svg = _createSVG("svg", _docElement);                                                                             // 3469
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});                                                    // 3470
					width = rect.getBoundingClientRect().width;                                                                       // 3471
					rect.style[_transformOriginProp] = "50% 50%";                                                                     // 3472
					rect.style[_transformProp] = "scaleX(0.5)";                                                                       // 3473
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);                                                                                     // 3475
				}                                                                                                                  // 3476
				return force;                                                                                                      // 3477
			})(),                                                                                                               // 3478
			_parseSVGOrigin = function(e, local, decoratee, absolute) {                                                         // 3479
				var bbox, v;                                                                                                       // 3480
				if (!absolute || !(v = absolute.split(" ")).length) {                                                              // 3481
					bbox = e.getBBox();                                                                                               // 3482
					local = _parsePosition(local).split(" ");                                                                         // 3483
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * bbox.width : parseFloat(local[0])) + bbox.x,    // 3484
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * bbox.height : parseFloat(local[1])) + bbox.y];     // 3485
				}                                                                                                                  // 3486
				decoratee.xOrigin = parseFloat(v[0]);                                                                              // 3487
				decoratee.yOrigin = parseFloat(v[1]);                                                                              // 3488
				e.setAttribute("data-svg-origin", v.join(" "));                                                                    // 3489
			},                                                                                                                  // 3490
                                                                                                                       // 3491
			/**                                                                                                                 // 3492
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element                                                                                // 3494
			 * @param {Object=} cs computed style object (optional)                                                             // 3495
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}      // 3498
			 */                                                                                                                 // 3499
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {                                             // 3500
				if (t._gsTransform && rec && !parse) {                                                                             // 3501
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}                                                                                                                  // 3503
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),                                                // 3504
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,                                                                                                    // 3506
					rnd = 100000,                                                                                                     // 3507
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,                             // 3509
					isDefault, s, m, i, n, dec, scaleX, scaleY, rotation, skewX;                                                      // 3510
				if (_transformProp) {                                                                                              // 3511
					s = _getStyle(t, _transformPropCSS, cs, true);                                                                    // 3512
				} else if (t.currentStyle) {                                                                                       // 3513
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = t.currentStyle.filter.match(_ieGetMatrixExp);                                                                 // 3515
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}                                                                                                                  // 3517
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");                                              // 3518
				tm.svg = !!(_SVGElement && typeof(t.getBBox) === "function" && t.getCTM && (!t.parentNode || (t.parentNode.getBBox && t.parentNode.getCTM))); //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object)
				if (tm.svg) {                                                                                                      // 3520
					if (isDefault && (t.style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = t.style[_transformProp];                                                                                     // 3522
						isDefault = false;                                                                                               // 3523
					}                                                                                                                 // 3524
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;                                   // 3526
					m = t.getAttribute("transform");                                                                                  // 3527
					if (isDefault && m && m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Only accept a matrix, though.
						s = m;                                                                                                           // 3529
						isDefault = 0;                                                                                                   // 3530
					}                                                                                                                 // 3531
				}                                                                                                                  // 3532
				if (!isDefault) {                                                                                                  // 3533
					//split the matrix values out into an array (m for matrix)                                                        // 3534
					m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [];                                                             // 3535
					i = m.length;                                                                                                     // 3536
					while (--i > -1) {                                                                                                // 3537
						n = Number(m[i]);                                                                                                // 3538
						m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
					}                                                                                                                 // 3540
					if (m.length === 16) {                                                                                            // 3541
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],                                                              // 3543
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],                                                                 // 3544
							a13 = m[8], a23 = m[9], a33 = m[10],                                                                            // 3545
							a14 = m[12], a24 = m[13], a34 = m[14],                                                                          // 3546
							a43 = m[11],                                                                                                    // 3547
							angle = Math.atan2(a32, a33),                                                                                   // 3548
							t1, t2, t3, t4, cos, sin;                                                                                       // 3549
                                                                                                                       // 3550
						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari               // 3551
						if (tm.zOrigin) {                                                                                                // 3552
							a34 = -tm.zOrigin;                                                                                              // 3553
							a14 = a13*a34-m[12];                                                                                            // 3554
							a24 = a23*a34-m[13];                                                                                            // 3555
							a34 = a33*a34+tm.zOrigin-m[14];                                                                                 // 3556
						}                                                                                                                // 3557
						tm.rotationX = angle * _RAD2DEG;                                                                                 // 3558
						//rotationX                                                                                                      // 3559
						if (angle) {                                                                                                     // 3560
							cos = Math.cos(-angle);                                                                                         // 3561
							sin = Math.sin(-angle);                                                                                         // 3562
							t1 = a12*cos+a13*sin;                                                                                           // 3563
							t2 = a22*cos+a23*sin;                                                                                           // 3564
							t3 = a32*cos+a33*sin;                                                                                           // 3565
							a13 = a12*-sin+a13*cos;                                                                                         // 3566
							a23 = a22*-sin+a23*cos;                                                                                         // 3567
							a33 = a32*-sin+a33*cos;                                                                                         // 3568
							a43 = a42*-sin+a43*cos;                                                                                         // 3569
							a12 = t1;                                                                                                       // 3570
							a22 = t2;                                                                                                       // 3571
							a32 = t3;                                                                                                       // 3572
						}                                                                                                                // 3573
						//rotationY                                                                                                      // 3574
						angle = Math.atan2(a13, a33);                                                                                    // 3575
						tm.rotationY = angle * _RAD2DEG;                                                                                 // 3576
						if (angle) {                                                                                                     // 3577
							cos = Math.cos(-angle);                                                                                         // 3578
							sin = Math.sin(-angle);                                                                                         // 3579
							t1 = a11*cos-a13*sin;                                                                                           // 3580
							t2 = a21*cos-a23*sin;                                                                                           // 3581
							t3 = a31*cos-a33*sin;                                                                                           // 3582
							a23 = a21*sin+a23*cos;                                                                                          // 3583
							a33 = a31*sin+a33*cos;                                                                                          // 3584
							a43 = a41*sin+a43*cos;                                                                                          // 3585
							a11 = t1;                                                                                                       // 3586
							a21 = t2;                                                                                                       // 3587
							a31 = t3;                                                                                                       // 3588
						}                                                                                                                // 3589
						//rotationZ                                                                                                      // 3590
						angle = Math.atan2(a21, a11);                                                                                    // 3591
						tm.rotation = angle * _RAD2DEG;                                                                                  // 3592
						if (angle) {                                                                                                     // 3593
							cos = Math.cos(-angle);                                                                                         // 3594
							sin = Math.sin(-angle);                                                                                         // 3595
							a11 = a11*cos+a12*sin;                                                                                          // 3596
							t2 = a21*cos+a22*sin;                                                                                           // 3597
							a22 = a21*-sin+a22*cos;                                                                                         // 3598
							a32 = a31*-sin+a32*cos;                                                                                         // 3599
							a21 = t2;                                                                                                       // 3600
						}                                                                                                                // 3601
                                                                                                                       // 3602
						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;                                                                                 // 3604
							tm.rotationY += 180;                                                                                            // 3605
						}                                                                                                                // 3606
                                                                                                                       // 3607
						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;                                          // 3608
						tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;                                          // 3609
						tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;                                          // 3610
						tm.skewX = 0;                                                                                                    // 3611
						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;                                                         // 3612
						tm.x = a14;                                                                                                      // 3613
						tm.y = a24;                                                                                                      // 3614
						tm.z = a34;                                                                                                      // 3615
						if (tm.svg) {                                                                                                    // 3616
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);                                                     // 3617
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);                                                     // 3618
						}                                                                                                                // 3619
                                                                                                                       // 3620
					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY)) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),                                                                                         // 3622
							a = k ? m[0] : 1,                                                                                               // 3623
							b = m[1] || 0,                                                                                                  // 3624
							c = m[2] || 0,                                                                                                  // 3625
							d = k ? m[3] : 1;                                                                                               // 3626
						tm.x = m[4] || 0;                                                                                                // 3627
						tm.y = m[5] || 0;                                                                                                // 3628
						scaleX = Math.sqrt(a * a + b * b);                                                                               // 3629
						scaleY = Math.sqrt(d * d + c * c);                                                                               // 3630
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;                                       // 3632
						if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {                                                             // 3633
							if (invX) {                                                                                                     // 3634
								scaleX *= -1;                                                                                                  // 3635
								skewX += (rotation <= 0) ? 180 : -180;                                                                         // 3636
								rotation += (rotation <= 0) ? 180 : -180;                                                                      // 3637
							} else {                                                                                                        // 3638
								scaleY *= -1;                                                                                                  // 3639
								skewX += (skewX <= 0) ? 180 : -180;                                                                            // 3640
							}                                                                                                               // 3641
						}                                                                                                                // 3642
						tm.scaleX = scaleX;                                                                                              // 3643
						tm.scaleY = scaleY;                                                                                              // 3644
						tm.rotation = rotation;                                                                                          // 3645
						tm.skewX = skewX;                                                                                                // 3646
						if (_supports3D) {                                                                                               // 3647
							tm.rotationX = tm.rotationY = tm.z = 0;                                                                         // 3648
							tm.perspective = defaultTransformPerspective;                                                                   // 3649
							tm.scaleZ = 1;                                                                                                  // 3650
						}                                                                                                                // 3651
						if (tm.svg) {                                                                                                    // 3652
							tm.x -= tm.xOrigin - (tm.xOrigin * a - tm.yOrigin * b);                                                         // 3653
							tm.y -= tm.yOrigin - (tm.yOrigin * d - tm.xOrigin * c);                                                         // 3654
						}                                                                                                                // 3655
					}                                                                                                                 // 3656
					tm.zOrigin = zOrigin;                                                                                             // 3657
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {                                                                                                   // 3659
						if (tm[i] < min) if (tm[i] > -min) {                                                                             // 3660
							tm[i] = 0;                                                                                                      // 3661
						}                                                                                                                // 3662
					}                                                                                                                 // 3663
				}                                                                                                                  // 3664
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective);
				if (rec) {                                                                                                         // 3666
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {                                                           // 3669
							_removeProp(t.style, _transformProp);                                                                           // 3670
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {                                               // 3671
							t.removeAttribute("transform");                                                                                 // 3672
						}                                                                                                                // 3673
					}                                                                                                                 // 3674
				}                                                                                                                  // 3675
				return tm;                                                                                                         // 3676
			},                                                                                                                  // 3677
                                                                                                                       // 3678
			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {                                                                                // 3680
				var t = this.data, //refers to the element's _gsTransform object                                                   // 3681
					ang = -t.rotation * _DEG2RAD,                                                                                     // 3682
					skew = ang + t.skewX * _DEG2RAD,                                                                                  // 3683
					rnd = 100000,                                                                                                     // 3684
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,                                                                 // 3685
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,                                                                 // 3686
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,                                                               // 3687
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,                                                                // 3688
					style = this.t.style,                                                                                             // 3689
					cs = this.t.currentStyle,                                                                                         // 3690
					filters, val;                                                                                                     // 3691
				if (!cs) {                                                                                                         // 3692
					return;                                                                                                           // 3693
				}                                                                                                                  // 3694
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;                                                                                                            // 3696
				c = -val;                                                                                                          // 3697
				filters = cs.filter;                                                                                               // 3698
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight                     // 3699
				var w = this.t.offsetWidth,                                                                                        // 3700
					h = this.t.offsetHeight,                                                                                          // 3701
					clip = (cs.position !== "absolute"),                                                                              // 3702
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,             // 3703
					ox = t.x + (w * t.xPercent / 100),                                                                                // 3704
					oy = t.y + (h * t.yPercent / 100),                                                                                // 3705
					dx, dy;                                                                                                           // 3706
                                                                                                                       // 3707
				//if transformOrigin is being used, adjust the offset x and y                                                      // 3708
				if (t.ox != null) {                                                                                                // 3709
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;                                                                  // 3710
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;                                                                  // 3711
					ox += dx - (dx * a + dy * b);                                                                                     // 3712
					oy += dy - (dx * c + dy * d);                                                                                     // 3713
				}                                                                                                                  // 3714
                                                                                                                       // 3715
				if (!clip) {                                                                                                       // 3716
					m += ", sizingMethod='auto expand')";                                                                             // 3717
				} else {                                                                                                           // 3718
					dx = (w / 2);                                                                                                     // 3719
					dy = (h / 2);                                                                                                     // 3720
					//translate to ensure that transformations occur around the correct origin (default is center).                   // 3721
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";                     // 3722
				}                                                                                                                  // 3723
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {                                                // 3724
					style.filter = filters.replace(_ieSetMatrixExp, m);                                                               // 3725
				} else {                                                                                                           // 3726
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}                                                                                                                  // 3728
                                                                                                                       // 3729
				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");                                                                                  // 3732
				}                                                                                                                  // 3733
                                                                                                                       // 3734
				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {                                                                                                       // 3736
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;                                                                                                 // 3738
					dx = t.ieOffsetX || 0;                                                                                            // 3739
					dy = t.ieOffsetY || 0;                                                                                            // 3740
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);                           // 3741
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);                           // 3742
					for (i = 0; i < 4; i++) {                                                                                         // 3743
						prop = _margins[i];                                                                                              // 3744
						marg = cs[prop];                                                                                                 // 3745
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {                                                                                           // 3748
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {                                                                                                         // 3750
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;                                                            // 3751
						}                                                                                                                // 3752
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";                    // 3753
					}                                                                                                                 // 3754
				}                                                                                                                  // 3755
			},                                                                                                                  // 3756
                                                                                                                       // 3757
			/* translates a super small decimal to a string WITHOUT scientific notation                                         // 3758
			_safeDecimal = function(n) {                                                                                        // 3759
				var s = (n < 0 ? -n : n) + "",                                                                                     // 3760
					a = s.split("e-");                                                                                                // 3761
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");           // 3762
			},                                                                                                                  // 3763
			*/                                                                                                                  // 3764
                                                                                                                       // 3765
			_set3DTransformRatio = _internals.set3DTransformRatio = function(v) {                                               // 3766
				var t = this.data, //refers to the element's _gsTransform object                                                   // 3767
					style = this.t.style,                                                                                             // 3768
					angle = t.rotation * _DEG2RAD,                                                                                    // 3769
					sx = t.scaleX,                                                                                                    // 3770
					sy = t.scaleY,                                                                                                    // 3771
					sz = t.scaleZ,                                                                                                    // 3772
					x = t.x,                                                                                                          // 3773
					y = t.y,                                                                                                          // 3774
					z = t.z,                                                                                                          // 3775
					perspective = t.perspective,                                                                                      // 3776
					a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,                                                       // 3777
					zOrigin, min, cos, sin, t1, t2, transform, comma, zero;                                                           // 3778
				if (v === 1 || v === 0 || !t.force3D) if (t.force3D !== true) if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !z && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.
					_set2DTransformRatio.call(this, v);                                                                               // 3780
					return;                                                                                                           // 3781
				}                                                                                                                  // 3782
				if (_isFirefox) {                                                                                                  // 3783
					min = 0.0001;                                                                                                     // 3784
					if (sx < min && sx > -min) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
						sx = sz = 0.00002;                                                                                               // 3786
					}                                                                                                                 // 3787
					if (sy < min && sy > -min) {                                                                                      // 3788
						sy = sz = 0.00002;                                                                                               // 3789
					}                                                                                                                 // 3790
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;                                                                                                 // 3792
					}                                                                                                                 // 3793
				}                                                                                                                  // 3794
				if (angle || t.skewX) {                                                                                            // 3795
					cos = a11 = Math.cos(angle);                                                                                      // 3796
					sin = a21 = Math.sin(angle);                                                                                      // 3797
					if (t.skewX) {                                                                                                    // 3798
						angle -= t.skewX * _DEG2RAD;                                                                                     // 3799
						cos = Math.cos(angle);                                                                                           // 3800
						sin = Math.sin(angle);                                                                                           // 3801
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(t.skewX * _DEG2RAD);                                                                              // 3803
							t1 = Math.sqrt(1 + t1 * t1);                                                                                    // 3804
							cos *= t1;                                                                                                      // 3805
							sin *= t1;                                                                                                      // 3806
						}                                                                                                                // 3807
					}                                                                                                                 // 3808
					a12 = -sin;                                                                                                       // 3809
					a22 = cos;                                                                                                        // 3810
                                                                                                                       // 3811
				} else if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !t.svg) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;                                                                                                           // 3814
				} else {                                                                                                           // 3815
					a11 = a22 = 1;                                                                                                    // 3816
					a12 = a21 = 0;                                                                                                    // 3817
				}                                                                                                                  // 3818
				// KEY  INDEX   AFFECTS                                                                                            // 3819
				// a11  0       rotation, rotationY, scaleX                                                                        // 3820
				// a21  1       rotation, rotationY, scaleX                                                                        // 3821
				// a31  2       rotationY, scaleX                                                                                  // 3822
				// a41  3       rotationY, scaleX                                                                                  // 3823
				// a12  4       rotation, skewX, rotationX, scaleY                                                                 // 3824
				// a22  5       rotation, skewX, rotationX, scaleY                                                                 // 3825
				// a32  6       rotationX, scaleY                                                                                  // 3826
				// a42  7       rotationX, scaleY                                                                                  // 3827
				// a13  8       rotationY, rotationX, scaleZ                                                                       // 3828
				// a23  9       rotationY, rotationX, scaleZ                                                                       // 3829
				// a33  10      rotationY, rotationX, scaleZ                                                                       // 3830
				// a43  11      rotationY, rotationX, perspective, scaleZ                                                          // 3831
				// a14  12      x, zOrigin, svgOrigin                                                                              // 3832
				// a24  13      y, zOrigin, svgOrigin                                                                              // 3833
				// a34  14      z, zOrigin                                                                                         // 3834
				// a44  15                                                                                                         // 3835
				// rotation: Math.atan2(a21, a11)                                                                                  // 3836
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))                                                       // 3837
				// rotationX: Math.atan2(a32, a33)                                                                                 // 3838
				a33 = 1;                                                                                                           // 3839
				a13 = a23 = a31 = a32 = a41 = a42 = 0;                                                                             // 3840
				a43 = (perspective) ? -1 / perspective : 0;                                                                        // 3841
				zOrigin = t.zOrigin;                                                                                               // 3842
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.                         // 3843
				comma = ",";                                                                                                       // 3844
				zero = "0";                                                                                                        // 3845
				angle = t.rotationY * _DEG2RAD;                                                                                    // 3846
				if (angle) {                                                                                                       // 3847
					cos = Math.cos(angle);                                                                                            // 3848
					sin = Math.sin(angle);                                                                                            // 3849
					a31 = -sin;                                                                                                       // 3850
					a41 = a43*-sin;                                                                                                   // 3851
					a13 = a11*sin;                                                                                                    // 3852
					a23 = a21*sin;                                                                                                    // 3853
					a33 = cos;                                                                                                        // 3854
					a43 *= cos;                                                                                                       // 3855
					a11 *= cos;                                                                                                       // 3856
					a21 *= cos;                                                                                                       // 3857
				}                                                                                                                  // 3858
				angle = t.rotationX * _DEG2RAD;                                                                                    // 3859
				if (angle) {                                                                                                       // 3860
					cos = Math.cos(angle);                                                                                            // 3861
					sin = Math.sin(angle);                                                                                            // 3862
					t1 = a12*cos+a13*sin;                                                                                             // 3863
					t2 = a22*cos+a23*sin;                                                                                             // 3864
					a32 = a33*sin;                                                                                                    // 3865
					a42 = a43*sin;                                                                                                    // 3866
					a13 = a12*-sin+a13*cos;                                                                                           // 3867
					a23 = a22*-sin+a23*cos;                                                                                           // 3868
					a33 = a33*cos;                                                                                                    // 3869
					a43 = a43*cos;                                                                                                    // 3870
					a12 = t1;                                                                                                         // 3871
					a22 = t2;                                                                                                         // 3872
				}                                                                                                                  // 3873
				if (sz !== 1) {                                                                                                    // 3874
					a13*=sz;                                                                                                          // 3875
					a23*=sz;                                                                                                          // 3876
					a33*=sz;                                                                                                          // 3877
					a43*=sz;                                                                                                          // 3878
				}                                                                                                                  // 3879
				if (sy !== 1) {                                                                                                    // 3880
					a12*=sy;                                                                                                          // 3881
					a22*=sy;                                                                                                          // 3882
					a32*=sy;                                                                                                          // 3883
					a42*=sy;                                                                                                          // 3884
				}                                                                                                                  // 3885
				if (sx !== 1) {                                                                                                    // 3886
					a11*=sx;                                                                                                          // 3887
					a21*=sx;                                                                                                          // 3888
					a31*=sx;                                                                                                          // 3889
					a41*=sx;                                                                                                          // 3890
				}                                                                                                                  // 3891
                                                                                                                       // 3892
				if (zOrigin || t.svg) {                                                                                            // 3893
					if (zOrigin) {                                                                                                    // 3894
						x += a13*-zOrigin;                                                                                               // 3895
						y += a23*-zOrigin;                                                                                               // 3896
						z += a33*-zOrigin+zOrigin;                                                                                       // 3897
					}                                                                                                                 // 3898
					if (t.svg) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually               // 3899
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12);                                                            // 3900
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22);                                                            // 3901
					}                                                                                                                 // 3902
					if (x < min && x > -min) {                                                                                        // 3903
						x = zero;                                                                                                        // 3904
					}                                                                                                                 // 3905
					if (y < min && y > -min) {                                                                                        // 3906
						y = zero;                                                                                                        // 3907
					}                                                                                                                 // 3908
					if (z < min && z > -min) {                                                                                        // 3909
						z = 0; //don't use string because we calculate perspective later and need the number.                            // 3910
					}                                                                                                                 // 3911
				}                                                                                                                  // 3912
                                                                                                                       // 3913
				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (t.rotationX || t.rotationY) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {                                                                                                           // 3921
					transform += ",0,0,0,0,1,0,";                                                                                     // 3922
				}                                                                                                                  // 3923
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";               // 3924
                                                                                                                       // 3925
				style[_transformProp] = transform;                                                                                 // 3926
			},                                                                                                                  // 3927
                                                                                                                       // 3928
			_set2DTransformRatio = _internals.set2DTransformRatio = function(v) {                                               // 3929
				var t = this.data, //refers to the element's _gsTransform object                                                   // 3930
					targ = this.t,                                                                                                    // 3931
					style = targ.style,                                                                                               // 3932
					x = t.x,                                                                                                          // 3933
					y = t.y,                                                                                                          // 3934
					ang, skew, rnd, sx, sy, a, b, c, d, matrix, min, t1;                                                              // 3935
				if ((t.rotationX || t.rotationY || t.z || t.force3D === true || (t.force3D === "auto" && v !== 1 && v !== 0)) && !(t.svg && _useSVGTransformAttr) && _supports3D) { //if a 3D tween begins while a 2D one is running, we need to kick the rendering over to the 3D method. For example, imagine a yoyo-ing, infinitely repeating scale tween running, and then the object gets rotated in 3D space with a different tween.
					this.setRatio = _set3DTransformRatio;                                                                             // 3937
					_set3DTransformRatio.call(this, v);                                                                               // 3938
					return;                                                                                                           // 3939
				}                                                                                                                  // 3940
				sx = t.scaleX;                                                                                                     // 3941
				sy = t.scaleY;                                                                                                     // 3942
				if (t.rotation || t.skewX || t.svg) {                                                                              // 3943
					ang = t.rotation * _DEG2RAD;                                                                                      // 3944
					skew = t.skewX * _DEG2RAD;                                                                                        // 3945
					rnd = 100000;                                                                                                     // 3946
					a = Math.cos(ang) * sx;                                                                                           // 3947
					b = Math.sin(ang) * sx;                                                                                           // 3948
					c = Math.sin(ang - skew) * -sy;                                                                                   // 3949
					d = Math.cos(ang - skew) * sy;                                                                                    // 3950
					if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);                                                                                             // 3952
						t1 = Math.sqrt(1 + t1 * t1);                                                                                     // 3953
						c *= t1;                                                                                                         // 3954
						d *= t1;                                                                                                         // 3955
					}                                                                                                                 // 3956
					if (t.svg) {                                                                                                      // 3957
						x += t.xOrigin - (t.xOrigin * a + t.yOrigin * c);                                                                // 3958
						y += t.yOrigin - (t.xOrigin * b + t.yOrigin * d);                                                                // 3959
						min = 0.000001;                                                                                                  // 3960
						if (x < min) if (x > -min) {                                                                                     // 3961
							x = 0;                                                                                                          // 3962
						}                                                                                                                // 3963
						if (y < min) if (y > -min) {                                                                                     // 3964
							y = 0;                                                                                                          // 3965
						}                                                                                                                // 3966
					}                                                                                                                 // 3967
					matrix = (((a * rnd) | 0) / rnd) + "," + (((b * rnd) | 0) / rnd) + "," + (((c * rnd) | 0) / rnd) + "," + (((d * rnd) | 0) / rnd) + "," + x + "," + y + ")";
					if (t.svg && _useSVGTransformAttr) {                                                                              // 3969
						targ.setAttribute("transform", "matrix(" + matrix);                                                              // 3970
					} else {                                                                                                          // 3971
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + matrix;
					}                                                                                                                 // 3974
				} else {                                                                                                           // 3975
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}                                                                                                                  // 3977
			};                                                                                                                  // 3978
                                                                                                                       // 3979
		p = Transform.prototype;                                                                                             // 3980
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;                                                                                  // 3982
                                                                                                                       // 3983
		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;                                                                                   // 3986
			var m1 = cssp._transform = _getTransform(t, _cs, true, vars.parseTransform),                                        // 3987
				style = t.style,                                                                                                   // 3988
				min = 0.000001,                                                                                                    // 3989
				i = _transformProps.length,                                                                                        // 3990
				v = vars,                                                                                                          // 3991
				endRotations = {},                                                                                                 // 3992
				m2, skewY, copy, orig, has3D, hasChange, dr;                                                                       // 3993
			if (typeof(v.transform) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = v.transform;                                                                                // 3996
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";                                                                                        // 3998
				_doc.body.appendChild(_tempDiv);                                                                                   // 3999
				m2 = _getTransform(_tempDiv, null, false);                                                                         // 4000
				_doc.body.removeChild(_tempDiv);                                                                                   // 4001
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),                                        // 4003
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),                                             // 4004
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),                                                                            // 4005
					x:_parseVal(v.x, m1.x),                                                                                           // 4006
					y:_parseVal(v.y, m1.y),                                                                                           // 4007
					z:_parseVal(v.z, m1.z),                                                                                           // 4008
					xPercent:_parseVal(v.xPercent, m1.xPercent),                                                                      // 4009
					yPercent:_parseVal(v.yPercent, m1.yPercent),                                                                      // 4010
					perspective:_parseVal(v.transformPerspective, m1.perspective)};                                                   // 4011
				dr = v.directionalRotation;                                                                                        // 4012
				if (dr != null) {                                                                                                  // 4013
					if (typeof(dr) === "object") {                                                                                    // 4014
						for (copy in dr) {                                                                                               // 4015
							v[copy] = dr[copy];                                                                                             // 4016
						}                                                                                                                // 4017
					} else {                                                                                                          // 4018
						v.rotation = dr;                                                                                                 // 4019
					}                                                                                                                 // 4020
				}                                                                                                                  // 4021
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {                                                         // 4022
					m2.x = 0;                                                                                                         // 4023
					m2.xPercent = _parseVal(v.x, m1.xPercent);                                                                        // 4024
				}                                                                                                                  // 4025
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {                                                         // 4026
					m2.y = 0;                                                                                                         // 4027
					m2.yPercent = _parseVal(v.y, m1.yPercent);                                                                        // 4028
				}                                                                                                                  // 4029
                                                                                                                       // 4030
				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {                                                                                                 // 4032
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}                                                                                                                  // 4035
				m2.skewX = (v.skewX == null) ? m1.skewX : _parseAngle(v.skewX, m1.skewX);                                          // 4036
                                                                                                                       // 4037
				//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
				m2.skewY = (v.skewY == null) ? m1.skewY : _parseAngle(v.skewY, m1.skewY);                                          // 4039
				if ((skewY = m2.skewY - m1.skewY)) {                                                                               // 4040
					m2.skewX += skewY;                                                                                                // 4041
					m2.rotation += skewY;                                                                                             // 4042
				}                                                                                                                  // 4043
			}                                                                                                                   // 4044
			if (_supports3D && v.force3D != null) {                                                                             // 4045
				m1.force3D = v.force3D;                                                                                            // 4046
				hasChange = true;                                                                                                  // 4047
			}                                                                                                                   // 4048
                                                                                                                       // 4049
			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;                                               // 4050
                                                                                                                       // 4051
			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {                                                                                    // 4053
				m2.scaleZ = 1; //no need to tween scaleZ.                                                                          // 4054
			}                                                                                                                   // 4055
                                                                                                                       // 4056
			while (--i > -1) {                                                                                                  // 4057
				p = _transformProps[i];                                                                                            // 4058
				orig = m2[p] - m1[p];                                                                                              // 4059
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {                                            // 4060
					hasChange = true;                                                                                                 // 4061
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);                                                                    // 4062
					if (p in endRotations) {                                                                                          // 4063
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}                                                                                                                 // 4065
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()                                                       // 4066
					pt.plugin = plugin;                                                                                               // 4067
					cssp._overwriteProps.push(pt.n);                                                                                  // 4068
				}                                                                                                                  // 4069
			}                                                                                                                   // 4070
                                                                                                                       // 4071
			orig = v.transformOrigin;                                                                                           // 4072
			if (m1.svg && (orig || v.svgOrigin)) {                                                                              // 4073
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin);                                                         // 4074
				pt = new CSSPropTween(m1, "xOrigin", m1.xOrigin, m2.xOrigin - m1.xOrigin, pt, -1, "transformOrigin");              // 4075
				pt.b = m1.xOrigin;                                                                                                 // 4076
				pt.e = pt.xs0 = m2.xOrigin;                                                                                        // 4077
				pt = new CSSPropTween(m1, "yOrigin", m1.yOrigin, m2.yOrigin - m1.yOrigin, pt, -1, "transformOrigin");              // 4078
				pt.b = m1.yOrigin;                                                                                                 // 4079
				pt.e = pt.xs0 = m2.yOrigin;                                                                                        // 4080
				orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}                                                                                                                   // 4082
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {                                                                                              // 4084
					hasChange = true;                                                                                                 // 4085
					p = _transformOriginProp;                                                                                         // 4086
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors                    // 4087
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin");                                                 // 4088
					pt.b = style[p];                                                                                                  // 4089
					pt.plugin = plugin;                                                                                               // 4090
					if (_supports3D) {                                                                                                // 4091
						copy = m1.zOrigin;                                                                                               // 4092
						orig = orig.split(" ");                                                                                          // 4093
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;                                                                                                     // 4097
						pt.xs0 = pt.e = m1.zOrigin;                                                                                      // 4098
					} else {                                                                                                          // 4099
						pt.xs0 = pt.e = orig;                                                                                            // 4100
					}                                                                                                                 // 4101
                                                                                                                       // 4102
				//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {                                                                                                           // 4104
					_parsePosition(orig + "", m1);                                                                                    // 4105
				}                                                                                                                  // 4106
			}                                                                                                                   // 4107
			if (hasChange) {                                                                                                    // 4108
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}                                                                                                                   // 4110
			return pt;                                                                                                          // 4111
		}, prefix:true});                                                                                                    // 4112
                                                                                                                       // 4113
		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});
                                                                                                                       // 4115
		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {        // 4116
			e = this.format(e);                                                                                                 // 4117
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],      // 4118
				style = t.style,                                                                                                   // 4119
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;                                               // 4120
			w = parseFloat(t.offsetWidth);                                                                                      // 4121
			h = parseFloat(t.offsetHeight);                                                                                     // 4122
			ea1 = e.split(" ");                                                                                                 // 4123
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix                                                     // 4125
					props[i] = _checkPropPrefix(props[i]);                                                                            // 4126
				}                                                                                                                  // 4127
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");                                                              // 4128
				if (bs.indexOf(" ") !== -1) {                                                                                      // 4129
					bs2 = bs.split(" ");                                                                                              // 4130
					bs = bs2[0];                                                                                                      // 4131
					bs2 = bs2[1];                                                                                                     // 4132
				}                                                                                                                  // 4133
				es = es2 = ea1[i];                                                                                                 // 4134
				bn = parseFloat(bs);                                                                                               // 4135
				bsfx = bs.substr((bn + "").length);                                                                                // 4136
				rel = (es.charAt(1) === "=");                                                                                      // 4137
				if (rel) {                                                                                                         // 4138
					en = parseInt(es.charAt(0)+"1", 10);                                                                              // 4139
					es = es.substr(2);                                                                                                // 4140
					en *= parseFloat(es);                                                                                             // 4141
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";                                                      // 4142
				} else {                                                                                                           // 4143
					en = parseFloat(es);                                                                                              // 4144
					esfx = es.substr((en + "").length);                                                                               // 4145
				}                                                                                                                  // 4146
				if (esfx === "") {                                                                                                 // 4147
					esfx = _suffixMap[p] || bsfx;                                                                                     // 4148
				}                                                                                                                  // 4149
				if (esfx !== bsfx) {                                                                                               // 4150
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number                                                // 4152
					if (esfx === "%") {                                                                                               // 4153
						bs = (hn / w * 100) + "%";                                                                                       // 4154
						bs2 = (vn / h * 100) + "%";                                                                                      // 4155
					} else if (esfx === "em") {                                                                                       // 4156
						em = _convertToPixels(t, "borderLeft", 1, "em");                                                                 // 4157
						bs = (hn / em) + "em";                                                                                           // 4158
						bs2 = (vn / em) + "em";                                                                                          // 4159
					} else {                                                                                                          // 4160
						bs = hn + "px";                                                                                                  // 4161
						bs2 = vn + "px";                                                                                                 // 4162
					}                                                                                                                 // 4163
					if (rel) {                                                                                                        // 4164
						es = (parseFloat(bs) + en) + esfx;                                                                               // 4165
						es2 = (parseFloat(bs2) + en) + esfx;                                                                             // 4166
					}                                                                                                                 // 4167
				}                                                                                                                  // 4168
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);                             // 4169
			}                                                                                                                   // 4170
			return pt;                                                                                                          // 4171
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});                                           // 4172
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {  // 4173
			var bp = "background-position",                                                                                     // 4174
				cs = (_cs || _getComputedStyle(t, null)),                                                                          // 4175
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),                                                                                               // 4177
				ba, ea, i, pct, overlap, src;                                                                                      // 4178
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1)) {                                                        // 4179
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");                                                        // 4180
				if (src && src !== "none") {                                                                                       // 4181
					ba = bs.split(" ");                                                                                               // 4182
					ea = es.split(" ");                                                                                               // 4183
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;                                                                                                            // 4185
					while (--i > -1) {                                                                                                // 4186
						bs = ba[i];                                                                                                      // 4187
						pct = (bs.indexOf("%") !== -1);                                                                                  // 4188
						if (pct !== (ea[i].indexOf("%") !== -1)) {                                                                       // 4189
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;                        // 4190
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";                 // 4191
						}                                                                                                                // 4192
					}                                                                                                                 // 4193
					bs = ba.join(" ");                                                                                                // 4194
				}                                                                                                                  // 4195
			}                                                                                                                   // 4196
			return this.parseComplex(t.style, bs, es, pt, plugin);                                                              // 4197
		}, formatter:_parsePosition});                                                                                       // 4198
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:_parsePosition});                       // 4199
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});                                       // 4200
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});                             // 4201
		_registerComplexSpecialProp("transformStyle", {prefix:true});                                                        // 4202
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});                                                    // 4203
		_registerComplexSpecialProp("userSelect", {prefix:true});                                                            // 4204
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});     // 4205
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;                                                                                                   // 4208
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;                                                                                               // 4210
				delim = _ieVers < 8 ? " " : ",";                                                                                   // 4211
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";               // 4212
				e = this.format(e).split(",").join(delim);                                                                         // 4213
			} else {                                                                                                            // 4214
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));                                                      // 4215
				e = this.format(e);                                                                                                // 4216
			}                                                                                                                   // 4217
			return this.parseComplex(t.style, b, e, pt, plugin);                                                                // 4218
		}});                                                                                                                 // 4219
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});                // 4220
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {   // 4222
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color:true, formatter:function(v) {                                                                              // 4224
				var a = v.split(" ");                                                                                              // 4225
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];                                 // 4226
			}});                                                                                                                // 4227
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {               // 4229
			var s = t.style,                                                                                                    // 4230
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";                                                              // 4231
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);                                            // 4232
		}});                                                                                                                 // 4233
                                                                                                                       // 4234
		//opacity-related                                                                                                    // 4235
		var _setIEOpacityRatio = function(v) {                                                                               // 4236
				var t = this.t, //refers to the element's style property                                                           // 4237
					filters = t.filter || _getStyle(this.data, "filter") || "",                                                       // 4238
					val = (this.s + this.c * v) | 0,                                                                                  // 4239
					skip;                                                                                                             // 4240
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) { // 4242
						t.removeAttribute("filter");                                                                                     // 4243
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {                                                                                                          // 4245
						t.filter = filters.replace(_alphaFilterExp, "");                                                                 // 4246
						skip = true;                                                                                                     // 4247
					}                                                                                                                 // 4248
				}                                                                                                                  // 4249
				if (!skip) {                                                                                                       // 4250
					if (this.xn1) {                                                                                                   // 4251
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}                                                                                                                 // 4253
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}                                                                                                                // 4257
					} else {                                                                                                          // 4258
						t.filter = filters.replace(_opacityExp, "opacity=" + val);                                                       // 4259
					}                                                                                                                 // 4260
				}                                                                                                                  // 4261
			};                                                                                                                  // 4262
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),                                                       // 4264
				style = t.style,                                                                                                   // 4265
				isAutoAlpha = (p === "autoAlpha");                                                                                 // 4266
			if (typeof(e) === "string" && e.charAt(1) === "=") {                                                                // 4267
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;                                                // 4268
			}                                                                                                                   // 4269
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;                                                                                                             // 4271
			}                                                                                                                   // 4272
			if (_supportsOpacity) {                                                                                             // 4273
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);                                                             // 4274
			} else {                                                                                                            // 4275
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);                                               // 4276
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.                                                                       // 4278
				pt.type = 2;                                                                                                       // 4279
				pt.b = "alpha(opacity=" + pt.s + ")";                                                                              // 4280
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";                                                                     // 4281
				pt.data = t;                                                                                                       // 4282
				pt.plugin = plugin;                                                                                                // 4283
				pt.setRatio = _setIEOpacityRatio;                                                                                  // 4284
			}                                                                                                                   // 4285
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";                                                                                                // 4288
				cssp._overwriteProps.push(pt.n);                                                                                   // 4289
				cssp._overwriteProps.push(p);                                                                                      // 4290
			}                                                                                                                   // 4291
			return pt;                                                                                                          // 4292
		}});                                                                                                                 // 4293
                                                                                                                       // 4294
                                                                                                                       // 4295
		var _removeProp = function(s, p) {                                                                                   // 4296
				if (p) {                                                                                                           // 4297
					if (s.removeProperty) {                                                                                           // 4298
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;                                                                                                    // 4300
						}                                                                                                                // 4301
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());                                                      // 4302
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"                         // 4303
						s.removeAttribute(p);                                                                                            // 4304
					}                                                                                                                 // 4305
				}                                                                                                                  // 4306
			},                                                                                                                  // 4307
			_setClassNameRatio = function(v) {                                                                                  // 4308
				this.t._gsClassPT = this;                                                                                          // 4309
				if (v === 1 || v === 0) {                                                                                          // 4310
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);                                                        // 4311
					var mpt = this.data, //first MiniPropTween                                                                        // 4312
						s = this.t.style;                                                                                                // 4313
					while (mpt) {                                                                                                     // 4314
						if (!mpt.v) {                                                                                                    // 4315
							_removeProp(s, mpt.p);                                                                                          // 4316
						} else {                                                                                                         // 4317
							s[mpt.p] = mpt.v;                                                                                               // 4318
						}                                                                                                                // 4319
						mpt = mpt._next;                                                                                                 // 4320
					}                                                                                                                 // 4321
					if (v === 1 && this.t._gsClassPT === this) {                                                                      // 4322
						this.t._gsClassPT = null;                                                                                        // 4323
					}                                                                                                                 // 4324
				} else if (this.t.getAttribute("class") !== this.e) {                                                              // 4325
					this.t.setAttribute("class", this.e);                                                                             // 4326
				}                                                                                                                  // 4327
			};                                                                                                                  // 4328
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {                         // 4329
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,                                                                                         // 4331
				difData, bs, cnpt, cnptLookup, mpt;                                                                                // 4332
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);                                                       // 4333
			pt.setRatio = _setClassNameRatio;                                                                                   // 4334
			pt.pr = -11;                                                                                                        // 4335
			_hasPriority = true;                                                                                                // 4336
			pt.b = b;                                                                                                           // 4337
			bs = _getAllStyles(t, _cs);                                                                                         // 4338
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;                                                                                                // 4340
			if (cnpt) {                                                                                                         // 4341
				cnptLookup = {};                                                                                                   // 4342
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {                                                                                                      // 4344
					cnptLookup[mpt.p] = 1;                                                                                            // 4345
					mpt = mpt._next;                                                                                                  // 4346
				}                                                                                                                  // 4347
				cnpt.setRatio(1);                                                                                                  // 4348
			}                                                                                                                   // 4349
			t._gsClassPT = pt;                                                                                                  // 4350
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			if (cssp._tween._duration) { //if it's a zero-duration tween, there's no need to tween anything or parse the data. In fact, if we switch classes temporarily (which we must do for proper parsing) and the class has a transition applied, it could cause a quick flash to the end state and back again initially in some browsers.
				t.setAttribute("class", pt.e);                                                                                     // 4353
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);                                                      // 4354
				t.setAttribute("class", b);                                                                                        // 4355
				pt.data = difData.firstMPT;                                                                                        // 4356
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			}                                                                                                                   // 4359
			return pt;                                                                                                          // 4360
		}});                                                                                                                 // 4361
                                                                                                                       // 4362
                                                                                                                       // 4363
		var _setClearPropsRatio = function(v) {                                                                              // 4364
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,                                                                                              // 4366
					transformParse = _specialProps.transform.parse,                                                                   // 4367
					a, p, i, clearTransform;                                                                                          // 4368
				if (this.e === "all") {                                                                                            // 4369
					s.cssText = "";                                                                                                   // 4370
					clearTransform = true;                                                                                            // 4371
				} else {                                                                                                           // 4372
					a = this.e.split(" ").join("").split(",");                                                                        // 4373
					i = a.length;                                                                                                     // 4374
					while (--i > -1) {                                                                                                // 4375
						p = a[i];                                                                                                        // 4376
						if (_specialProps[p]) {                                                                                          // 4377
							if (_specialProps[p].parse === transformParse) {                                                                // 4378
								clearTransform = true;                                                                                         // 4379
							} else {                                                                                                        // 4380
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}                                                                                                               // 4382
						}                                                                                                                // 4383
						_removeProp(s, p);                                                                                               // 4384
					}                                                                                                                 // 4385
				}                                                                                                                  // 4386
				if (clearTransform) {                                                                                              // 4387
					_removeProp(s, _transformProp);                                                                                   // 4388
					if (this.t._gsTransform) {                                                                                        // 4389
						delete this.t._gsTransform;                                                                                      // 4390
					}                                                                                                                 // 4391
				}                                                                                                                  // 4392
                                                                                                                       // 4393
			}                                                                                                                   // 4394
		};                                                                                                                   // 4395
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {                                      // 4396
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);                                                                           // 4397
			pt.setRatio = _setClearPropsRatio;                                                                                  // 4398
			pt.e = e;                                                                                                           // 4399
			pt.pr = -10;                                                                                                        // 4400
			pt.data = cssp._tween;                                                                                              // 4401
			_hasPriority = true;                                                                                                // 4402
			return pt;                                                                                                          // 4403
		}});                                                                                                                 // 4404
                                                                                                                       // 4405
		p = "bezier,throwProps,physicsProps,physics2D".split(",");                                                           // 4406
		i = p.length;                                                                                                        // 4407
		while (i--) {                                                                                                        // 4408
			_registerPluginProp(p[i]);                                                                                          // 4409
		}                                                                                                                    // 4410
                                                                                                                       // 4411
                                                                                                                       // 4412
                                                                                                                       // 4413
                                                                                                                       // 4414
                                                                                                                       // 4415
                                                                                                                       // 4416
                                                                                                                       // 4417
                                                                                                                       // 4418
		p = CSSPlugin.prototype;                                                                                             // 4419
		p._firstPT = p._lastParsedTransform = p._transform = null;                                                           // 4420
                                                                                                                       // 4421
		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc. // 4422
		p._onInitTween = function(target, vars, tween) {                                                                     // 4423
			if (!target.nodeType) { //css is only for dom elements                                                              // 4424
				return false;                                                                                                      // 4425
			}                                                                                                                   // 4426
			this._target = target;                                                                                              // 4427
			this._tween = tween;                                                                                                // 4428
			this._vars = vars;                                                                                                  // 4429
			_autoRound = vars.autoRound;                                                                                        // 4430
			_hasPriority = false;                                                                                               // 4431
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;                                                                 // 4432
			_cs = _getComputedStyle(target, "");                                                                                // 4433
			_overwriteProps = this._overwriteProps;                                                                             // 4434
			var style = target.style,                                                                                           // 4435
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;                                                                // 4436
			if (_reqSafariFix) if (style.zIndex === "") {                                                                       // 4437
				v = _getStyle(target, "zIndex", _cs);                                                                              // 4438
				if (v === "auto" || v === "") {                                                                                    // 4439
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);                                                                             // 4441
				}                                                                                                                  // 4442
			}                                                                                                                   // 4443
                                                                                                                       // 4444
			if (typeof(vars) === "string") {                                                                                    // 4445
				first = style.cssText;                                                                                             // 4446
				v = _getAllStyles(target, _cs);                                                                                    // 4447
				style.cssText = first + ";" + vars;                                                                                // 4448
				v = _cssDif(target, v, _getAllStyles(target)).difs;                                                                // 4449
				if (!_supportsOpacity && _opacityValExp.test(vars)) {                                                              // 4450
					v.opacity = parseFloat( RegExp.$1 );                                                                              // 4451
				}                                                                                                                  // 4452
				vars = v;                                                                                                          // 4453
				style.cssText = first;                                                                                             // 4454
			}                                                                                                                   // 4455
			this._firstPT = pt = this.parse(target, vars, null);                                                                // 4456
                                                                                                                       // 4457
			if (this._transformType) {                                                                                          // 4458
				threeD = (this._transformType === 3);                                                                              // 4459
				if (!_transformProp) {                                                                                             // 4460
					style.zoom = 1; //helps correct an IE issue.                                                                      // 4461
				} else if (_isSafari) {                                                                                            // 4462
					_reqSafariFix = true;                                                                                             // 4463
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).               // 4464
					if (style.zIndex === "") {                                                                                        // 4465
						zIndex = _getStyle(target, "zIndex", _cs);                                                                       // 4466
						if (zIndex === "auto" || zIndex === "") {                                                                        // 4467
							this._addLazySet(style, "zIndex", 0);                                                                           // 4468
						}                                                                                                                // 4469
					}                                                                                                                 // 4470
					//Setting WebkitBackfaceVisibility corrects 3 bugs:                                                               // 4471
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {                                                                                               // 4476
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}                                                                                                                 // 4478
				}                                                                                                                  // 4479
				pt2 = pt;                                                                                                          // 4480
				while (pt2 && pt2._next) {                                                                                         // 4481
					pt2 = pt2._next;                                                                                                  // 4482
				}                                                                                                                  // 4483
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);                                                        // 4484
				this._linkCSSP(tpt, null, pt2);                                                                                    // 4485
				tpt.setRatio = (threeD && _supports3D) ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);                                                    // 4487
				tpt.tween = tween;                                                                                                 // 4488
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}                                                                                                                   // 4490
                                                                                                                       // 4491
			if (_hasPriority) {                                                                                                 // 4492
				//reorders the linked list in order of pr (priority)                                                               // 4493
				while (pt) {                                                                                                       // 4494
					next = pt._next;                                                                                                  // 4495
					pt2 = first;                                                                                                      // 4496
					while (pt2 && pt2.pr > pt.pr) {                                                                                   // 4497
						pt2 = pt2._next;                                                                                                 // 4498
					}                                                                                                                 // 4499
					if ((pt._prev = pt2 ? pt2._prev : last)) {                                                                        // 4500
						pt._prev._next = pt;                                                                                             // 4501
					} else {                                                                                                          // 4502
						first = pt;                                                                                                      // 4503
					}                                                                                                                 // 4504
					if ((pt._next = pt2)) {                                                                                           // 4505
						pt2._prev = pt;                                                                                                  // 4506
					} else {                                                                                                          // 4507
						last = pt;                                                                                                       // 4508
					}                                                                                                                 // 4509
					pt = next;                                                                                                        // 4510
				}                                                                                                                  // 4511
				this._firstPT = first;                                                                                             // 4512
			}                                                                                                                   // 4513
			return true;                                                                                                        // 4514
		};                                                                                                                   // 4515
                                                                                                                       // 4516
                                                                                                                       // 4517
		p.parse = function(target, vars, pt, plugin) {                                                                       // 4518
			var style = target.style,                                                                                           // 4519
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;                                                                     // 4520
			for (p in vars) {                                                                                                   // 4521
				es = vars[p]; //ending value string                                                                                // 4522
				sp = _specialProps[p]; //SpecialProp lookup.                                                                       // 4523
				if (sp) {                                                                                                          // 4524
					pt = sp.parse(target, es, p, this, pt, plugin, vars);                                                             // 4525
                                                                                                                       // 4526
				} else {                                                                                                           // 4527
					bs = _getStyle(target, p, _cs) + "";                                                                              // 4528
					isStr = (typeof(es) === "string");                                                                                // 4529
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {                                                                                                    // 4531
							es = _parseColor(es);                                                                                           // 4532
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";                                                 // 4533
						}                                                                                                                // 4534
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);                                        // 4535
                                                                                                                       // 4536
					} else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {                                         // 4537
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);                                                 // 4538
                                                                                                                       // 4539
					} else {                                                                                                          // 4540
						bn = parseFloat(bs);                                                                                             // 4541
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.
                                                                                                                       // 4543
						if (bs === "" || bs === "auto") {                                                                                // 4544
							if (p === "width" || p === "height") {                                                                          // 4545
								bn = _getDimension(target, p, _cs);                                                                            // 4546
								bsfx = "px";                                                                                                   // 4547
							} else if (p === "left" || p === "top") {                                                                       // 4548
								bn = _calculateOffset(target, p, _cs);                                                                         // 4549
								bsfx = "px";                                                                                                   // 4550
							} else {                                                                                                        // 4551
								bn = (p !== "opacity") ? 0 : 1;                                                                                // 4552
								bsfx = "";                                                                                                     // 4553
							}                                                                                                               // 4554
						}                                                                                                                // 4555
                                                                                                                       // 4556
						rel = (isStr && es.charAt(1) === "=");                                                                           // 4557
						if (rel) {                                                                                                       // 4558
							en = parseInt(es.charAt(0) + "1", 10);                                                                          // 4559
							es = es.substr(2);                                                                                              // 4560
							en *= parseFloat(es);                                                                                           // 4561
							esfx = es.replace(_suffixExp, "");                                                                              // 4562
						} else {                                                                                                         // 4563
							en = parseFloat(es);                                                                                            // 4564
							esfx = isStr ? es.replace(_suffixExp, "") : "";                                                                 // 4565
						}                                                                                                                // 4566
                                                                                                                       // 4567
						if (esfx === "") {                                                                                               // 4568
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}                                                                                                                // 4570
                                                                                                                       // 4571
						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.
                                                                                                                       // 4573
						//if the beginning/ending suffixes don't match, normalize them...                                                // 4574
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);                                                                     // 4576
							if (esfx === "%") {                                                                                             // 4577
								bn /= _convertToPixels(target, p, 100, "%") / 100;                                                             // 4578
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";                                                                                                // 4580
								}                                                                                                              // 4581
                                                                                                                       // 4582
							} else if (esfx === "em") {                                                                                     // 4583
								bn /= _convertToPixels(target, p, 1, "em");                                                                    // 4584
                                                                                                                       // 4585
							//otherwise convert to pixels.                                                                                  // 4586
							} else if (esfx !== "px") {                                                                                     // 4587
								en = _convertToPixels(target, p, en, esfx);                                                                    // 4588
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.                             // 4589
							}                                                                                                               // 4590
							if (rel) if (en || en === 0) {                                                                                  // 4591
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.       // 4592
							}                                                                                                               // 4593
						}                                                                                                                // 4594
                                                                                                                       // 4595
						if (rel) {                                                                                                       // 4596
							en += bn;                                                                                                       // 4597
						}                                                                                                                // 4598
                                                                                                                       // 4599
						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;                                                                                                  // 4602
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);                      // 4603
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {                                 // 4604
							_log("invalid " + p + " tween value: " + vars[p]);                                                              // 4605
						} else {                                                                                                         // 4606
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);                                 // 4607
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);                                                             // 4609
						}                                                                                                                // 4610
					}                                                                                                                 // 4611
				}                                                                                                                  // 4612
				if (plugin) if (pt && !pt.plugin) {                                                                                // 4613
					pt.plugin = plugin;                                                                                               // 4614
				}                                                                                                                  // 4615
			}                                                                                                                   // 4616
			return pt;                                                                                                          // 4617
		};                                                                                                                   // 4618
                                                                                                                       // 4619
                                                                                                                       // 4620
		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {                                                                                           // 4622
			var pt = this._firstPT,                                                                                             // 4623
				min = 0.000001,                                                                                                    // 4624
				val, str, i;                                                                                                       // 4625
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {                          // 4627
				while (pt) {                                                                                                       // 4628
					if (pt.type !== 2) {                                                                                              // 4629
						pt.t[pt.p] = pt.e;                                                                                               // 4630
					} else {                                                                                                          // 4631
						pt.setRatio(v);                                                                                                  // 4632
					}                                                                                                                 // 4633
					pt = pt._next;                                                                                                    // 4634
				}                                                                                                                  // 4635
                                                                                                                       // 4636
			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {                                                                                                       // 4638
					val = pt.c * v + pt.s;                                                                                            // 4639
					if (pt.r) {                                                                                                       // 4640
						val = Math.round(val);                                                                                           // 4641
					} else if (val < min) if (val > -min) {                                                                           // 4642
						val = 0;                                                                                                         // 4643
					}                                                                                                                 // 4644
					if (!pt.type) {                                                                                                   // 4645
						pt.t[pt.p] = val + pt.xs0;                                                                                       // 4646
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;                                                                                                        // 4648
						if (i === 2) {                                                                                                   // 4649
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;                                                           // 4650
						} else if (i === 3) {                                                                                            // 4651
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;                                         // 4652
						} else if (i === 4) {                                                                                            // 4653
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;                       // 4654
						} else if (i === 5) {                                                                                            // 4655
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;     // 4656
						} else {                                                                                                         // 4657
							str = pt.xs0 + val + pt.xs1;                                                                                    // 4658
							for (i = 1; i < pt.l; i++) {                                                                                    // 4659
								str += pt["xn"+i] + pt["xs"+(i+1)];                                                                            // 4660
							}                                                                                                               // 4661
							pt.t[pt.p] = str;                                                                                               // 4662
						}                                                                                                                // 4663
                                                                                                                       // 4664
					} else if (pt.type === -1) { //non-tweening value                                                                 // 4665
						pt.t[pt.p] = pt.xs0;                                                                                             // 4666
                                                                                                                       // 4667
					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.                // 4668
						pt.setRatio(v);                                                                                                  // 4669
					}                                                                                                                 // 4670
					pt = pt._next;                                                                                                    // 4671
				}                                                                                                                  // 4672
                                                                                                                       // 4673
			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {                                                                                                            // 4675
				while (pt) {                                                                                                       // 4676
					if (pt.type !== 2) {                                                                                              // 4677
						pt.t[pt.p] = pt.b;                                                                                               // 4678
					} else {                                                                                                          // 4679
						pt.setRatio(v);                                                                                                  // 4680
					}                                                                                                                 // 4681
					pt = pt._next;                                                                                                    // 4682
				}                                                                                                                  // 4683
			}                                                                                                                   // 4684
		};                                                                                                                   // 4685
                                                                                                                       // 4686
		/**                                                                                                                  // 4687
		 * @private                                                                                                          // 4688
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin     // 4692
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you           // 4693
		 * want and it won't create duplicate CSSPropTweens.                                                                 // 4694
		 *                                                                                                                   // 4695
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */                                                                                                                  // 4697
		p._enableTransforms = function(threeD) {                                                                             // 4698
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};                                                                                                                   // 4701
                                                                                                                       // 4702
		var lazySet = function(v) {                                                                                          // 4703
			this.t[this.p] = this.e;                                                                                            // 4704
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};                                                                                                                   // 4706
		/** @private Gives us a way to set a value on the first render (and only the first render). **/                      // 4707
		p._addLazySet = function(t, p, v) {                                                                                  // 4708
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);                                            // 4709
			pt.e = v;                                                                                                           // 4710
			pt.setRatio = lazySet;                                                                                              // 4711
			pt.data = this;                                                                                                     // 4712
		};                                                                                                                   // 4713
                                                                                                                       // 4714
		/** @private **/                                                                                                     // 4715
		p._linkCSSP = function(pt, next, prev, remove) {                                                                     // 4716
			if (pt) {                                                                                                           // 4717
				if (next) {                                                                                                        // 4718
					next._prev = pt;                                                                                                  // 4719
				}                                                                                                                  // 4720
				if (pt._next) {                                                                                                    // 4721
					pt._next._prev = pt._prev;                                                                                        // 4722
				}                                                                                                                  // 4723
				if (pt._prev) {                                                                                                    // 4724
					pt._prev._next = pt._next;                                                                                        // 4725
				} else if (this._firstPT === pt) {                                                                                 // 4726
					this._firstPT = pt._next;                                                                                         // 4727
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}                                                                                                                  // 4729
				if (prev) {                                                                                                        // 4730
					prev._next = pt;                                                                                                  // 4731
				} else if (!remove && this._firstPT === null) {                                                                    // 4732
					this._firstPT = pt;                                                                                               // 4733
				}                                                                                                                  // 4734
				pt._next = next;                                                                                                   // 4735
				pt._prev = prev;                                                                                                   // 4736
			}                                                                                                                   // 4737
			return pt;                                                                                                          // 4738
		};                                                                                                                   // 4739
                                                                                                                       // 4740
		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {                                                                                         // 4742
			var copy = lookup,                                                                                                  // 4743
				pt, p, xfirst;                                                                                                     // 4744
			if (lookup.autoAlpha || lookup.alpha) {                                                                             // 4745
				copy = {};                                                                                                         // 4746
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.       // 4747
					copy[p] = lookup[p];                                                                                              // 4748
				}                                                                                                                  // 4749
				copy.opacity = 1;                                                                                                  // 4750
				if (copy.autoAlpha) {                                                                                              // 4751
					copy.visibility = 1;                                                                                              // 4752
				}                                                                                                                  // 4753
			}                                                                                                                   // 4754
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;                                                                                                // 4756
				if (xfirst && xfirst._prev) {                                                                                      // 4757
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev                                  // 4758
				} else if (xfirst === this._firstPT) {                                                                             // 4759
					this._firstPT = pt._next;                                                                                         // 4760
				}                                                                                                                  // 4761
				if (pt._next) {                                                                                                    // 4762
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);                                                           // 4763
				}                                                                                                                  // 4764
				this._classNamePT = null;                                                                                          // 4765
			}                                                                                                                   // 4766
			return TweenPlugin.prototype._kill.call(this, copy);                                                                // 4767
		};                                                                                                                   // 4768
                                                                                                                       // 4769
                                                                                                                       // 4770
                                                                                                                       // 4771
		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.     // 4772
		var _getChildStyles = function(e, props, targets) {                                                                  // 4773
				var children, i, child, type;                                                                                      // 4774
				if (e.slice) {                                                                                                     // 4775
					i = e.length;                                                                                                     // 4776
					while (--i > -1) {                                                                                                // 4777
						_getChildStyles(e[i], props, targets);                                                                           // 4778
					}                                                                                                                 // 4779
					return;                                                                                                           // 4780
				}                                                                                                                  // 4781
				children = e.childNodes;                                                                                           // 4782
				i = children.length;                                                                                               // 4783
				while (--i > -1) {                                                                                                 // 4784
					child = children[i];                                                                                              // 4785
					type = child.type;                                                                                                // 4786
					if (child.style) {                                                                                                // 4787
						props.push(_getAllStyles(child));                                                                                // 4788
						if (targets) {                                                                                                   // 4789
							targets.push(child);                                                                                            // 4790
						}                                                                                                                // 4791
					}                                                                                                                 // 4792
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {                                       // 4793
						_getChildStyles(child, props, targets);                                                                          // 4794
					}                                                                                                                 // 4795
				}                                                                                                                  // 4796
			};                                                                                                                  // 4797
                                                                                                                       // 4798
		/**                                                                                                                  // 4799
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite        // 4800
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and       // 4801
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting       // 4802
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is       // 4803
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens  // 4804
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,     // 4805
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API    // 4806
		 * and it would create other problems. For example:                                                                  // 4807
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *                                                                                                                   // 4811
		 * @param {Object} target object to be tweened                                                                       // 4812
		 * @param {number} Duration in seconds (or frames for frames-based tweens)                                           // 4813
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}               // 4814
		 * @return {Array} An array of TweenLite instances                                                                   // 4815
		 */                                                                                                                  // 4816
		CSSPlugin.cascadeTo = function(target, duration, vars) {                                                             // 4817
			var tween = TweenLite.to(target, duration, vars),                                                                   // 4818
				results = [tween],                                                                                                 // 4819
				b = [],                                                                                                            // 4820
				e = [],                                                                                                            // 4821
				targets = [],                                                                                                      // 4822
				_reservedProps = TweenLite._internals.reservedProps,                                                               // 4823
				i, difs, p, from;                                                                                                  // 4824
			target = tween._targets || tween.target;                                                                            // 4825
			_getChildStyles(target, b, targets);                                                                                // 4826
			tween.render(duration, true, true);                                                                                 // 4827
			_getChildStyles(target, e);                                                                                         // 4828
			tween.render(0, true, true);                                                                                        // 4829
			tween._enabled(true);                                                                                               // 4830
			i = targets.length;                                                                                                 // 4831
			while (--i > -1) {                                                                                                  // 4832
				difs = _cssDif(targets[i], b[i], e[i]);                                                                            // 4833
				if (difs.firstMPT) {                                                                                               // 4834
					difs = difs.difs;                                                                                                 // 4835
					for (p in vars) {                                                                                                 // 4836
						if (_reservedProps[p]) {                                                                                         // 4837
							difs[p] = vars[p];                                                                                              // 4838
						}                                                                                                                // 4839
					}                                                                                                                 // 4840
					from = {};                                                                                                        // 4841
					for (p in difs) {                                                                                                 // 4842
						from[p] = b[i][p];                                                                                               // 4843
					}                                                                                                                 // 4844
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));                                                 // 4845
				}                                                                                                                  // 4846
			}                                                                                                                   // 4847
			return results;                                                                                                     // 4848
		};                                                                                                                   // 4849
                                                                                                                       // 4850
		TweenPlugin.activate([CSSPlugin]);                                                                                   // 4851
		return CSSPlugin;                                                                                                    // 4852
                                                                                                                       // 4853
	}, true);                                                                                                             // 4854
                                                                                                                       // 4855
	                                                                                                                      // 4856
	                                                                                                                      // 4857
	                                                                                                                      // 4858
	                                                                                                                      // 4859
	                                                                                                                      // 4860
	                                                                                                                      // 4861
	                                                                                                                      // 4862
	                                                                                                                      // 4863
	                                                                                                                      // 4864
	                                                                                                                      // 4865
/*                                                                                                                     // 4866
 * ----------------------------------------------------------------                                                    // 4867
 * RoundPropsPlugin                                                                                                    // 4868
 * ----------------------------------------------------------------                                                    // 4869
 */                                                                                                                    // 4870
	(function() {                                                                                                         // 4871
                                                                                                                       // 4872
		var RoundPropsPlugin = _gsScope._gsDefine.plugin({                                                                   // 4873
				propName: "roundProps",                                                                                            // 4874
				priority: -1,                                                                                                      // 4875
				API: 2,                                                                                                            // 4876
                                                                                                                       // 4877
				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {                                                                             // 4879
					this._tween = tween;                                                                                              // 4880
					return true;                                                                                                      // 4881
				}                                                                                                                  // 4882
                                                                                                                       // 4883
			}),                                                                                                                 // 4884
			p = RoundPropsPlugin.prototype;                                                                                     // 4885
                                                                                                                       // 4886
		p._onInitAllProps = function() {                                                                                     // 4887
			var tween = this._tween,                                                                                            // 4888
				rp = (tween.vars.roundProps instanceof Array) ? tween.vars.roundProps : tween.vars.roundProps.split(","),          // 4889
				i = rp.length,                                                                                                     // 4890
				lookup = {},                                                                                                       // 4891
				rpt = tween._propLookup.roundProps,                                                                                // 4892
				prop, pt, next;                                                                                                    // 4893
			while (--i > -1) {                                                                                                  // 4894
				lookup[rp[i]] = 1;                                                                                                 // 4895
			}                                                                                                                   // 4896
			i = rp.length;                                                                                                      // 4897
			while (--i > -1) {                                                                                                  // 4898
				prop = rp[i];                                                                                                      // 4899
				pt = tween._firstPT;                                                                                               // 4900
				while (pt) {                                                                                                       // 4901
					next = pt._next; //record here, because it may get removed                                                        // 4902
					if (pt.pg) {                                                                                                      // 4903
						pt.t._roundProps(lookup, true);                                                                                  // 4904
					} else if (pt.n === prop) {                                                                                       // 4905
						this._add(pt.t, prop, pt.s, pt.c);                                                                               // 4906
						//remove from linked list                                                                                        // 4907
						if (next) {                                                                                                      // 4908
							next._prev = pt._prev;                                                                                          // 4909
						}                                                                                                                // 4910
						if (pt._prev) {                                                                                                  // 4911
							pt._prev._next = next;                                                                                          // 4912
						} else if (tween._firstPT === pt) {                                                                              // 4913
							tween._firstPT = next;                                                                                          // 4914
						}                                                                                                                // 4915
						pt._next = pt._prev = null;                                                                                      // 4916
						tween._propLookup[prop] = rpt;                                                                                   // 4917
					}                                                                                                                 // 4918
					pt = next;                                                                                                        // 4919
				}                                                                                                                  // 4920
			}                                                                                                                   // 4921
			return false;                                                                                                       // 4922
		};                                                                                                                   // 4923
                                                                                                                       // 4924
		p._add = function(target, p, s, c) {                                                                                 // 4925
			this._addTween(target, p, s, s + c, p, true);                                                                       // 4926
			this._overwriteProps.push(p);                                                                                       // 4927
		};                                                                                                                   // 4928
                                                                                                                       // 4929
	}());                                                                                                                 // 4930
                                                                                                                       // 4931
                                                                                                                       // 4932
                                                                                                                       // 4933
                                                                                                                       // 4934
                                                                                                                       // 4935
                                                                                                                       // 4936
                                                                                                                       // 4937
                                                                                                                       // 4938
                                                                                                                       // 4939
                                                                                                                       // 4940
/*                                                                                                                     // 4941
 * ----------------------------------------------------------------                                                    // 4942
 * AttrPlugin                                                                                                          // 4943
 * ----------------------------------------------------------------                                                    // 4944
 */                                                                                                                    // 4945
	_gsScope._gsDefine.plugin({                                                                                           // 4946
		propName: "attr",                                                                                                    // 4947
		API: 2,                                                                                                              // 4948
		version: "0.3.3",                                                                                                    // 4949
                                                                                                                       // 4950
		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {                                                                               // 4952
			var p, start, end;                                                                                                  // 4953
			if (typeof(target.setAttribute) !== "function") {                                                                   // 4954
				return false;                                                                                                      // 4955
			}                                                                                                                   // 4956
			this._target = target;                                                                                              // 4957
			this._proxy = {};                                                                                                   // 4958
			this._start = {}; // we record start and end values exactly as they are in case they're strings (not numbers) - we need to be able to revert to them cleanly.
			this._end = {};                                                                                                     // 4960
			for (p in value) {                                                                                                  // 4961
				this._start[p] = this._proxy[p] = start = target.getAttribute(p);                                                  // 4962
				end = this._addTween(this._proxy, p, parseFloat(start), value[p], p);                                              // 4963
				this._end[p] = end ? end.s + end.c : value[p];                                                                     // 4964
				this._overwriteProps.push(p);                                                                                      // 4965
			}                                                                                                                   // 4966
			return true;                                                                                                        // 4967
		},                                                                                                                   // 4968
                                                                                                                       // 4969
		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {                                                                                               // 4971
			this._super.setRatio.call(this, ratio);                                                                             // 4972
			var props = this._overwriteProps,                                                                                   // 4973
				i = props.length,                                                                                                  // 4974
				lookup = (ratio === 1) ? this._end : ratio ? this._proxy : this._start,                                            // 4975
				p;                                                                                                                 // 4976
			while (--i > -1) {                                                                                                  // 4977
				p = props[i];                                                                                                      // 4978
				this._target.setAttribute(p, lookup[p] + "");                                                                      // 4979
			}                                                                                                                   // 4980
		}                                                                                                                    // 4981
                                                                                                                       // 4982
	});                                                                                                                   // 4983
                                                                                                                       // 4984
                                                                                                                       // 4985
                                                                                                                       // 4986
                                                                                                                       // 4987
                                                                                                                       // 4988
                                                                                                                       // 4989
                                                                                                                       // 4990
                                                                                                                       // 4991
                                                                                                                       // 4992
                                                                                                                       // 4993
/*                                                                                                                     // 4994
 * ----------------------------------------------------------------                                                    // 4995
 * DirectionalRotationPlugin                                                                                           // 4996
 * ----------------------------------------------------------------                                                    // 4997
 */                                                                                                                    // 4998
	_gsScope._gsDefine.plugin({                                                                                           // 4999
		propName: "directionalRotation",                                                                                     // 5000
		version: "0.2.1",                                                                                                    // 5001
		API: 2,                                                                                                              // 5002
                                                                                                                       // 5003
		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {                                                                               // 5005
			if (typeof(value) !== "object") {                                                                                   // 5006
				value = {rotation:value};                                                                                          // 5007
			}                                                                                                                   // 5008
			this.finals = {};                                                                                                   // 5009
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,                                                          // 5010
				min = 0.000001,                                                                                                    // 5011
				p, v, start, end, dif, split;                                                                                      // 5012
			for (p in value) {                                                                                                  // 5013
				if (p !== "useRadians") {                                                                                          // 5014
					split = (value[p] + "").split("_");                                                                               // 5015
					v = split[0];                                                                                                     // 5016
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;                                                                                                // 5019
					if (split.length) {                                                                                               // 5020
						v = split.join("_");                                                                                             // 5021
						if (v.indexOf("short") !== -1) {                                                                                 // 5022
							dif = dif % cap;                                                                                                // 5023
							if (dif !== dif % (cap / 2)) {                                                                                  // 5024
								dif = (dif < 0) ? dif + cap : dif - cap;                                                                       // 5025
							}                                                                                                               // 5026
						}                                                                                                                // 5027
						if (v.indexOf("_cw") !== -1 && dif < 0) {                                                                        // 5028
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;                                               // 5029
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {                                                                 // 5030
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;                                               // 5031
						}                                                                                                                // 5032
					}                                                                                                                 // 5033
					if (dif > min || dif < -min) {                                                                                    // 5034
						this._addTween(target, p, start, start + dif, p);                                                                // 5035
						this._overwriteProps.push(p);                                                                                    // 5036
					}                                                                                                                 // 5037
				}                                                                                                                  // 5038
			}                                                                                                                   // 5039
			return true;                                                                                                        // 5040
		},                                                                                                                   // 5041
                                                                                                                       // 5042
		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {                                                                                               // 5044
			var pt;                                                                                                             // 5045
			if (ratio !== 1) {                                                                                                  // 5046
				this._super.setRatio.call(this, ratio);                                                                            // 5047
			} else {                                                                                                            // 5048
				pt = this._firstPT;                                                                                                // 5049
				while (pt) {                                                                                                       // 5050
					if (pt.f) {                                                                                                       // 5051
						pt.t[pt.p](this.finals[pt.p]);                                                                                   // 5052
					} else {                                                                                                          // 5053
						pt.t[pt.p] = this.finals[pt.p];                                                                                  // 5054
					}                                                                                                                 // 5055
					pt = pt._next;                                                                                                    // 5056
				}                                                                                                                  // 5057
			}                                                                                                                   // 5058
		}                                                                                                                    // 5059
                                                                                                                       // 5060
	})._autoCSS = true;                                                                                                   // 5061
                                                                                                                       // 5062
                                                                                                                       // 5063
                                                                                                                       // 5064
                                                                                                                       // 5065
                                                                                                                       // 5066
                                                                                                                       // 5067
                                                                                                                       // 5068
	                                                                                                                      // 5069
	                                                                                                                      // 5070
	                                                                                                                      // 5071
	                                                                                                                      // 5072
/*                                                                                                                     // 5073
 * ----------------------------------------------------------------                                                    // 5074
 * EasePack                                                                                                            // 5075
 * ----------------------------------------------------------------                                                    // 5076
 */                                                                                                                    // 5077
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {                                                   // 5078
		                                                                                                                     // 5079
		var w = (_gsScope.GreenSockGlobals || _gsScope),                                                                     // 5080
			gs = w.com.greensock,                                                                                               // 5081
			_2PI = Math.PI * 2,                                                                                                 // 5082
			_HALF_PI = Math.PI / 2,                                                                                             // 5083
			_class = gs._class,                                                                                                 // 5084
			_create = function(n, f) {                                                                                          // 5085
				var C = _class("easing." + n, function(){}, true),                                                                 // 5086
					p = C.prototype = new Ease();                                                                                     // 5087
				p.constructor = C;                                                                                                 // 5088
				p.getRatio = f;                                                                                                    // 5089
				return C;                                                                                                          // 5090
			},                                                                                                                  // 5091
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {                                                       // 5093
				var C = _class("easing."+name, {                                                                                   // 5094
					easeOut:new EaseOut(),                                                                                            // 5095
					easeIn:new EaseIn(),                                                                                              // 5096
					easeInOut:new EaseInOut()                                                                                         // 5097
				}, true);                                                                                                          // 5098
				_easeReg(C, name);                                                                                                 // 5099
				return C;                                                                                                          // 5100
			},                                                                                                                  // 5101
			EasePoint = function(time, value, next) {                                                                           // 5102
				this.t = time;                                                                                                     // 5103
				this.v = value;                                                                                                    // 5104
				if (next) {                                                                                                        // 5105
					this.next = next;                                                                                                 // 5106
					next.prev = this;                                                                                                 // 5107
					this.c = next.v - value;                                                                                          // 5108
					this.gap = next.t - time;                                                                                         // 5109
				}                                                                                                                  // 5110
			},                                                                                                                  // 5111
                                                                                                                       // 5112
			//Back                                                                                                              // 5113
			_createBack = function(n, f) {                                                                                      // 5114
				var C = _class("easing." + n, function(overshoot) {                                                                // 5115
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;                                                 // 5116
						this._p2 = this._p1 * 1.525;                                                                                     // 5117
					}, true),                                                                                                         // 5118
					p = C.prototype = new Ease();                                                                                     // 5119
				p.constructor = C;                                                                                                 // 5120
				p.getRatio = f;                                                                                                    // 5121
				p.config = function(overshoot) {                                                                                   // 5122
					return new C(overshoot);                                                                                          // 5123
				};                                                                                                                 // 5124
				return C;                                                                                                          // 5125
			},                                                                                                                  // 5126
                                                                                                                       // 5127
			Back = _wrap("Back",                                                                                                // 5128
				_createBack("BackOut", function(p) {                                                                               // 5129
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);                                                   // 5130
				}),                                                                                                                // 5131
				_createBack("BackIn", function(p) {                                                                                // 5132
					return p * p * ((this._p1 + 1) * p - this._p1);                                                                   // 5133
				}),                                                                                                                // 5134
				_createBack("BackInOut", function(p) {                                                                             // 5135
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})                                                                                                                 // 5137
			),                                                                                                                  // 5138
                                                                                                                       // 5139
                                                                                                                       // 5140
			//SlowMo                                                                                                            // 5141
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {                                           // 5142
				power = (power || power === 0) ? power : 0.7;                                                                      // 5143
				if (linearRatio == null) {                                                                                         // 5144
					linearRatio = 0.7;                                                                                                // 5145
				} else if (linearRatio > 1) {                                                                                      // 5146
					linearRatio = 1;                                                                                                  // 5147
				}                                                                                                                  // 5148
				this._p = (linearRatio !== 1) ? power : 0;                                                                         // 5149
				this._p1 = (1 - linearRatio) / 2;                                                                                  // 5150
				this._p2 = linearRatio;                                                                                            // 5151
				this._p3 = this._p1 + this._p2;                                                                                    // 5152
				this._calcEnd = (yoyoMode === true);                                                                               // 5153
			}, true),                                                                                                           // 5154
			p = SlowMo.prototype = new Ease(),                                                                                  // 5155
			SteppedEase, RoughEase, _createElastic;                                                                             // 5156
                                                                                                                       // 5157
		p.constructor = SlowMo;                                                                                              // 5158
		p.getRatio = function(p) {                                                                                           // 5159
			var r = p + (0.5 - p) * this._p;                                                                                    // 5160
			if (p < this._p1) {                                                                                                 // 5161
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);        // 5162
			} else if (p > this._p3) {                                                                                          // 5163
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}                                                                                                                   // 5165
			return this._calcEnd ? 1 : r;                                                                                       // 5166
		};                                                                                                                   // 5167
		SlowMo.ease = new SlowMo(0.7, 0.7);                                                                                  // 5168
                                                                                                                       // 5169
		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {                                                  // 5170
			return new SlowMo(linearRatio, power, yoyoMode);                                                                    // 5171
		};                                                                                                                   // 5172
                                                                                                                       // 5173
                                                                                                                       // 5174
		//SteppedEase                                                                                                        // 5175
		SteppedEase = _class("easing.SteppedEase", function(steps) {                                                         // 5176
				steps = steps || 1;                                                                                                // 5177
				this._p1 = 1 / steps;                                                                                              // 5178
				this._p2 = steps + 1;                                                                                              // 5179
			}, true);                                                                                                           // 5180
		p = SteppedEase.prototype = new Ease();                                                                              // 5181
		p.constructor = SteppedEase;                                                                                         // 5182
		p.getRatio = function(p) {                                                                                           // 5183
			if (p < 0) {                                                                                                        // 5184
				p = 0;                                                                                                             // 5185
			} else if (p >= 1) {                                                                                                // 5186
				p = 0.999999999;                                                                                                   // 5187
			}                                                                                                                   // 5188
			return ((this._p2 * p) >> 0) * this._p1;                                                                            // 5189
		};                                                                                                                   // 5190
		p.config = SteppedEase.config = function(steps) {                                                                    // 5191
			return new SteppedEase(steps);                                                                                      // 5192
		};                                                                                                                   // 5193
                                                                                                                       // 5194
                                                                                                                       // 5195
		//RoughEase                                                                                                          // 5196
		RoughEase = _class("easing.RoughEase", function(vars) {                                                              // 5197
			vars = vars || {};                                                                                                  // 5198
			var taper = vars.taper || "none",                                                                                   // 5199
				a = [],                                                                                                            // 5200
				cnt = 0,                                                                                                           // 5201
				points = (vars.points || 20) | 0,                                                                                  // 5202
				i = points,                                                                                                        // 5203
				randomize = (vars.randomize !== false),                                                                            // 5204
				clamp = (vars.clamp === true),                                                                                     // 5205
				template = (vars.template instanceof Ease) ? vars.template : null,                                                 // 5206
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,                                       // 5207
				x, y, bump, invX, obj, pnt;                                                                                        // 5208
			while (--i > -1) {                                                                                                  // 5209
				x = randomize ? Math.random() : (1 / points) * i;                                                                  // 5210
				y = template ? template.getRatio(x) : x;                                                                           // 5211
				if (taper === "none") {                                                                                            // 5212
					bump = strength;                                                                                                  // 5213
				} else if (taper === "out") {                                                                                      // 5214
					invX = 1 - x;                                                                                                     // 5215
					bump = invX * invX * strength;                                                                                    // 5216
				} else if (taper === "in") {                                                                                       // 5217
					bump = x * x * strength;                                                                                          // 5218
				} else if (x < 0.5) {  //"both" (start)                                                                            // 5219
					invX = x * 2;                                                                                                     // 5220
					bump = invX * invX * 0.5 * strength;                                                                              // 5221
				} else {				//"both" (end)                                                                                         // 5222
					invX = (1 - x) * 2;                                                                                               // 5223
					bump = invX * invX * 0.5 * strength;                                                                              // 5224
				}                                                                                                                  // 5225
				if (randomize) {                                                                                                   // 5226
					y += (Math.random() * bump) - (bump * 0.5);                                                                       // 5227
				} else if (i % 2) {                                                                                                // 5228
					y += bump * 0.5;                                                                                                  // 5229
				} else {                                                                                                           // 5230
					y -= bump * 0.5;                                                                                                  // 5231
				}                                                                                                                  // 5232
				if (clamp) {                                                                                                       // 5233
					if (y > 1) {                                                                                                      // 5234
						y = 1;                                                                                                           // 5235
					} else if (y < 0) {                                                                                               // 5236
						y = 0;                                                                                                           // 5237
					}                                                                                                                 // 5238
				}                                                                                                                  // 5239
				a[cnt++] = {x:x, y:y};                                                                                             // 5240
			}                                                                                                                   // 5241
			a.sort(function(a, b) {                                                                                             // 5242
				return a.x - b.x;                                                                                                  // 5243
			});                                                                                                                 // 5244
                                                                                                                       // 5245
			pnt = new EasePoint(1, 1, null);                                                                                    // 5246
			i = points;                                                                                                         // 5247
			while (--i > -1) {                                                                                                  // 5248
				obj = a[i];                                                                                                        // 5249
				pnt = new EasePoint(obj.x, obj.y, pnt);                                                                            // 5250
			}                                                                                                                   // 5251
                                                                                                                       // 5252
			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);                                                   // 5253
		}, true);                                                                                                            // 5254
		p = RoughEase.prototype = new Ease();                                                                                // 5255
		p.constructor = RoughEase;                                                                                           // 5256
		p.getRatio = function(p) {                                                                                           // 5257
			var pnt = this._prev;                                                                                               // 5258
			if (p > pnt.t) {                                                                                                    // 5259
				while (pnt.next && p >= pnt.t) {                                                                                   // 5260
					pnt = pnt.next;                                                                                                   // 5261
				}                                                                                                                  // 5262
				pnt = pnt.prev;                                                                                                    // 5263
			} else {                                                                                                            // 5264
				while (pnt.prev && p <= pnt.t) {                                                                                   // 5265
					pnt = pnt.prev;                                                                                                   // 5266
				}                                                                                                                  // 5267
			}                                                                                                                   // 5268
			this._prev = pnt;                                                                                                   // 5269
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);                                                                   // 5270
		};                                                                                                                   // 5271
		p.config = function(vars) {                                                                                          // 5272
			return new RoughEase(vars);                                                                                         // 5273
		};                                                                                                                   // 5274
		RoughEase.ease = new RoughEase();                                                                                    // 5275
                                                                                                                       // 5276
                                                                                                                       // 5277
		//Bounce                                                                                                             // 5278
		_wrap("Bounce",                                                                                                      // 5279
			_create("BounceOut", function(p) {                                                                                  // 5280
				if (p < 1 / 2.75) {                                                                                                // 5281
					return 7.5625 * p * p;                                                                                            // 5282
				} else if (p < 2 / 2.75) {                                                                                         // 5283
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;                                                                     // 5284
				} else if (p < 2.5 / 2.75) {                                                                                       // 5285
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;                                                                  // 5286
				}                                                                                                                  // 5287
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;                                                                // 5288
			}),                                                                                                                 // 5289
			_create("BounceIn", function(p) {                                                                                   // 5290
				if ((p = 1 - p) < 1 / 2.75) {                                                                                      // 5291
					return 1 - (7.5625 * p * p);                                                                                      // 5292
				} else if (p < 2 / 2.75) {                                                                                         // 5293
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);                                                               // 5294
				} else if (p < 2.5 / 2.75) {                                                                                       // 5295
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);                                                            // 5296
				}                                                                                                                  // 5297
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);                                                          // 5298
			}),                                                                                                                 // 5299
			_create("BounceInOut", function(p) {                                                                                // 5300
				var invert = (p < 0.5);                                                                                            // 5301
				if (invert) {                                                                                                      // 5302
					p = 1 - (p * 2);                                                                                                  // 5303
				} else {                                                                                                           // 5304
					p = (p * 2) - 1;                                                                                                  // 5305
				}                                                                                                                  // 5306
				if (p < 1 / 2.75) {                                                                                                // 5307
					p = 7.5625 * p * p;                                                                                               // 5308
				} else if (p < 2 / 2.75) {                                                                                         // 5309
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;                                                                        // 5310
				} else if (p < 2.5 / 2.75) {                                                                                       // 5311
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;                                                                     // 5312
				} else {                                                                                                           // 5313
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;                                                                  // 5314
				}                                                                                                                  // 5315
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;                                                                     // 5316
			})                                                                                                                  // 5317
		);                                                                                                                   // 5318
                                                                                                                       // 5319
                                                                                                                       // 5320
		//CIRC                                                                                                               // 5321
		_wrap("Circ",                                                                                                        // 5322
			_create("CircOut", function(p) {                                                                                    // 5323
				return Math.sqrt(1 - (p = p - 1) * p);                                                                             // 5324
			}),                                                                                                                 // 5325
			_create("CircIn", function(p) {                                                                                     // 5326
				return -(Math.sqrt(1 - (p * p)) - 1);                                                                              // 5327
			}),                                                                                                                 // 5328
			_create("CircInOut", function(p) {                                                                                  // 5329
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);                 // 5330
			})                                                                                                                  // 5331
		);                                                                                                                   // 5332
                                                                                                                       // 5333
                                                                                                                       // 5334
		//Elastic                                                                                                            // 5335
		_createElastic = function(n, f, def) {                                                                               // 5336
			var C = _class("easing." + n, function(amplitude, period) {                                                         // 5337
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);                                                     // 5339
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);                                                      // 5340
					this._p2 = _2PI / this._p2; //precalculate to optimize                                                            // 5341
				}, true),                                                                                                          // 5342
				p = C.prototype = new Ease();                                                                                      // 5343
			p.constructor = C;                                                                                                  // 5344
			p.getRatio = f;                                                                                                     // 5345
			p.config = function(amplitude, period) {                                                                            // 5346
				return new C(amplitude, period);                                                                                   // 5347
			};                                                                                                                  // 5348
			return C;                                                                                                           // 5349
		};                                                                                                                   // 5350
		_wrap("Elastic",                                                                                                     // 5351
			_createElastic("ElasticOut", function(p) {                                                                          // 5352
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;                                // 5353
			}, 0.3),                                                                                                            // 5354
			_createElastic("ElasticIn", function(p) {                                                                           // 5355
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));                           // 5356
			}, 0.3),                                                                                                            // 5357
			_createElastic("ElasticInOut", function(p) {                                                                        // 5358
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)                                                                                                            // 5360
		);                                                                                                                   // 5361
                                                                                                                       // 5362
                                                                                                                       // 5363
		//Expo                                                                                                               // 5364
		_wrap("Expo",                                                                                                        // 5365
			_create("ExpoOut", function(p) {                                                                                    // 5366
				return 1 - Math.pow(2, -10 * p);                                                                                   // 5367
			}),                                                                                                                 // 5368
			_create("ExpoIn", function(p) {                                                                                     // 5369
				return Math.pow(2, 10 * (p - 1)) - 0.001;                                                                          // 5370
			}),                                                                                                                 // 5371
			_create("ExpoInOut", function(p) {                                                                                  // 5372
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));                  // 5373
			})                                                                                                                  // 5374
		);                                                                                                                   // 5375
                                                                                                                       // 5376
                                                                                                                       // 5377
		//Sine                                                                                                               // 5378
		_wrap("Sine",                                                                                                        // 5379
			_create("SineOut", function(p) {                                                                                    // 5380
				return Math.sin(p * _HALF_PI);                                                                                     // 5381
			}),                                                                                                                 // 5382
			_create("SineIn", function(p) {                                                                                     // 5383
				return -Math.cos(p * _HALF_PI) + 1;                                                                                // 5384
			}),                                                                                                                 // 5385
			_create("SineInOut", function(p) {                                                                                  // 5386
				return -0.5 * (Math.cos(Math.PI * p) - 1);                                                                         // 5387
			})                                                                                                                  // 5388
		);                                                                                                                   // 5389
                                                                                                                       // 5390
		_class("easing.EaseLookup", {                                                                                        // 5391
				find:function(s) {                                                                                                 // 5392
					return Ease.map[s];                                                                                               // 5393
				}                                                                                                                  // 5394
			}, true);                                                                                                           // 5395
                                                                                                                       // 5396
		//register the non-standard eases                                                                                    // 5397
		_easeReg(w.SlowMo, "SlowMo", "ease,");                                                                               // 5398
		_easeReg(RoughEase, "RoughEase", "ease,");                                                                           // 5399
		_easeReg(SteppedEase, "SteppedEase", "ease,");                                                                       // 5400
                                                                                                                       // 5401
		return Back;                                                                                                         // 5402
		                                                                                                                     // 5403
	}, true);                                                                                                             // 5404
                                                                                                                       // 5405
                                                                                                                       // 5406
});                                                                                                                    // 5407
                                                                                                                       // 5408
if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.    // 5409
                                                                                                                       // 5410
                                                                                                                       // 5411
                                                                                                                       // 5412
                                                                                                                       // 5413
                                                                                                                       // 5414
                                                                                                                       // 5415
                                                                                                                       // 5416
                                                                                                                       // 5417
                                                                                                                       // 5418
                                                                                                                       // 5419
                                                                                                                       // 5420
/*                                                                                                                     // 5421
 * ----------------------------------------------------------------                                                    // 5422
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.                                                     // 5423
 * ----------------------------------------------------------------                                                    // 5424
 */                                                                                                                    // 5425
(function(window, moduleName) {                                                                                        // 5426
                                                                                                                       // 5427
		"use strict";                                                                                                        // 5428
		var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;                                          // 5429
		if (_globals.TweenLite) {                                                                                            // 5430
			return; //in case the core set of classes is already loaded, don't instantiate twice.                               // 5431
		}                                                                                                                    // 5432
		var _namespace = function(ns) {                                                                                      // 5433
				var a = ns.split("."),                                                                                             // 5434
					p = _globals, i;                                                                                                  // 5435
				for (i = 0; i < a.length; i++) {                                                                                   // 5436
					p[a[i]] = p = p[a[i]] || {};                                                                                      // 5437
				}                                                                                                                  // 5438
				return p;                                                                                                          // 5439
			},                                                                                                                  // 5440
			gs = _namespace("com.greensock"),                                                                                   // 5441
			_tinyNum = 0.0000000001,                                                                                            // 5442
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],                                                                                                        // 5444
					l = a.length,                                                                                                     // 5445
					i;                                                                                                                // 5446
				for (i = 0; i !== l; b.push(a[i++]));                                                                              // 5447
				return b;                                                                                                          // 5448
			},                                                                                                                  // 5449
			_emptyFunc = function() {},                                                                                         // 5450
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,                                                                          // 5452
					array = toString.call([]);                                                                                        // 5453
				return function(obj) {                                                                                             // 5454
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};                                                                                                                 // 5456
			}()),                                                                                                               // 5457
			a, i, p, _ticker, _tickerActive,                                                                                    // 5458
			_defLookup = {},                                                                                                    // 5459
                                                                                                                       // 5460
			/**                                                                                                                 // 5461
			 * @constructor                                                                                                     // 5462
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.             // 5466
			 *                                                                                                                  // 5467
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:                                                                                     // 5474
			 *                                                                                                                  // 5475
			 * <script>                                                                                                         // 5476
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>                                                                                                        // 5478
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>                                                            // 5479
			 * <script>                                                                                                         // 5480
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>                                                                                                        // 5482
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>                                                            // 5483
			 * <script>                                                                                                         // 5484
			 *     gs.TweenLite.to(...); //would use v1.7                                                                       // 5485
			 *     TweenLite.to(...); //would use v1.6                                                                          // 5486
			 * </script>                                                                                                        // 5487
			 *                                                                                                                  // 5488
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */                                                                                                                 // 5493
			Definition = function(ns, dependencies, func, global) {                                                             // 5494
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses                                                  // 5495
				_defLookup[ns] = this;                                                                                             // 5496
				this.gsClass = null;                                                                                               // 5497
				this.func = func;                                                                                                  // 5498
				var _classes = [];                                                                                                 // 5499
				this.check = function(init) {                                                                                      // 5500
					var i = dependencies.length,                                                                                      // 5501
						missing = i,                                                                                                     // 5502
						cur, a, n, cl;                                                                                                   // 5503
					while (--i > -1) {                                                                                                // 5504
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {                        // 5505
							_classes[i] = cur.gsClass;                                                                                      // 5506
							missing--;                                                                                                      // 5507
						} else if (init) {                                                                                               // 5508
							cur.sc.push(this);                                                                                              // 5509
						}                                                                                                                // 5510
					}                                                                                                                 // 5511
					if (missing === 0 && func) {                                                                                      // 5512
						a = ("com.greensock." + ns).split(".");                                                                          // 5513
						n = a.pop();                                                                                                     // 5514
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);                                     // 5515
                                                                                                                       // 5516
						//exports to multiple environments                                                                               // 5517
						if (global) {                                                                                                    // 5518
							_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(define) === "function" && define.amd){ //AMD                                                         // 5520
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (ns === moduleName && typeof(module) !== "undefined" && module.exports){ //node                       // 5522
								module.exports = cl;                                                                                           // 5523
							}                                                                                                               // 5524
						}                                                                                                                // 5525
						for (i = 0; i < this.sc.length; i++) {                                                                           // 5526
							this.sc[i].check();                                                                                             // 5527
						}                                                                                                                // 5528
					}                                                                                                                 // 5529
				};                                                                                                                 // 5530
				this.check(true);                                                                                                  // 5531
			},                                                                                                                  // 5532
                                                                                                                       // 5533
			//used to create Definition instances (which basically registers a class that has dependencies).                    // 5534
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {                                           // 5535
				return new Definition(ns, dependencies, func, global);                                                             // 5536
			},                                                                                                                  // 5537
                                                                                                                       // 5538
			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {                                                                   // 5540
				func = func || function() {};                                                                                      // 5541
				_gsDefine(ns, [], function(){ return func; }, global);                                                             // 5542
				return func;                                                                                                       // 5543
			};                                                                                                                  // 5544
                                                                                                                       // 5545
		_gsDefine.globals = _globals;                                                                                        // 5546
                                                                                                                       // 5547
                                                                                                                       // 5548
                                                                                                                       // 5549
/*                                                                                                                     // 5550
 * ----------------------------------------------------------------                                                    // 5551
 * Ease                                                                                                                // 5552
 * ----------------------------------------------------------------                                                    // 5553
 */                                                                                                                    // 5554
		var _baseParams = [0, 0, 1, 1],                                                                                      // 5555
			_blankArray = [],                                                                                                   // 5556
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {                                             // 5557
				this._func = func;                                                                                                 // 5558
				this._type = type || 0;                                                                                            // 5559
				this._power = power || 0;                                                                                          // 5560
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;                                        // 5561
			}, true),                                                                                                           // 5562
			_easeMap = Ease.map = {},                                                                                           // 5563
			_easeReg = Ease.register = function(ease, names, types, create) {                                                   // 5564
				var na = names.split(","),                                                                                         // 5565
					i = na.length,                                                                                                    // 5566
					ta = (types || "easeIn,easeOut,easeInOut").split(","),                                                            // 5567
					e, name, j, type;                                                                                                 // 5568
				while (--i > -1) {                                                                                                 // 5569
					name = na[i];                                                                                                     // 5570
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};                                          // 5571
					j = ta.length;                                                                                                    // 5572
					while (--j > -1) {                                                                                                // 5573
						type = ta[j];                                                                                                    // 5574
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease(); // 5575
					}                                                                                                                 // 5576
				}                                                                                                                  // 5577
			};                                                                                                                  // 5578
                                                                                                                       // 5579
		p = Ease.prototype;                                                                                                  // 5580
		p._calcEnd = false;                                                                                                  // 5581
		p.getRatio = function(p) {                                                                                           // 5582
			if (this._func) {                                                                                                   // 5583
				this._params[0] = p;                                                                                               // 5584
				return this._func.apply(null, this._params);                                                                       // 5585
			}                                                                                                                   // 5586
			var t = this._type,                                                                                                 // 5587
				pw = this._power,                                                                                                  // 5588
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;                                           // 5589
			if (pw === 1) {                                                                                                     // 5590
				r *= r;                                                                                                            // 5591
			} else if (pw === 2) {                                                                                              // 5592
				r *= r * r;                                                                                                        // 5593
			} else if (pw === 3) {                                                                                              // 5594
				r *= r * r * r;                                                                                                    // 5595
			} else if (pw === 4) {                                                                                              // 5596
				r *= r * r * r * r;                                                                                                // 5597
			}                                                                                                                   // 5598
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);                                         // 5599
		};                                                                                                                   // 5600
                                                                                                                       // 5601
		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];                                                                // 5603
		i = a.length;                                                                                                        // 5604
		while (--i > -1) {                                                                                                   // 5605
			p = a[i]+",Power"+i;                                                                                                // 5606
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);                                                              // 5607
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));                                    // 5608
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");                                                                  // 5609
		}                                                                                                                    // 5610
		_easeMap.linear = gs.easing.Linear.easeIn;                                                                           // 5611
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks                                                        // 5612
                                                                                                                       // 5613
                                                                                                                       // 5614
/*                                                                                                                     // 5615
 * ----------------------------------------------------------------                                                    // 5616
 * EventDispatcher                                                                                                     // 5617
 * ----------------------------------------------------------------                                                    // 5618
 */                                                                                                                    // 5619
		var EventDispatcher = _class("events.EventDispatcher", function(target) {                                            // 5620
			this._listeners = {};                                                                                               // 5621
			this._eventTarget = target || this;                                                                                 // 5622
		});                                                                                                                  // 5623
		p = EventDispatcher.prototype;                                                                                       // 5624
                                                                                                                       // 5625
		p.addEventListener = function(type, callback, scope, useParam, priority) {                                           // 5626
			priority = priority || 0;                                                                                           // 5627
			var list = this._listeners[type],                                                                                   // 5628
				index = 0,                                                                                                         // 5629
				listener, i;                                                                                                       // 5630
			if (list == null) {                                                                                                 // 5631
				this._listeners[type] = list = [];                                                                                 // 5632
			}                                                                                                                   // 5633
			i = list.length;                                                                                                    // 5634
			while (--i > -1) {                                                                                                  // 5635
				listener = list[i];                                                                                                // 5636
				if (listener.c === callback && listener.s === scope) {                                                             // 5637
					list.splice(i, 1);                                                                                                // 5638
				} else if (index === 0 && listener.pr < priority) {                                                                // 5639
					index = i + 1;                                                                                                    // 5640
				}                                                                                                                  // 5641
			}                                                                                                                   // 5642
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});                                             // 5643
			if (this === _ticker && !_tickerActive) {                                                                           // 5644
				_ticker.wake();                                                                                                    // 5645
			}                                                                                                                   // 5646
		};                                                                                                                   // 5647
                                                                                                                       // 5648
		p.removeEventListener = function(type, callback) {                                                                   // 5649
			var list = this._listeners[type], i;                                                                                // 5650
			if (list) {                                                                                                         // 5651
				i = list.length;                                                                                                   // 5652
				while (--i > -1) {                                                                                                 // 5653
					if (list[i].c === callback) {                                                                                     // 5654
						list.splice(i, 1);                                                                                               // 5655
						return;                                                                                                          // 5656
					}                                                                                                                 // 5657
				}                                                                                                                  // 5658
			}                                                                                                                   // 5659
		};                                                                                                                   // 5660
                                                                                                                       // 5661
		p.dispatchEvent = function(type) {                                                                                   // 5662
			var list = this._listeners[type],                                                                                   // 5663
				i, t, listener;                                                                                                    // 5664
			if (list) {                                                                                                         // 5665
				i = list.length;                                                                                                   // 5666
				t = this._eventTarget;                                                                                             // 5667
				while (--i > -1) {                                                                                                 // 5668
					listener = list[i];                                                                                               // 5669
					if (listener) {                                                                                                   // 5670
						if (listener.up) {                                                                                               // 5671
							listener.c.call(listener.s || t, {type:type, target:t});                                                        // 5672
						} else {                                                                                                         // 5673
							listener.c.call(listener.s || t);                                                                               // 5674
						}                                                                                                                // 5675
					}                                                                                                                 // 5676
				}                                                                                                                  // 5677
			}                                                                                                                   // 5678
		};                                                                                                                   // 5679
                                                                                                                       // 5680
                                                                                                                       // 5681
/*                                                                                                                     // 5682
 * ----------------------------------------------------------------                                                    // 5683
 * Ticker                                                                                                              // 5684
 * ----------------------------------------------------------------                                                    // 5685
 */                                                                                                                    // 5686
 		var _reqAnimFrame = window.requestAnimationFrame,                                                                   // 5687
			_cancelAnimFrame = window.cancelAnimationFrame,                                                                     // 5688
			_getTime = Date.now || function() {return new Date().getTime();},                                                   // 5689
			_lastUpdate = _getTime();                                                                                           // 5690
                                                                                                                       // 5691
		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];                                                                                       // 5693
		i = a.length;                                                                                                        // 5694
		while (--i > -1 && !_reqAnimFrame) {                                                                                 // 5695
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];                                                             // 5696
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];           // 5697
		}                                                                                                                    // 5698
                                                                                                                       // 5699
		_class("Ticker", function(fps, useRAF) {                                                                             // 5700
			var _self = this,                                                                                                   // 5701
				_startTime = _getTime(),                                                                                           // 5702
				_useRAF = (useRAF !== false && _reqAnimFrame),                                                                     // 5703
				_lagThreshold = 500,                                                                                               // 5704
				_adjustedLag = 33,                                                                                                 // 5705
				_tickWord = "tick", //helps reduce gc burden                                                                       // 5706
				_fps, _req, _id, _gap, _nextTime,                                                                                  // 5707
				_tick = function(manual) {                                                                                         // 5708
					var elapsed = _getTime() - _lastUpdate,                                                                           // 5709
						overlap, dispatch;                                                                                               // 5710
					if (elapsed > _lagThreshold) {                                                                                    // 5711
						_startTime += elapsed - _adjustedLag;                                                                            // 5712
					}                                                                                                                 // 5713
					_lastUpdate += elapsed;                                                                                           // 5714
					_self.time = (_lastUpdate - _startTime) / 1000;                                                                   // 5715
					overlap = _self.time - _nextTime;                                                                                 // 5716
					if (!_fps || overlap > 0 || manual === true) {                                                                    // 5717
						_self.frame++;                                                                                                   // 5718
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);                                               // 5719
						dispatch = true;                                                                                                 // 5720
					}                                                                                                                 // 5721
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);                                                                                               // 5723
					}                                                                                                                 // 5724
					if (dispatch) {                                                                                                   // 5725
						_self.dispatchEvent(_tickWord);                                                                                  // 5726
					}                                                                                                                 // 5727
				};                                                                                                                 // 5728
                                                                                                                       // 5729
			EventDispatcher.call(_self);                                                                                        // 5730
			_self.time = _self.frame = 0;                                                                                       // 5731
			_self.tick = function() {                                                                                           // 5732
				_tick(true);                                                                                                       // 5733
			};                                                                                                                  // 5734
                                                                                                                       // 5735
			_self.lagSmoothing = function(threshold, adjustedLag) {                                                             // 5736
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited                   // 5737
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);                                                            // 5738
			};                                                                                                                  // 5739
                                                                                                                       // 5740
			_self.sleep = function() {                                                                                          // 5741
				if (_id == null) {                                                                                                 // 5742
					return;                                                                                                           // 5743
				}                                                                                                                  // 5744
				if (!_useRAF || !_cancelAnimFrame) {                                                                               // 5745
					clearTimeout(_id);                                                                                                // 5746
				} else {                                                                                                           // 5747
					_cancelAnimFrame(_id);                                                                                            // 5748
				}                                                                                                                  // 5749
				_req = _emptyFunc;                                                                                                 // 5750
				_id = null;                                                                                                        // 5751
				if (_self === _ticker) {                                                                                           // 5752
					_tickerActive = false;                                                                                            // 5753
				}                                                                                                                  // 5754
			};                                                                                                                  // 5755
                                                                                                                       // 5756
			_self.wake = function() {                                                                                           // 5757
				if (_id !== null) {                                                                                                // 5758
					_self.sleep();                                                                                                    // 5759
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;                                                                     // 5761
				}                                                                                                                  // 5762
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {                                                                                           // 5764
					_tickerActive = true;                                                                                             // 5765
				}                                                                                                                  // 5766
				_tick(2);                                                                                                          // 5767
			};                                                                                                                  // 5768
                                                                                                                       // 5769
			_self.fps = function(value) {                                                                                       // 5770
				if (!arguments.length) {                                                                                           // 5771
					return _fps;                                                                                                      // 5772
				}                                                                                                                  // 5773
				_fps = value;                                                                                                      // 5774
				_gap = 1 / (_fps || 60);                                                                                           // 5775
				_nextTime = this.time + _gap;                                                                                      // 5776
				_self.wake();                                                                                                      // 5777
			};                                                                                                                  // 5778
                                                                                                                       // 5779
			_self.useRAF = function(value) {                                                                                    // 5780
				if (!arguments.length) {                                                                                           // 5781
					return _useRAF;                                                                                                   // 5782
				}                                                                                                                  // 5783
				_self.sleep();                                                                                                     // 5784
				_useRAF = value;                                                                                                   // 5785
				_self.fps(_fps);                                                                                                   // 5786
			};                                                                                                                  // 5787
			_self.fps(fps);                                                                                                     // 5788
                                                                                                                       // 5789
			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {                                                                                             // 5791
				if (_useRAF && (!_id || _self.frame < 5)) {                                                                        // 5792
					_self.useRAF(false);                                                                                              // 5793
				}                                                                                                                  // 5794
			}, 1500);                                                                                                           // 5795
		});                                                                                                                  // 5796
                                                                                                                       // 5797
		p = gs.Ticker.prototype = new gs.events.EventDispatcher();                                                           // 5798
		p.constructor = gs.Ticker;                                                                                           // 5799
                                                                                                                       // 5800
                                                                                                                       // 5801
/*                                                                                                                     // 5802
 * ----------------------------------------------------------------                                                    // 5803
 * Animation                                                                                                           // 5804
 * ----------------------------------------------------------------                                                    // 5805
 */                                                                                                                    // 5806
		var Animation = _class("core.Animation", function(duration, vars) {                                                  // 5807
				this.vars = vars = vars || {};                                                                                     // 5808
				this._duration = this._totalDuration = duration || 0;                                                              // 5809
				this._delay = Number(vars.delay) || 0;                                                                             // 5810
				this._timeScale = 1;                                                                                               // 5811
				this._active = (vars.immediateRender === true);                                                                    // 5812
				this.data = vars.data;                                                                                             // 5813
				this._reversed = (vars.reversed === true);                                                                         // 5814
                                                                                                                       // 5815
				if (!_rootTimeline) {                                                                                              // 5816
					return;                                                                                                           // 5817
				}                                                                                                                  // 5818
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();                                                                                                   // 5820
				}                                                                                                                  // 5821
                                                                                                                       // 5822
				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;                                                // 5823
				tl.add(this, tl._time);                                                                                            // 5824
                                                                                                                       // 5825
				if (this.vars.paused) {                                                                                            // 5826
					this.paused(true);                                                                                                // 5827
				}                                                                                                                  // 5828
			});                                                                                                                 // 5829
                                                                                                                       // 5830
		_ticker = Animation.ticker = new gs.Ticker();                                                                        // 5831
		p = Animation.prototype;                                                                                             // 5832
		p._dirty = p._gc = p._initted = p._paused = false;                                                                   // 5833
		p._totalTime = p._time = 0;                                                                                          // 5834
		p._rawPrevTime = -1;                                                                                                 // 5835
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;                                                   // 5836
		p._paused = false;                                                                                                   // 5837
                                                                                                                       // 5838
                                                                                                                       // 5839
		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {                                                                                     // 5841
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {                                                            // 5842
					_ticker.wake();                                                                                                   // 5843
				}                                                                                                                  // 5844
				setTimeout(_checkTimeout, 2000);                                                                                   // 5845
			};                                                                                                                  // 5846
		_checkTimeout();                                                                                                     // 5847
                                                                                                                       // 5848
                                                                                                                       // 5849
		p.play = function(from, suppressEvents) {                                                                            // 5850
			if (from != null) {                                                                                                 // 5851
				this.seek(from, suppressEvents);                                                                                   // 5852
			}                                                                                                                   // 5853
			return this.reversed(false).paused(false);                                                                          // 5854
		};                                                                                                                   // 5855
                                                                                                                       // 5856
		p.pause = function(atTime, suppressEvents) {                                                                         // 5857
			if (atTime != null) {                                                                                               // 5858
				this.seek(atTime, suppressEvents);                                                                                 // 5859
			}                                                                                                                   // 5860
			return this.paused(true);                                                                                           // 5861
		};                                                                                                                   // 5862
                                                                                                                       // 5863
		p.resume = function(from, suppressEvents) {                                                                          // 5864
			if (from != null) {                                                                                                 // 5865
				this.seek(from, suppressEvents);                                                                                   // 5866
			}                                                                                                                   // 5867
			return this.paused(false);                                                                                          // 5868
		};                                                                                                                   // 5869
                                                                                                                       // 5870
		p.seek = function(time, suppressEvents) {                                                                            // 5871
			return this.totalTime(Number(time), suppressEvents !== false);                                                      // 5872
		};                                                                                                                   // 5873
                                                                                                                       // 5874
		p.restart = function(includeDelay, suppressEvents) {                                                                 // 5875
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};                                                                                                                   // 5877
                                                                                                                       // 5878
		p.reverse = function(from, suppressEvents) {                                                                         // 5879
			if (from != null) {                                                                                                 // 5880
				this.seek((from || this.totalDuration()), suppressEvents);                                                         // 5881
			}                                                                                                                   // 5882
			return this.reversed(true).paused(false);                                                                           // 5883
		};                                                                                                                   // 5884
                                                                                                                       // 5885
		p.render = function(time, suppressEvents, force) {                                                                   // 5886
			//stub - we override this method in subclasses.                                                                     // 5887
		};                                                                                                                   // 5888
                                                                                                                       // 5889
		p.invalidate = function() {                                                                                          // 5890
			this._time = this._totalTime = 0;                                                                                   // 5891
			this._initted = this._gc = false;                                                                                   // 5892
			this._rawPrevTime = -1;                                                                                             // 5893
			if (this._gc || !this.timeline) {                                                                                   // 5894
				this._enabled(true);                                                                                               // 5895
			}                                                                                                                   // 5896
			return this;                                                                                                        // 5897
		};                                                                                                                   // 5898
                                                                                                                       // 5899
		p.isActive = function() {                                                                                            // 5900
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.                      // 5901
				startTime = this._startTime,                                                                                       // 5902
				rawTime;                                                                                                           // 5903
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};                                                                                                                   // 5905
                                                                                                                       // 5906
		p._enabled = function (enabled, ignoreTimeline) {                                                                    // 5907
			if (!_tickerActive) {                                                                                               // 5908
				_ticker.wake();                                                                                                    // 5909
			}                                                                                                                   // 5910
			this._gc = !enabled;                                                                                                // 5911
			this._active = this.isActive();                                                                                     // 5912
			if (ignoreTimeline !== true) {                                                                                      // 5913
				if (enabled && !this.timeline) {                                                                                   // 5914
					this._timeline.add(this, this._startTime - this._delay);                                                          // 5915
				} else if (!enabled && this.timeline) {                                                                            // 5916
					this._timeline._remove(this, true);                                                                               // 5917
				}                                                                                                                  // 5918
			}                                                                                                                   // 5919
			return false;                                                                                                       // 5920
		};                                                                                                                   // 5921
                                                                                                                       // 5922
                                                                                                                       // 5923
		p._kill = function(vars, target) {                                                                                   // 5924
			return this._enabled(false, false);                                                                                 // 5925
		};                                                                                                                   // 5926
                                                                                                                       // 5927
		p.kill = function(vars, target) {                                                                                    // 5928
			this._kill(vars, target);                                                                                           // 5929
			return this;                                                                                                        // 5930
		};                                                                                                                   // 5931
                                                                                                                       // 5932
		p._uncache = function(includeSelf) {                                                                                 // 5933
			var tween = includeSelf ? this : this.timeline;                                                                     // 5934
			while (tween) {                                                                                                     // 5935
				tween._dirty = true;                                                                                               // 5936
				tween = tween.timeline;                                                                                            // 5937
			}                                                                                                                   // 5938
			return this;                                                                                                        // 5939
		};                                                                                                                   // 5940
                                                                                                                       // 5941
		p._swapSelfInParams = function(params) {                                                                             // 5942
			var i = params.length,                                                                                              // 5943
				copy = params.concat();                                                                                            // 5944
			while (--i > -1) {                                                                                                  // 5945
				if (params[i] === "{self}") {                                                                                      // 5946
					copy[i] = this;                                                                                                   // 5947
				}                                                                                                                  // 5948
			}                                                                                                                   // 5949
			return copy;                                                                                                        // 5950
		};                                                                                                                   // 5951
                                                                                                                       // 5952
//----Animation getters/setters --------------------------------------------------------                               // 5953
                                                                                                                       // 5954
		p.eventCallback = function(type, callback, params, scope) {                                                          // 5955
			if ((type || "").substr(0,2) === "on") {                                                                            // 5956
				var v = this.vars;                                                                                                 // 5957
				if (arguments.length === 1) {                                                                                      // 5958
					return v[type];                                                                                                   // 5959
				}                                                                                                                  // 5960
				if (callback == null) {                                                                                            // 5961
					delete v[type];                                                                                                   // 5962
				} else {                                                                                                           // 5963
					v[type] = callback;                                                                                               // 5964
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;                                                                                        // 5966
				}                                                                                                                  // 5967
				if (type === "onUpdate") {                                                                                         // 5968
					this._onUpdate = callback;                                                                                        // 5969
				}                                                                                                                  // 5970
			}                                                                                                                   // 5971
			return this;                                                                                                        // 5972
		};                                                                                                                   // 5973
                                                                                                                       // 5974
		p.delay = function(value) {                                                                                          // 5975
			if (!arguments.length) {                                                                                            // 5976
				return this._delay;                                                                                                // 5977
			}                                                                                                                   // 5978
			if (this._timeline.smoothChildTiming) {                                                                             // 5979
				this.startTime( this._startTime + value - this._delay );                                                           // 5980
			}                                                                                                                   // 5981
			this._delay = value;                                                                                                // 5982
			return this;                                                                                                        // 5983
		};                                                                                                                   // 5984
                                                                                                                       // 5985
		p.duration = function(value) {                                                                                       // 5986
			if (!arguments.length) {                                                                                            // 5987
				this._dirty = false;                                                                                               // 5988
				return this._duration;                                                                                             // 5989
			}                                                                                                                   // 5990
			this._duration = this._totalDuration = value;                                                                       // 5991
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {       // 5993
				this.totalTime(this._totalTime * (value / this._duration), true);                                                  // 5994
			}                                                                                                                   // 5995
			return this;                                                                                                        // 5996
		};                                                                                                                   // 5997
                                                                                                                       // 5998
		p.totalDuration = function(value) {                                                                                  // 5999
			this._dirty = false;                                                                                                // 6000
			return (!arguments.length) ? this._totalDuration : this.duration(value);                                            // 6001
		};                                                                                                                   // 6002
                                                                                                                       // 6003
		p.time = function(value, suppressEvents) {                                                                           // 6004
			if (!arguments.length) {                                                                                            // 6005
				return this._time;                                                                                                 // 6006
			}                                                                                                                   // 6007
			if (this._dirty) {                                                                                                  // 6008
				this.totalDuration();                                                                                              // 6009
			}                                                                                                                   // 6010
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);                           // 6011
		};                                                                                                                   // 6012
                                                                                                                       // 6013
		p.totalTime = function(time, suppressEvents, uncapped) {                                                             // 6014
			if (!_tickerActive) {                                                                                               // 6015
				_ticker.wake();                                                                                                    // 6016
			}                                                                                                                   // 6017
			if (!arguments.length) {                                                                                            // 6018
				return this._totalTime;                                                                                            // 6019
			}                                                                                                                   // 6020
			if (this._timeline) {                                                                                               // 6021
				if (time < 0 && !uncapped) {                                                                                       // 6022
					time += this.totalDuration();                                                                                     // 6023
				}                                                                                                                  // 6024
				if (this._timeline.smoothChildTiming) {                                                                            // 6025
					if (this._dirty) {                                                                                                // 6026
						this.totalDuration();                                                                                            // 6027
					}                                                                                                                 // 6028
					var totalDuration = this._totalDuration,                                                                          // 6029
						tl = this._timeline;                                                                                             // 6030
					if (time > totalDuration && !uncapped) {                                                                          // 6031
						time = totalDuration;                                                                                            // 6032
					}                                                                                                                 // 6033
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);                                                                                            // 6036
					}                                                                                                                 // 6037
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {                                                                                               // 6039
						while (tl._timeline) {                                                                                           // 6040
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {                                   // 6041
								tl.totalTime(tl._totalTime, true);                                                                             // 6042
							}                                                                                                               // 6043
							tl = tl._timeline;                                                                                              // 6044
						}                                                                                                                // 6045
					}                                                                                                                 // 6046
				}                                                                                                                  // 6047
				if (this._gc) {                                                                                                    // 6048
					this._enabled(true, false);                                                                                       // 6049
				}                                                                                                                  // 6050
				if (this._totalTime !== time || this._duration === 0) {                                                            // 6051
					this.render(time, suppressEvents, false);                                                                         // 6052
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();                                                                                                   // 6054
					}                                                                                                                 // 6055
				}                                                                                                                  // 6056
			}                                                                                                                   // 6057
			return this;                                                                                                        // 6058
		};                                                                                                                   // 6059
                                                                                                                       // 6060
		p.progress = p.totalProgress = function(value, suppressEvents) {                                                     // 6061
			return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
		};                                                                                                                   // 6063
                                                                                                                       // 6064
		p.startTime = function(value) {                                                                                      // 6065
			if (!arguments.length) {                                                                                            // 6066
				return this._startTime;                                                                                            // 6067
			}                                                                                                                   // 6068
			if (value !== this._startTime) {                                                                                    // 6069
				this._startTime = value;                                                                                           // 6070
				if (this.timeline) if (this.timeline._sortChildren) {                                                              // 6071
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}                                                                                                                  // 6073
			}                                                                                                                   // 6074
			return this;                                                                                                        // 6075
		};                                                                                                                   // 6076
                                                                                                                       // 6077
		p.endTime = function(includeRepeats) {                                                                               // 6078
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;    // 6079
		};                                                                                                                   // 6080
                                                                                                                       // 6081
		p.timeScale = function(value) {                                                                                      // 6082
			if (!arguments.length) {                                                                                            // 6083
				return this._timeScale;                                                                                            // 6084
			}                                                                                                                   // 6085
			value = value || _tinyNum; //can't allow zero because it'll throw the math off                                      // 6086
			if (this._timeline && this._timeline.smoothChildTiming) {                                                           // 6087
				var pauseTime = this._pauseTime,                                                                                   // 6088
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();                                      // 6089
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);                                           // 6090
			}                                                                                                                   // 6091
			this._timeScale = value;                                                                                            // 6092
			return this._uncache(false);                                                                                        // 6093
		};                                                                                                                   // 6094
                                                                                                                       // 6095
		p.reversed = function(value) {                                                                                       // 6096
			if (!arguments.length) {                                                                                            // 6097
				return this._reversed;                                                                                             // 6098
			}                                                                                                                   // 6099
			if (value != this._reversed) {                                                                                      // 6100
				this._reversed = value;                                                                                            // 6101
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}                                                                                                                   // 6103
			return this;                                                                                                        // 6104
		};                                                                                                                   // 6105
                                                                                                                       // 6106
		p.paused = function(value) {                                                                                         // 6107
			if (!arguments.length) {                                                                                            // 6108
				return this._paused;                                                                                               // 6109
			}                                                                                                                   // 6110
			var tl = this._timeline,                                                                                            // 6111
				raw, elapsed;                                                                                                      // 6112
			if (value != this._paused) if (tl) {                                                                                // 6113
				if (!_tickerActive && !value) {                                                                                    // 6114
					_ticker.wake();                                                                                                   // 6115
				}                                                                                                                  // 6116
				raw = tl.rawTime();                                                                                                // 6117
				elapsed = raw - this._pauseTime;                                                                                   // 6118
				if (!value && tl.smoothChildTiming) {                                                                              // 6119
					this._startTime += elapsed;                                                                                       // 6120
					this._uncache(false);                                                                                             // 6121
				}                                                                                                                  // 6122
				this._pauseTime = value ? raw : null;                                                                              // 6123
				this._paused = value;                                                                                              // 6124
				this._active = this.isActive();                                                                                    // 6125
				if (!value && elapsed !== 0 && this._initted && this.duration()) {                                                 // 6126
					this.render((tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}                                                                                                                  // 6128
			}                                                                                                                   // 6129
			if (this._gc && !value) {                                                                                           // 6130
				this._enabled(true, false);                                                                                        // 6131
			}                                                                                                                   // 6132
			return this;                                                                                                        // 6133
		};                                                                                                                   // 6134
                                                                                                                       // 6135
                                                                                                                       // 6136
/*                                                                                                                     // 6137
 * ----------------------------------------------------------------                                                    // 6138
 * SimpleTimeline                                                                                                      // 6139
 * ----------------------------------------------------------------                                                    // 6140
 */                                                                                                                    // 6141
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {                                                  // 6142
			Animation.call(this, 0, vars);                                                                                      // 6143
			this.autoRemoveChildren = this.smoothChildTiming = true;                                                            // 6144
		});                                                                                                                  // 6145
                                                                                                                       // 6146
		p = SimpleTimeline.prototype = new Animation();                                                                      // 6147
		p.constructor = SimpleTimeline;                                                                                      // 6148
		p.kill()._gc = false;                                                                                                // 6149
		p._first = p._last = p._recent = null;                                                                               // 6150
		p._sortChildren = false;                                                                                             // 6151
                                                                                                                       // 6152
		p.add = p.insert = function(child, position, align, stagger) {                                                       // 6153
			var prevTween, st;                                                                                                  // 6154
			child._startTime = Number(position || 0) + child._delay;                                                            // 6155
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);                    // 6157
			}                                                                                                                   // 6158
			if (child.timeline) {                                                                                               // 6159
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}                                                                                                                   // 6161
			child.timeline = child._timeline = this;                                                                            // 6162
			if (child._gc) {                                                                                                    // 6163
				child._enabled(true, true);                                                                                        // 6164
			}                                                                                                                   // 6165
			prevTween = this._last;                                                                                             // 6166
			if (this._sortChildren) {                                                                                           // 6167
				st = child._startTime;                                                                                             // 6168
				while (prevTween && prevTween._startTime > st) {                                                                   // 6169
					prevTween = prevTween._prev;                                                                                      // 6170
				}                                                                                                                  // 6171
			}                                                                                                                   // 6172
			if (prevTween) {                                                                                                    // 6173
				child._next = prevTween._next;                                                                                     // 6174
				prevTween._next = child;                                                                                           // 6175
			} else {                                                                                                            // 6176
				child._next = this._first;                                                                                         // 6177
				this._first = child;                                                                                               // 6178
			}                                                                                                                   // 6179
			if (child._next) {                                                                                                  // 6180
				child._next._prev = child;                                                                                         // 6181
			} else {                                                                                                            // 6182
				this._last = child;                                                                                                // 6183
			}                                                                                                                   // 6184
			child._prev = prevTween;                                                                                            // 6185
			this._recent = child;                                                                                               // 6186
			if (this._timeline) {                                                                                               // 6187
				this._uncache(true);                                                                                               // 6188
			}                                                                                                                   // 6189
			return this;                                                                                                        // 6190
		};                                                                                                                   // 6191
                                                                                                                       // 6192
		p._remove = function(tween, skipDisable) {                                                                           // 6193
			if (tween.timeline === this) {                                                                                      // 6194
				if (!skipDisable) {                                                                                                // 6195
					tween._enabled(false, true);                                                                                      // 6196
				}                                                                                                                  // 6197
                                                                                                                       // 6198
				if (tween._prev) {                                                                                                 // 6199
					tween._prev._next = tween._next;                                                                                  // 6200
				} else if (this._first === tween) {                                                                                // 6201
					this._first = tween._next;                                                                                        // 6202
				}                                                                                                                  // 6203
				if (tween._next) {                                                                                                 // 6204
					tween._next._prev = tween._prev;                                                                                  // 6205
				} else if (this._last === tween) {                                                                                 // 6206
					this._last = tween._prev;                                                                                         // 6207
				}                                                                                                                  // 6208
				tween._next = tween._prev = tween.timeline = null;                                                                 // 6209
				if (tween === this._recent) {                                                                                      // 6210
					this._recent = this._last;                                                                                        // 6211
				}                                                                                                                  // 6212
                                                                                                                       // 6213
				if (this._timeline) {                                                                                              // 6214
					this._uncache(true);                                                                                              // 6215
				}                                                                                                                  // 6216
			}                                                                                                                   // 6217
			return this;                                                                                                        // 6218
		};                                                                                                                   // 6219
                                                                                                                       // 6220
		p.render = function(time, suppressEvents, force) {                                                                   // 6221
			var tween = this._first,                                                                                            // 6222
				next;                                                                                                              // 6223
			this._totalTime = this._time = this._rawPrevTime = time;                                                            // 6224
			while (tween) {                                                                                                     // 6225
				next = tween._next; //record it here because the value could change after rendering...                             // 6226
				if (tween._active || (time >= tween._startTime && !tween._paused)) {                                               // 6227
					if (!tween._reversed) {                                                                                           // 6228
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);                               // 6229
					} else {                                                                                                          // 6230
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}                                                                                                                 // 6232
				}                                                                                                                  // 6233
				tween = next;                                                                                                      // 6234
			}                                                                                                                   // 6235
		};                                                                                                                   // 6236
                                                                                                                       // 6237
		p.rawTime = function() {                                                                                             // 6238
			if (!_tickerActive) {                                                                                               // 6239
				_ticker.wake();                                                                                                    // 6240
			}                                                                                                                   // 6241
			return this._totalTime;                                                                                             // 6242
		};                                                                                                                   // 6243
                                                                                                                       // 6244
/*                                                                                                                     // 6245
 * ----------------------------------------------------------------                                                    // 6246
 * TweenLite                                                                                                           // 6247
 * ----------------------------------------------------------------                                                    // 6248
 */                                                                                                                    // 6249
		var TweenLite = _class("TweenLite", function(target, duration, vars) {                                               // 6250
				Animation.call(this, duration, vars);                                                                              // 6251
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)       // 6252
                                                                                                                       // 6253
				if (target == null) {                                                                                              // 6254
					throw "Cannot tween a null target.";                                                                              // 6255
				}                                                                                                                  // 6256
                                                                                                                       // 6257
				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;              // 6258
                                                                                                                       // 6259
				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,                                                                                  // 6261
					i, targ, targets;                                                                                                 // 6262
                                                                                                                       // 6263
				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];
                                                                                                                       // 6265
				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];                                                                                            // 6268
					this._siblings = [];                                                                                              // 6269
					for (i = 0; i < targets.length; i++) {                                                                            // 6270
						targ = targets[i];                                                                                               // 6271
						if (!targ) {                                                                                                     // 6272
							targets.splice(i--, 1);                                                                                         // 6273
							continue;                                                                                                       // 6274
						} else if (typeof(targ) === "string") {                                                                          // 6275
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings                              // 6276
							if (typeof(targ) === "string") {                                                                                // 6277
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}                                                                                                               // 6279
							continue;                                                                                                       // 6280
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);                                                                                         // 6282
							this._targets = targets = targets.concat(_slice(targ));                                                         // 6283
							continue;                                                                                                       // 6284
						}                                                                                                                // 6285
						this._siblings[i] = _register(targ, this, false);                                                                // 6286
						if (overwrite === 1) if (this._siblings[i].length > 1) {                                                         // 6287
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);                                                        // 6288
						}                                                                                                                // 6289
					}                                                                                                                 // 6290
                                                                                                                       // 6291
				} else {                                                                                                           // 6292
					this._propLookup = {};                                                                                            // 6293
					this._siblings = _register(target, this, false);                                                                  // 6294
					if (overwrite === 1) if (this._siblings.length > 1) {                                                             // 6295
						_applyOverwrite(target, this, null, 1, this._siblings);                                                          // 6296
					}                                                                                                                 // 6297
				}                                                                                                                  // 6298
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {   // 6299
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(-this._delay);                                                                                        // 6301
				}                                                                                                                  // 6302
			}, true),                                                                                                           // 6303
			_isSelector = function(v) {                                                                                         // 6304
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},                                                                                                                  // 6306
			_autoCSS = function(vars, target) {                                                                                 // 6307
				var css = {},                                                                                                      // 6308
					p;                                                                                                                // 6309
				for (p in vars) {                                                                                                  // 6310
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];                                                                                                // 6312
						delete vars[p];                                                                                                  // 6313
					}                                                                                                                 // 6314
				}                                                                                                                  // 6315
				vars.css = css;                                                                                                    // 6316
			};                                                                                                                  // 6317
                                                                                                                       // 6318
		p = TweenLite.prototype = new Animation();                                                                           // 6319
		p.constructor = TweenLite;                                                                                           // 6320
		p.kill()._gc = false;                                                                                                // 6321
                                                                                                                       // 6322
//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------  // 6323
                                                                                                                       // 6324
		p.ratio = 0;                                                                                                         // 6325
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;                                                   // 6326
		p._notifyPluginsOfEnabled = p._lazy = false;                                                                         // 6327
                                                                                                                       // 6328
		TweenLite.version = "1.16.0";                                                                                        // 6329
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);                                                        // 6330
		TweenLite.defaultOverwrite = "auto";                                                                                 // 6331
		TweenLite.ticker = _ticker;                                                                                          // 6332
		TweenLite.autoSleep = 120;                                                                                           // 6333
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {                                                          // 6334
			_ticker.lagSmoothing(threshold, adjustedLag);                                                                       // 6335
		};                                                                                                                   // 6336
                                                                                                                       // 6337
		TweenLite.selector = window.$ || window.jQuery || function(e) {                                                      // 6338
			var selector = window.$ || window.jQuery;                                                                           // 6339
			if (selector) {                                                                                                     // 6340
				TweenLite.selector = selector;                                                                                     // 6341
				return selector(e);                                                                                                // 6342
			}                                                                                                                   // 6343
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};                                                                                                                   // 6345
                                                                                                                       // 6346
		var _lazyTweens = [],                                                                                                // 6347
			_lazyLookup = {},                                                                                                   // 6348
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},                                                                                 // 6350
			_tweenLookup = _internals.tweenLookup = {},                                                                         // 6351
			_tweenLookupNum = 0,                                                                                                // 6352
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},         // 6354
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),                                         // 6355
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),                                                     // 6356
			_nextGCFrame = 30,                                                                                                  // 6357
			_lazyRender = _internals.lazyRender = function() {                                                                  // 6358
				var i = _lazyTweens.length,                                                                                        // 6359
					tween;                                                                                                            // 6360
				_lazyLookup = {};                                                                                                  // 6361
				while (--i > -1) {                                                                                                 // 6362
					tween = _lazyTweens[i];                                                                                           // 6363
					if (tween && tween._lazy !== false) {                                                                             // 6364
						tween.render(tween._lazy[0], tween._lazy[1], true);                                                              // 6365
						tween._lazy = false;                                                                                             // 6366
					}                                                                                                                 // 6367
				}                                                                                                                  // 6368
				_lazyTweens.length = 0;                                                                                            // 6369
			};                                                                                                                  // 6370
                                                                                                                       // 6371
		_rootTimeline._startTime = _ticker.time;                                                                             // 6372
		_rootFramesTimeline._startTime = _ticker.frame;                                                                      // 6373
		_rootTimeline._active = _rootFramesTimeline._active = true;                                                          // 6374
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".
                                                                                                                       // 6376
		Animation._updateRoot = TweenLite.render = function() {                                                              // 6377
				var i, a, p;                                                                                                       // 6378
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();                                                                                                    // 6380
				}                                                                                                                  // 6381
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);          // 6382
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {                                                                                          // 6384
					_lazyRender();                                                                                                    // 6385
				}                                                                                                                  // 6386
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);                                        // 6388
					for (p in _tweenLookup) {                                                                                         // 6389
						a = _tweenLookup[p].tweens;                                                                                      // 6390
						i = a.length;                                                                                                    // 6391
						while (--i > -1) {                                                                                               // 6392
							if (a[i]._gc) {                                                                                                 // 6393
								a.splice(i, 1);                                                                                                // 6394
							}                                                                                                               // 6395
						}                                                                                                                // 6396
						if (a.length === 0) {                                                                                            // 6397
							delete _tweenLookup[p];                                                                                         // 6398
						}                                                                                                                // 6399
					}                                                                                                                 // 6400
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;                                                                                         // 6402
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {                                                                                         // 6404
							p = p._next;                                                                                                    // 6405
						}                                                                                                                // 6406
						if (!p) {                                                                                                        // 6407
							_ticker.sleep();                                                                                                // 6408
						}                                                                                                                // 6409
					}                                                                                                                 // 6410
				}                                                                                                                  // 6411
			};                                                                                                                  // 6412
                                                                                                                       // 6413
		_ticker.addEventListener("tick", Animation._updateRoot);                                                             // 6414
                                                                                                                       // 6415
		var _register = function(target, tween, scrub) {                                                                     // 6416
				var id = target._gsTweenID, a, i;                                                                                  // 6417
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {                                   // 6418
					_tweenLookup[id] = {target:target, tweens:[]};                                                                    // 6419
				}                                                                                                                  // 6420
				if (tween) {                                                                                                       // 6421
					a = _tweenLookup[id].tweens;                                                                                      // 6422
					a[(i = a.length)] = tween;                                                                                        // 6423
					if (scrub) {                                                                                                      // 6424
						while (--i > -1) {                                                                                               // 6425
							if (a[i] === tween) {                                                                                           // 6426
								a.splice(i, 1);                                                                                                // 6427
							}                                                                                                               // 6428
						}                                                                                                                // 6429
					}                                                                                                                 // 6430
				}                                                                                                                  // 6431
				return _tweenLookup[id].tweens;                                                                                    // 6432
			},                                                                                                                  // 6433
                                                                                                                       // 6434
			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {                                  // 6435
				var func = overwrittenTween.vars.onOverwrite, r1, r2;                                                              // 6436
				if (func) {                                                                                                        // 6437
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);                                               // 6438
				}                                                                                                                  // 6439
				func = TweenLite.onOverwrite;                                                                                      // 6440
				if (func) {                                                                                                        // 6441
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);                                               // 6442
				}                                                                                                                  // 6443
				return (r1 !== false && r2 !== false);                                                                             // 6444
			},                                                                                                                  // 6445
			_applyOverwrite = function(target, tween, props, mode, siblings) {                                                  // 6446
				var i, changed, curTween, l;                                                                                       // 6447
				if (mode === 1 || mode >= 4) {                                                                                     // 6448
					l = siblings.length;                                                                                              // 6449
					for (i = 0; i < l; i++) {                                                                                         // 6450
						if ((curTween = siblings[i]) !== tween) {                                                                        // 6451
							if (!curTween._gc) {                                                                                            // 6452
								if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {                                        // 6453
									changed = true;                                                                                               // 6454
								}                                                                                                              // 6455
							}                                                                                                               // 6456
						} else if (mode === 5) {                                                                                         // 6457
							break;                                                                                                          // 6458
						}                                                                                                                // 6459
					}                                                                                                                 // 6460
					return changed;                                                                                                   // 6461
				}                                                                                                                  // 6462
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,                                                                       // 6464
					overlaps = [],                                                                                                    // 6465
					oCount = 0,                                                                                                       // 6466
					zeroDur = (tween._duration === 0),                                                                                // 6467
					globalStart;                                                                                                      // 6468
				i = siblings.length;                                                                                               // 6469
				while (--i > -1) {                                                                                                 // 6470
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {                                     // 6471
						//ignore                                                                                                         // 6472
					} else if (curTween._timeline !== tween._timeline) {                                                              // 6473
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);                                                   // 6474
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {                                                       // 6475
							overlaps[oCount++] = curTween;                                                                                  // 6476
						}                                                                                                                // 6477
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;                                                                                   // 6479
					}                                                                                                                 // 6480
				}                                                                                                                  // 6481
                                                                                                                       // 6482
				i = oCount;                                                                                                        // 6483
				while (--i > -1) {                                                                                                 // 6484
					curTween = overlaps[i];                                                                                           // 6485
					if (mode === 2) if (curTween._kill(props, target, tween)) {                                                       // 6486
						changed = true;                                                                                                  // 6487
					}                                                                                                                 // 6488
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {                                                    // 6489
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {                                                              // 6490
							continue;                                                                                                       // 6491
						}                                                                                                                // 6492
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.           // 6493
							changed = true;                                                                                                 // 6494
						}                                                                                                                // 6495
					}                                                                                                                 // 6496
				}                                                                                                                  // 6497
				return changed;                                                                                                    // 6498
			},                                                                                                                  // 6499
                                                                                                                       // 6500
			_checkOverlap = function(tween, reference, zeroDur) {                                                               // 6501
				var tl = tween._timeline,                                                                                          // 6502
					ts = tl._timeScale,                                                                                               // 6503
					t = tween._startTime;                                                                                             // 6504
				while (tl._timeline) {                                                                                             // 6505
					t += tl._startTime;                                                                                               // 6506
					ts *= tl._timeScale;                                                                                              // 6507
					if (tl._paused) {                                                                                                 // 6508
						return -100;                                                                                                     // 6509
					}                                                                                                                 // 6510
					tl = tl._timeline;                                                                                                // 6511
				}                                                                                                                  // 6512
				t /= ts;                                                                                                           // 6513
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};                                                                                                                  // 6515
                                                                                                                       // 6516
                                                                                                                       // 6517
//---- TweenLite instance methods -----------------------------------------------------------------------------        // 6518
                                                                                                                       // 6519
		p._init = function() {                                                                                               // 6520
			var v = this.vars,                                                                                                  // 6521
				op = this._overwrittenProps,                                                                                       // 6522
				dur = this._duration,                                                                                              // 6523
				immediate = !!v.immediateRender,                                                                                   // 6524
				ease = v.ease,                                                                                                     // 6525
				i, initPlugins, pt, p, startVars;                                                                                  // 6526
			if (v.startAt) {                                                                                                    // 6527
				if (this._startAt) {                                                                                               // 6528
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();                                                                                             // 6530
				}                                                                                                                  // 6531
				startVars = {};                                                                                                    // 6532
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];                                                                                      // 6534
				}                                                                                                                  // 6535
				startVars.overwrite = false;                                                                                       // 6536
				startVars.immediateRender = true;                                                                                  // 6537
				startVars.lazy = (immediate && v.lazy !== false);                                                                  // 6538
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);                                                           // 6540
				if (immediate) {                                                                                                   // 6541
					if (this._time > 0) {                                                                                             // 6542
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {                                                                                           // 6544
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}                                                                                                                 // 6546
				}                                                                                                                  // 6547
			} else if (v.runBackwards && dur !== 0) {                                                                           // 6548
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {                                                                                               // 6550
					this._startAt.render(-1, true);                                                                                   // 6551
					this._startAt.kill();                                                                                             // 6552
					this._startAt = null;                                                                                             // 6553
				} else {                                                                                                           // 6554
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;                                                                                               // 6556
					}                                                                                                                 // 6557
					pt = {};                                                                                                          // 6558
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {                                                                     // 6560
							pt[p] = v[p];                                                                                                   // 6561
						}                                                                                                                // 6562
					}                                                                                                                 // 6563
					pt.overwrite = 0;                                                                                                 // 6564
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);                                                                        // 6566
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);                                                                 // 6568
					if (!immediate) {                                                                                                 // 6569
						this._startAt._init(); //ensures that the initial values are recorded                                            // 6570
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {                                                                                 // 6572
							this._startAt = null;                                                                                           // 6573
						}                                                                                                                // 6574
					} else if (this._time === 0) {                                                                                    // 6575
						return;                                                                                                          // 6576
					}                                                                                                                 // 6577
				}                                                                                                                  // 6578
			}                                                                                                                   // 6579
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {                                                                 // 6581
				this._ease = ease.config.apply(ease, v.easeParams);                                                                // 6582
			}                                                                                                                   // 6583
			this._easeType = this._ease._type;                                                                                  // 6584
			this._easePower = this._ease._power;                                                                                // 6585
			this._firstPT = null;                                                                                               // 6586
                                                                                                                       // 6587
			if (this._targets) {                                                                                                // 6588
				i = this._targets.length;                                                                                          // 6589
				while (--i > -1) {                                                                                                 // 6590
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null)) ) {   // 6591
						initPlugins = true;                                                                                              // 6592
					}                                                                                                                 // 6593
				}                                                                                                                  // 6594
			} else {                                                                                                            // 6595
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);                                  // 6596
			}                                                                                                                   // 6597
                                                                                                                       // 6598
			if (initPlugins) {                                                                                                  // 6599
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}                                                                                                                   // 6601
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);                                                                                       // 6603
			}                                                                                                                   // 6604
			if (v.runBackwards) {                                                                                               // 6605
				pt = this._firstPT;                                                                                                // 6606
				while (pt) {                                                                                                       // 6607
					pt.s += pt.c;                                                                                                     // 6608
					pt.c = -pt.c;                                                                                                     // 6609
					pt = pt._next;                                                                                                    // 6610
				}                                                                                                                  // 6611
			}                                                                                                                   // 6612
			this._onUpdate = v.onUpdate;                                                                                        // 6613
			this._initted = true;                                                                                               // 6614
		};                                                                                                                   // 6615
                                                                                                                       // 6616
		p._initProps = function(target, propLookup, siblings, overwrittenProps) {                                            // 6617
			var p, i, initPlugins, plugin, pt, v;                                                                               // 6618
			if (target == null) {                                                                                               // 6619
				return false;                                                                                                      // 6620
			}                                                                                                                   // 6621
                                                                                                                       // 6622
			if (_lazyLookup[target._gsTweenID]) {                                                                               // 6623
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}                                                                                                                   // 6625
                                                                                                                       // 6626
			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);                                                                                       // 6628
			}                                                                                                                   // 6629
			for (p in this.vars) {                                                                                              // 6630
				v = this.vars[p];                                                                                                  // 6631
				if (_reservedProps[p]) {                                                                                           // 6632
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {            // 6633
						this.vars[p] = v = this._swapSelfInParams(v, this);                                                              // 6634
					}                                                                                                                 // 6635
                                                                                                                       // 6636
				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {                 // 6637
                                                                                                                       // 6638
					//t - target 		[object]                                                                                           // 6639
					//p - property 		[string]                                                                                         // 6640
					//s - start			[number]                                                                                            // 6641
					//c - change		[number]                                                                                            // 6642
					//f - isFunction	[boolean]                                                                                        // 6643
					//n - name			[string]                                                                                             // 6644
					//pg - isPlugin 	[boolean]                                                                                        // 6645
					//pr - priority		[number]                                                                                         // 6646
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
					i = plugin._overwriteProps.length;                                                                                // 6648
					while (--i > -1) {                                                                                                // 6649
						propLookup[plugin._overwriteProps[i]] = this._firstPT;                                                           // 6650
					}                                                                                                                 // 6651
					if (plugin._priority || plugin._onInitAllProps) {                                                                 // 6652
						initPlugins = true;                                                                                              // 6653
					}                                                                                                                 // 6654
					if (plugin._onDisable || plugin._onEnable) {                                                                      // 6655
						this._notifyPluginsOfEnabled = true;                                                                             // 6656
					}                                                                                                                 // 6657
                                                                                                                       // 6658
				} else {                                                                                                           // 6659
					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
					pt.c = (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : (Number(v) - pt.s) || 0;
				}                                                                                                                  // 6663
				if (pt) if (pt._next) {                                                                                            // 6664
					pt._next._prev = pt;                                                                                              // 6665
				}                                                                                                                  // 6666
			}                                                                                                                   // 6667
                                                                                                                       // 6668
			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps);                                            // 6670
			}                                                                                                                   // 6671
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);                                                                                    // 6673
				return this._initProps(target, propLookup, siblings, overwrittenProps);                                            // 6674
			}                                                                                                                   // 6675
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;                                                                             // 6677
			}                                                                                                                   // 6678
			return initPlugins;                                                                                                 // 6679
		};                                                                                                                   // 6680
                                                                                                                       // 6681
		p.render = function(time, suppressEvents, force) {                                                                   // 6682
			var prevTime = this._time,                                                                                          // 6683
				duration = this._duration,                                                                                         // 6684
				prevRawPrevTime = this._rawPrevTime,                                                                               // 6685
				isComplete, callback, pt, rawPrevTime;                                                                             // 6686
			if (time >= duration) {                                                                                             // 6687
				this._totalTime = this._time = duration;                                                                           // 6688
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;                                                     // 6689
				if (!this._reversed ) {                                                                                            // 6690
					isComplete = true;                                                                                                // 6691
					callback = "onComplete";                                                                                          // 6692
				}                                                                                                                  // 6693
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;                                                                                                        // 6696
					}                                                                                                                 // 6697
					if (time === 0 || prevRawPrevTime < 0 || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;                                                                                                    // 6699
						if (prevRawPrevTime > _tinyNum) {                                                                                // 6700
							callback = "onReverseComplete";                                                                                 // 6701
						}                                                                                                                // 6702
					}                                                                                                                 // 6703
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}                                                                                                                  // 6705
                                                                                                                       // 6706
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;                                                                                  // 6708
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;                                                     // 6709
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {                                                   // 6710
					callback = "onReverseComplete";                                                                                   // 6711
					isComplete = this._reversed;                                                                                      // 6712
				}                                                                                                                  // 6713
				if (time < 0) {                                                                                                    // 6714
					this._active = false;                                                                                             // 6715
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {                        // 6717
							force = true;                                                                                                   // 6718
						}                                                                                                                // 6719
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}                                                                                                                 // 6721
				}                                                                                                                  // 6722
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;                                                                                                     // 6724
				}                                                                                                                  // 6725
			} else {                                                                                                            // 6726
				this._totalTime = this._time = time;                                                                               // 6727
                                                                                                                       // 6728
				if (this._easeType) {                                                                                              // 6729
					var r = time / duration, type = this._easeType, pow = this._easePower;                                            // 6730
					if (type === 1 || (type === 3 && r >= 0.5)) {                                                                     // 6731
						r = 1 - r;                                                                                                       // 6732
					}                                                                                                                 // 6733
					if (type === 3) {                                                                                                 // 6734
						r *= 2;                                                                                                          // 6735
					}                                                                                                                 // 6736
					if (pow === 1) {                                                                                                  // 6737
						r *= r;                                                                                                          // 6738
					} else if (pow === 2) {                                                                                           // 6739
						r *= r * r;                                                                                                      // 6740
					} else if (pow === 3) {                                                                                           // 6741
						r *= r * r * r;                                                                                                  // 6742
					} else if (pow === 4) {                                                                                           // 6743
						r *= r * r * r * r;                                                                                              // 6744
					}                                                                                                                 // 6745
                                                                                                                       // 6746
					if (type === 1) {                                                                                                 // 6747
						this.ratio = 1 - r;                                                                                              // 6748
					} else if (type === 2) {                                                                                          // 6749
						this.ratio = r;                                                                                                  // 6750
					} else if (time / duration < 0.5) {                                                                               // 6751
						this.ratio = r / 2;                                                                                              // 6752
					} else {                                                                                                          // 6753
						this.ratio = 1 - (r / 2);                                                                                        // 6754
					}                                                                                                                 // 6755
                                                                                                                       // 6756
				} else {                                                                                                           // 6757
					this.ratio = this._ease.getRatio(time / duration);                                                                // 6758
				}                                                                                                                  // 6759
			}                                                                                                                   // 6760
                                                                                                                       // 6761
			if (this._time === prevTime && !force) {                                                                            // 6762
				return;                                                                                                            // 6763
			} else if (!this._initted) {                                                                                        // 6764
				this._init();                                                                                                      // 6765
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;                                                                                                           // 6767
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;                                                                          // 6769
					this._rawPrevTime = prevRawPrevTime;                                                                              // 6770
					_lazyTweens.push(this);                                                                                           // 6771
					this._lazy = [time, suppressEvents];                                                                              // 6772
					return;                                                                                                           // 6773
				}                                                                                                                  // 6774
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {                                                                                   // 6776
					this.ratio = this._ease.getRatio(this._time / duration);                                                          // 6777
				} else if (isComplete && this._ease._calcEnd) {                                                                    // 6778
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);                                                     // 6779
				}                                                                                                                  // 6780
			}                                                                                                                   // 6781
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;                                                                                                // 6783
			}                                                                                                                   // 6784
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {                                     // 6785
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}                                                                                                                   // 6787
			if (prevTime === 0) {                                                                                               // 6788
				if (this._startAt) {                                                                                               // 6789
					if (time >= 0) {                                                                                                  // 6790
						this._startAt.render(time, suppressEvents, force);                                                               // 6791
					} else if (!callback) {                                                                                           // 6792
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}                                                                                                                 // 6794
				}                                                                                                                  // 6795
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {                              // 6796
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);                  // 6797
				}                                                                                                                  // 6798
			}                                                                                                                   // 6799
			pt = this._firstPT;                                                                                                 // 6800
			while (pt) {                                                                                                        // 6801
				if (pt.f) {                                                                                                        // 6802
					pt.t[pt.p](pt.c * this.ratio + pt.s);                                                                             // 6803
				} else {                                                                                                           // 6804
					pt.t[pt.p] = pt.c * this.ratio + pt.s;                                                                            // 6805
				}                                                                                                                  // 6806
				pt = pt._next;                                                                                                     // 6807
			}                                                                                                                   // 6808
                                                                                                                       // 6809
			if (this._onUpdate) {                                                                                               // 6810
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}                                                                                                                  // 6813
				if (!suppressEvents) if (this._time !== prevTime || isComplete) {                                                  // 6814
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);                   // 6815
				}                                                                                                                  // 6816
			}                                                                                                                   // 6817
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);                                                                // 6820
				}                                                                                                                  // 6821
				if (isComplete) {                                                                                                  // 6822
					if (this._timeline.autoRemoveChildren) {                                                                          // 6823
						this._enabled(false, false);                                                                                     // 6824
					}                                                                                                                 // 6825
					this._active = false;                                                                                             // 6826
				}                                                                                                                  // 6827
				if (!suppressEvents && this.vars[callback]) {                                                                      // 6828
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);  // 6829
				}                                                                                                                  // 6830
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;                                                                                            // 6832
				}                                                                                                                  // 6833
			}                                                                                                                   // 6834
		};                                                                                                                   // 6835
                                                                                                                       // 6836
		p._kill = function(vars, target, overwritingTween) {                                                                 // 6837
			if (vars === "all") {                                                                                               // 6838
				vars = null;                                                                                                       // 6839
			}                                                                                                                   // 6840
			if (vars == null) if (target == null || target === this.target) {                                                   // 6841
				this._lazy = false;                                                                                                // 6842
				return this._enabled(false, false);                                                                                // 6843
			}                                                                                                                   // 6844
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;                                     // 6846
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {                                  // 6847
				i = target.length;                                                                                                 // 6848
				while (--i > -1) {                                                                                                 // 6849
					if (this._kill(vars, target[i])) {                                                                                // 6850
						changed = true;                                                                                                  // 6851
					}                                                                                                                 // 6852
				}                                                                                                                  // 6853
			} else {                                                                                                            // 6854
				if (this._targets) {                                                                                               // 6855
					i = this._targets.length;                                                                                         // 6856
					while (--i > -1) {                                                                                                // 6857
						if (target === this._targets[i]) {                                                                               // 6858
							propLookup = this._propLookup[i] || {};                                                                         // 6859
							this._overwrittenProps = this._overwrittenProps || [];                                                          // 6860
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";                  // 6861
							break;                                                                                                          // 6862
						}                                                                                                                // 6863
					}                                                                                                                 // 6864
				} else if (target !== this.target) {                                                                               // 6865
					return false;                                                                                                     // 6866
				} else {                                                                                                           // 6867
					propLookup = this._propLookup;                                                                                    // 6868
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";                          // 6869
				}                                                                                                                  // 6870
                                                                                                                       // 6871
				if (propLookup) {                                                                                                  // 6872
					killProps = vars || propLookup;                                                                                   // 6873
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {                                       // 6875
						for (p in killProps) {                                                                                           // 6876
							if (propLookup[p]) {                                                                                            // 6877
								if (!killed) {                                                                                                 // 6878
									killed = [];                                                                                                  // 6879
								}                                                                                                              // 6880
								killed.push(p);                                                                                                // 6881
							}                                                                                                               // 6882
						}                                                                                                                // 6883
						if (!_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;                                                                                                   // 6885
						}                                                                                                                // 6886
					}                                                                                                                 // 6887
                                                                                                                       // 6888
					for (p in killProps) {                                                                                            // 6889
						if ((pt = propLookup[p])) {                                                                                      // 6890
							if (pt.pg && pt.t._kill(killProps)) {                                                                           // 6891
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first                     // 6892
							}                                                                                                               // 6893
							if (!pt.pg || pt.t._overwriteProps.length === 0) {                                                              // 6894
								if (pt._prev) {                                                                                                // 6895
									pt._prev._next = pt._next;                                                                                    // 6896
								} else if (pt === this._firstPT) {                                                                             // 6897
									this._firstPT = pt._next;                                                                                     // 6898
								}                                                                                                              // 6899
								if (pt._next) {                                                                                                // 6900
									pt._next._prev = pt._prev;                                                                                    // 6901
								}                                                                                                              // 6902
								pt._next = pt._prev = null;                                                                                    // 6903
							}                                                                                                               // 6904
							delete propLookup[p];                                                                                           // 6905
						}                                                                                                                // 6906
						if (record) {                                                                                                    // 6907
							overwrittenProps[p] = 1;                                                                                        // 6908
						}                                                                                                                // 6909
					}                                                                                                                 // 6910
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);                                                                                     // 6912
					}                                                                                                                 // 6913
				}                                                                                                                  // 6914
			}                                                                                                                   // 6915
			return changed;                                                                                                     // 6916
		};                                                                                                                   // 6917
                                                                                                                       // 6918
		p.invalidate = function() {                                                                                          // 6919
			if (this._notifyPluginsOfEnabled) {                                                                                 // 6920
				TweenLite._onPluginEvent("_onDisable", this);                                                                      // 6921
			}                                                                                                                   // 6922
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;                                     // 6923
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;                                                   // 6924
			this._propLookup = (this._targets) ? {} : [];                                                                       // 6925
			Animation.prototype.invalidate.call(this);                                                                          // 6926
			if (this.vars.immediateRender) {                                                                                    // 6927
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(-this._delay);                                                                                         // 6929
			}                                                                                                                   // 6930
			return this;                                                                                                        // 6931
		};                                                                                                                   // 6932
                                                                                                                       // 6933
		p._enabled = function(enabled, ignoreTimeline) {                                                                     // 6934
			if (!_tickerActive) {                                                                                               // 6935
				_ticker.wake();                                                                                                    // 6936
			}                                                                                                                   // 6937
			if (enabled && this._gc) {                                                                                          // 6938
				var targets = this._targets,                                                                                       // 6939
					i;                                                                                                                // 6940
				if (targets) {                                                                                                     // 6941
					i = targets.length;                                                                                               // 6942
					while (--i > -1) {                                                                                                // 6943
						this._siblings[i] = _register(targets[i], this, true);                                                           // 6944
					}                                                                                                                 // 6945
				} else {                                                                                                           // 6946
					this._siblings = _register(this.target, this, true);                                                              // 6947
				}                                                                                                                  // 6948
			}                                                                                                                   // 6949
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);                                                   // 6950
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {                                                              // 6951
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);                                     // 6952
			}                                                                                                                   // 6953
			return false;                                                                                                       // 6954
		};                                                                                                                   // 6955
                                                                                                                       // 6956
                                                                                                                       // 6957
//----TweenLite static methods -----------------------------------------------------                                   // 6958
                                                                                                                       // 6959
		TweenLite.to = function(target, duration, vars) {                                                                    // 6960
			return new TweenLite(target, duration, vars);                                                                       // 6961
		};                                                                                                                   // 6962
                                                                                                                       // 6963
		TweenLite.from = function(target, duration, vars) {                                                                  // 6964
			vars.runBackwards = true;                                                                                           // 6965
			vars.immediateRender = (vars.immediateRender != false);                                                             // 6966
			return new TweenLite(target, duration, vars);                                                                       // 6967
		};                                                                                                                   // 6968
                                                                                                                       // 6969
		TweenLite.fromTo = function(target, duration, fromVars, toVars) {                                                    // 6970
			toVars.startAt = fromVars;                                                                                          // 6971
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);                    // 6972
			return new TweenLite(target, duration, toVars);                                                                     // 6973
		};                                                                                                                   // 6974
                                                                                                                       // 6975
		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {                                        // 6976
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};                                                                                                                   // 6978
                                                                                                                       // 6979
		TweenLite.set = function(target, vars) {                                                                             // 6980
			return new TweenLite(target, 0, vars);                                                                              // 6981
		};                                                                                                                   // 6982
                                                                                                                       // 6983
		TweenLite.getTweensOf = function(target, onlyActive) {                                                               // 6984
			if (target == null) { return []; }                                                                                  // 6985
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;                             // 6986
			var i, a, j, t;                                                                                                     // 6987
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {                                  // 6988
				i = target.length;                                                                                                 // 6989
				a = [];                                                                                                            // 6990
				while (--i > -1) {                                                                                                 // 6991
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));                                                       // 6992
				}                                                                                                                  // 6993
				i = a.length;                                                                                                      // 6994
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)                               // 6995
				while (--i > -1) {                                                                                                 // 6996
					t = a[i];                                                                                                         // 6997
					j = i;                                                                                                            // 6998
					while (--j > -1) {                                                                                                // 6999
						if (t === a[j]) {                                                                                                // 7000
							a.splice(i, 1);                                                                                                 // 7001
						}                                                                                                                // 7002
					}                                                                                                                 // 7003
				}                                                                                                                  // 7004
			} else {                                                                                                            // 7005
				a = _register(target).concat();                                                                                    // 7006
				i = a.length;                                                                                                      // 7007
				while (--i > -1) {                                                                                                 // 7008
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {                                                               // 7009
						a.splice(i, 1);                                                                                                  // 7010
					}                                                                                                                 // 7011
				}                                                                                                                  // 7012
			}                                                                                                                   // 7013
			return a;                                                                                                           // 7014
		};                                                                                                                   // 7015
                                                                                                                       // 7016
		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {                         // 7017
			if (typeof(onlyActive) === "object") {                                                                              // 7018
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)                      // 7019
				onlyActive = false;                                                                                                // 7020
			}                                                                                                                   // 7021
			var a = TweenLite.getTweensOf(target, onlyActive),                                                                  // 7022
				i = a.length;                                                                                                      // 7023
			while (--i > -1) {                                                                                                  // 7024
				a[i]._kill(vars, target);                                                                                          // 7025
			}                                                                                                                   // 7026
		};                                                                                                                   // 7027
                                                                                                                       // 7028
                                                                                                                       // 7029
                                                                                                                       // 7030
/*                                                                                                                     // 7031
 * ----------------------------------------------------------------                                                    // 7032
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------                                                    // 7034
 */                                                                                                                    // 7035
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {                                          // 7036
					this._overwriteProps = (props || "").split(",");                                                                  // 7037
					this._propName = this._overwriteProps[0];                                                                         // 7038
					this._priority = priority || 0;                                                                                   // 7039
					this._super = TweenPlugin.prototype;                                                                              // 7040
				}, true);                                                                                                          // 7041
                                                                                                                       // 7042
		p = TweenPlugin.prototype;                                                                                           // 7043
		TweenPlugin.version = "1.10.1";                                                                                      // 7044
		TweenPlugin.API = 2;                                                                                                 // 7045
		p._firstPT = null;                                                                                                   // 7046
                                                                                                                       // 7047
		p._addTween = function(target, prop, start, end, overwriteProp, round) {                                             // 7048
			var c, pt;                                                                                                          // 7049
			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
				this._firstPT = pt = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
				if (pt._next) {                                                                                                    // 7052
					pt._next._prev = pt;                                                                                              // 7053
				}                                                                                                                  // 7054
				return pt;                                                                                                         // 7055
			}                                                                                                                   // 7056
		};                                                                                                                   // 7057
                                                                                                                       // 7058
		p.setRatio = function(v) {                                                                                           // 7059
			var pt = this._firstPT,                                                                                             // 7060
				min = 0.000001,                                                                                                    // 7061
				val;                                                                                                               // 7062
			while (pt) {                                                                                                        // 7063
				val = pt.c * v + pt.s;                                                                                             // 7064
				if (pt.r) {                                                                                                        // 7065
					val = Math.round(val);                                                                                            // 7066
				} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
					val = 0;                                                                                                          // 7068
				}                                                                                                                  // 7069
				if (pt.f) {                                                                                                        // 7070
					pt.t[pt.p](val);                                                                                                  // 7071
				} else {                                                                                                           // 7072
					pt.t[pt.p] = val;                                                                                                 // 7073
				}                                                                                                                  // 7074
				pt = pt._next;                                                                                                     // 7075
			}                                                                                                                   // 7076
		};                                                                                                                   // 7077
                                                                                                                       // 7078
		p._kill = function(lookup) {                                                                                         // 7079
			var a = this._overwriteProps,                                                                                       // 7080
				pt = this._firstPT,                                                                                                // 7081
				i;                                                                                                                 // 7082
			if (lookup[this._propName] != null) {                                                                               // 7083
				this._overwriteProps = [];                                                                                         // 7084
			} else {                                                                                                            // 7085
				i = a.length;                                                                                                      // 7086
				while (--i > -1) {                                                                                                 // 7087
					if (lookup[a[i]] != null) {                                                                                       // 7088
						a.splice(i, 1);                                                                                                  // 7089
					}                                                                                                                 // 7090
				}                                                                                                                  // 7091
			}                                                                                                                   // 7092
			while (pt) {                                                                                                        // 7093
				if (lookup[pt.n] != null) {                                                                                        // 7094
					if (pt._next) {                                                                                                   // 7095
						pt._next._prev = pt._prev;                                                                                       // 7096
					}                                                                                                                 // 7097
					if (pt._prev) {                                                                                                   // 7098
						pt._prev._next = pt._next;                                                                                       // 7099
						pt._prev = null;                                                                                                 // 7100
					} else if (this._firstPT === pt) {                                                                                // 7101
						this._firstPT = pt._next;                                                                                        // 7102
					}                                                                                                                 // 7103
				}                                                                                                                  // 7104
				pt = pt._next;                                                                                                     // 7105
			}                                                                                                                   // 7106
			return false;                                                                                                       // 7107
		};                                                                                                                   // 7108
                                                                                                                       // 7109
		p._roundProps = function(lookup, value) {                                                                            // 7110
			var pt = this._firstPT;                                                                                             // 7111
			while (pt) {                                                                                                        // 7112
				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					pt.r = value;                                                                                                     // 7114
				}                                                                                                                  // 7115
				pt = pt._next;                                                                                                     // 7116
			}                                                                                                                   // 7117
		};                                                                                                                   // 7118
                                                                                                                       // 7119
		TweenLite._onPluginEvent = function(type, tween) {                                                                   // 7120
			var pt = tween._firstPT,                                                                                            // 7121
				changed, pt2, first, last, next;                                                                                   // 7122
			if (type === "_onInitAllProps") {                                                                                   // 7123
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {                                                                                                       // 7125
					next = pt._next;                                                                                                  // 7126
					pt2 = first;                                                                                                      // 7127
					while (pt2 && pt2.pr > pt.pr) {                                                                                   // 7128
						pt2 = pt2._next;                                                                                                 // 7129
					}                                                                                                                 // 7130
					if ((pt._prev = pt2 ? pt2._prev : last)) {                                                                        // 7131
						pt._prev._next = pt;                                                                                             // 7132
					} else {                                                                                                          // 7133
						first = pt;                                                                                                      // 7134
					}                                                                                                                 // 7135
					if ((pt._next = pt2)) {                                                                                           // 7136
						pt2._prev = pt;                                                                                                  // 7137
					} else {                                                                                                          // 7138
						last = pt;                                                                                                       // 7139
					}                                                                                                                 // 7140
					pt = next;                                                                                                        // 7141
				}                                                                                                                  // 7142
				pt = tween._firstPT = first;                                                                                       // 7143
			}                                                                                                                   // 7144
			while (pt) {                                                                                                        // 7145
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {                                              // 7146
					changed = true;                                                                                                   // 7147
				}                                                                                                                  // 7148
				pt = pt._next;                                                                                                     // 7149
			}                                                                                                                   // 7150
			return changed;                                                                                                     // 7151
		};                                                                                                                   // 7152
                                                                                                                       // 7153
		TweenPlugin.activate = function(plugins) {                                                                           // 7154
			var i = plugins.length;                                                                                             // 7155
			while (--i > -1) {                                                                                                  // 7156
				if (plugins[i].API === TweenPlugin.API) {                                                                          // 7157
					_plugins[(new plugins[i]())._propName] = plugins[i];                                                              // 7158
				}                                                                                                                  // 7159
			}                                                                                                                   // 7160
			return true;                                                                                                        // 7161
		};                                                                                                                   // 7162
                                                                                                                       // 7163
		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {                                                                                // 7165
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }             // 7166
			var propName = config.propName,                                                                                     // 7167
				priority = config.priority || 0,                                                                                   // 7168
				overwriteProps = config.overwriteProps,                                                                            // 7169
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_roundProps", initAll:"_onInitAllProps"},         // 7170
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",                     // 7171
					function() {                                                                                                      // 7172
						TweenPlugin.call(this, propName, priority);                                                                      // 7173
						this._overwriteProps = overwriteProps || [];                                                                     // 7174
					}, (config.global === true)),                                                                                     // 7175
				p = Plugin.prototype = new TweenPlugin(propName),                                                                  // 7176
				prop;                                                                                                              // 7177
			p.constructor = Plugin;                                                                                             // 7178
			Plugin.API = config.API;                                                                                            // 7179
			for (prop in map) {                                                                                                 // 7180
				if (typeof(config[prop]) === "function") {                                                                         // 7181
					p[map[prop]] = config[prop];                                                                                      // 7182
				}                                                                                                                  // 7183
			}                                                                                                                   // 7184
			Plugin.version = config.version;                                                                                    // 7185
			TweenPlugin.activate([Plugin]);                                                                                     // 7186
			return Plugin;                                                                                                      // 7187
		};                                                                                                                   // 7188
                                                                                                                       // 7189
                                                                                                                       // 7190
		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;                                                                                                 // 7192
		if (a) {                                                                                                             // 7193
			for (i = 0; i < a.length; i++) {                                                                                    // 7194
				a[i]();                                                                                                            // 7195
			}                                                                                                                   // 7196
			for (p in _defLookup) {                                                                                             // 7197
				if (!_defLookup[p].func) {                                                                                         // 7198
					window.console.log("GSAP encountered missing dependency: com.greensock." + p);                                    // 7199
				}                                                                                                                  // 7200
			}                                                                                                                   // 7201
		}                                                                                                                    // 7202
                                                                                                                       // 7203
		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated
                                                                                                                       // 7205
})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/infinitedg:gsap/vendor/GreenSock-JS/src/uncompressed/plugins/ColorPropsPlugin.js                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*!                                                                                                                    // 1
 * VERSION: beta 1.3.0                                                                                                 // 2
 * DATE: 2015-02-06                                                                                                    // 3
 * UPDATES AND DOCS AT: http://greensock.com                                                                           // 4
 *                                                                                                                     // 5
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.                                                   // 6
 * This work is subject to the terms at http://greensock.com/standard-license or for                                   // 7
 * Club GreenSock members, the software agreement that was issued with your membership.                                // 8
 *                                                                                                                     // 9
 * @author: Jack Doyle, jack@greensock.com                                                                             // 10
 **/                                                                                                                   // 11
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {                                                     // 13
                                                                                                                       // 14
	"use strict";                                                                                                         // 15
                                                                                                                       // 16
	var _numExp = /(\d|\.)+/g,                                                                                            // 17
		_colorLookup = {aqua:[0,255,255],                                                                                    // 18
			lime:[0,255,0],                                                                                                     // 19
			silver:[192,192,192],                                                                                               // 20
			black:[0,0,0],                                                                                                      // 21
			maroon:[128,0,0],                                                                                                   // 22
			teal:[0,128,128],                                                                                                   // 23
			blue:[0,0,255],                                                                                                     // 24
			navy:[0,0,128],                                                                                                     // 25
			white:[255,255,255],                                                                                                // 26
			fuchsia:[255,0,255],                                                                                                // 27
			olive:[128,128,0],                                                                                                  // 28
			yellow:[255,255,0],                                                                                                 // 29
			orange:[255,165,0],                                                                                                 // 30
			gray:[128,128,128],                                                                                                 // 31
			purple:[128,0,128],                                                                                                 // 32
			green:[0,128,0],                                                                                                    // 33
			red:[255,0,0],                                                                                                      // 34
			pink:[255,192,203],                                                                                                 // 35
			cyan:[0,255,255],                                                                                                   // 36
			transparent:[255,255,255,0]},                                                                                       // 37
		_hue = function(h, m1, m2) {                                                                                         // 38
			h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;                                                                          // 39
			return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
		},                                                                                                                   // 41
		_parseColor = function(color) {                                                                                      // 42
			if (color === "" || color == null || color === "none") {                                                            // 43
				return _colorLookup.transparent;                                                                                   // 44
			}                                                                                                                   // 45
			if (_colorLookup[color]) {                                                                                          // 46
				return _colorLookup[color];                                                                                        // 47
			}                                                                                                                   // 48
			if (typeof(color) === "number") {                                                                                   // 49
				return [color >> 16, (color >> 8) & 255, color & 255];                                                             // 50
			}                                                                                                                   // 51
			if (color.charAt(0) === "#") {                                                                                      // 52
				if (color.length === 4) { //for shorthand like #9F0                                                                // 53
					color = "#" + color.charAt(1) + color.charAt(1) + color.charAt(2) + color.charAt(2) + color.charAt(3) + color.charAt(3);
				}                                                                                                                  // 55
				color = parseInt(color.substr(1), 16);                                                                             // 56
				return [color >> 16, (color >> 8) & 255, color & 255];                                                             // 57
			}                                                                                                                   // 58
			if (color.substr(0, 3) === "hsl") {                                                                                 // 59
				color = color.match(_numExp);                                                                                      // 60
				var h = (Number(color[0]) % 360) / 360,                                                                            // 61
					s = Number(color[1]) / 100,                                                                                       // 62
					l = Number(color[2]) / 100,                                                                                       // 63
					m2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s,                                                                    // 64
					m1 = l * 2 - m2;                                                                                                  // 65
				if (color.length > 3) {                                                                                            // 66
					color[3] = Number(color[3]);                                                                                      // 67
				}                                                                                                                  // 68
				color[0] = _hue(h + 1 / 3, m1, m2);                                                                                // 69
				color[1] = _hue(h, m1, m2);                                                                                        // 70
				color[2] = _hue(h - 1 / 3, m1, m2);                                                                                // 71
				return color;                                                                                                      // 72
			}                                                                                                                   // 73
			return color.match(_numExp) || _colorLookup.transparent;                                                            // 74
		};                                                                                                                   // 75
                                                                                                                       // 76
	_gsScope._gsDefine.plugin({                                                                                           // 77
		propName: "colorProps",                                                                                              // 78
		version: "1.3.0",                                                                                                    // 79
		priority: -1,                                                                                                        // 80
		API: 2,                                                                                                              // 81
                                                                                                                       // 82
		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {                                                                               // 84
			this._target = target;                                                                                              // 85
			var p, s, c, pt;                                                                                                    // 86
			this.numFormat = (value.format === "number");                                                                       // 87
			for (p in value) {                                                                                                  // 88
				if (p !== "format") {                                                                                              // 89
					c = _parseColor(value[p]);                                                                                        // 90
					this._firstPT = pt = {_next:this._firstPT, p:p, f:(typeof(target[p]) === "function"), n:p, r:false};              // 91
					s = _parseColor( (!pt.f) ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					pt.s = Number(s[0]);                                                                                              // 93
					pt.c = Number(c[0]) - pt.s;                                                                                       // 94
					pt.gs = Number(s[1]);                                                                                             // 95
					pt.gc = Number(c[1]) - pt.gs;                                                                                     // 96
					pt.bs = Number(s[2]);                                                                                             // 97
					pt.bc = Number(c[2]) - pt.bs;                                                                                     // 98
					if ((pt.rgba = (s.length > 3 || c.length > 3))) { //detect an rgba() value                                        // 99
						pt.as = (s.length < 4) ? 1 : Number(s[3]);                                                                       // 100
						pt.ac = ((c.length < 4) ? 1 : Number(c[3])) - pt.as;                                                             // 101
					}                                                                                                                 // 102
					if (pt._next) {                                                                                                   // 103
						pt._next._prev = pt;                                                                                             // 104
					}                                                                                                                 // 105
				}                                                                                                                  // 106
			}                                                                                                                   // 107
			return true;                                                                                                        // 108
		},                                                                                                                   // 109
                                                                                                                       // 110
		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(v) {                                                                                                   // 112
			var pt = this._firstPT, val;                                                                                        // 113
			while (pt) {                                                                                                        // 114
				val = this.numFormat ? (pt.s + (v * pt.c)) << 16 | (pt.gs + (v * pt.gc)) << 8 | (pt.bs + (v * pt.bc)) : (pt.rgba ? "rgba(" : "rgb(") + ((pt.s + (v * pt.c)) >> 0) + ", " + ((pt.gs + (v * pt.gc)) >> 0) + ", " + ((pt.bs + (v * pt.bc)) >> 0) + (pt.rgba ? ", " + (pt.as + (v * pt.ac)) : "") + ")";
				if (pt.f) {                                                                                                        // 116
					this._target[pt.p](val);                                                                                          // 117
				} else {                                                                                                           // 118
					this._target[pt.p] = val;                                                                                         // 119
				}                                                                                                                  // 120
				pt = pt._next;                                                                                                     // 121
			}                                                                                                                   // 122
		}                                                                                                                    // 123
	});                                                                                                                   // 124
                                                                                                                       // 125
}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }                                                             // 126
                                                                                                                       // 127
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['infinitedg:gsap'] = {};

})();
